{"ast":null,"code":"import earcut from 'earcut';\nimport { modifyPolygonWindingDirection, WINDING } from '@math.gl/polygon';\nconst OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;\nconst HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;\nconst windingOptions = {\n  isClosed: true\n};\n\nfunction validate(polygon) {\n  polygon = polygon && polygon.positions || polygon;\n\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\nexport function getPositions(polygon) {\n  return 'positions' in polygon ? polygon.positions : polygon;\n}\nexport function getHoleIndices(polygon) {\n  return 'holeIndices' in polygon ? polygon.holeIndices : null;\n}\n\nfunction isNested(polygon) {\n  return Array.isArray(polygon[0]);\n}\n\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\nfunction isNestedRingClosed(simplePolygon) {\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n  return targetIndex;\n}\n\nfunction copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n  return targetIndex;\n}\n\nexport function normalize(polygon, positionSize) {\n  validate(polygon);\n  const positions = [];\n  const holeIndices = [];\n\n  if ('positions' in polygon) {\n    const {\n      positions: srcPositions,\n      holeIndices: srcHoleIndices\n    } = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n        holeIndices.push(targetIndex);\n      }\n\n      holeIndices.pop();\n      return {\n        positions,\n        holeIndices\n      };\n    }\n\n    polygon = srcPositions;\n  }\n\n  if (!isNested(polygon)) {\n    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);\n    return positions;\n  }\n\n  if (!isSimple(polygon)) {\n    let targetIndex = 0;\n\n    for (const [polygonIndex, simplePolygon] of polygon.entries()) {\n      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n      holeIndices.push(targetIndex);\n    }\n\n    holeIndices.pop();\n    return {\n      positions,\n      holeIndices\n    };\n  }\n\n  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);\n  return positions;\n}\nexport function getSurfaceIndices(polygon, positionSize, preproject) {\n  let holeIndices = getHoleIndices(polygon);\n\n  if (holeIndices) {\n    holeIndices = holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n\n  let positions = getPositions(polygon);\n\n  if (preproject) {\n    const n = positions.length;\n    positions = positions.slice();\n    const p = [];\n\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n      const xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n    }\n  }\n\n  return earcut(positions, holeIndices, positionSize);\n}","map":{"version":3,"sources":["../../../src/solid-polygon-layer/polygon.ts"],"names":["OUTER_POLYGON_WINDING","WINDING","HOLE_POLYGON_WINDING","windingOptions","isClosed","polygon","Array","ArrayBuffer","Number","p0","simplePolygon","p1","i","positions","startIndex","endIndex","targetIndex","len","j","target","isNestedRingClosed","modifyPolygonWindingDirection","srcStartIndex","srcEndIndex","srcLength","isFlatRingClosed","validate","holeIndices","srcHoleIndices","copyFlatRing","isNested","isSimple","copyNestedRing","polygonIndex","getHoleIndices","positionIndex","getPositions","n","p","xy","preproject","earcut"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable max-params */\nimport earcut from 'earcut';\nimport {modifyPolygonWindingDirection, WINDING} from '@math.gl/polygon';\n\nimport type {Position} from '@deck.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nconst OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;\nconst HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;\n\ntype WindingOptions = {\n  start?: number;\n  end?: number;\n  size?: number;\n  isClosed?: boolean;\n};\n\n/** A scratch object for sending winding options */\nconst windingOptions: WindingOptions = {\n  isClosed: true\n};\n\n// 4 data formats are supported:\n\n/** Simple Polygon: an array of points */\nexport type NestedSimplePolygonGeometry = Position[];\n/** Complex Polygon: an array of array of points (array of rings)\n * with the first ring representing the outer hull and other rings representing holes\n */\nexport type NestedComplexPolygonGeometry = Position[][];\n/** An array of numbers (flattened \"simple polygon\") */\nexport type FlatSimplePolygonGeometry = NumericArray;\n/** Flattened \"complex polygon\" */\nexport type FlatComplexPolygonGeometry = {positions: NumericArray; holeIndices: NumericArray};\n\nexport type PolygonGeometry =\n  | NestedSimplePolygonGeometry\n  | NestedComplexPolygonGeometry\n  | FlatSimplePolygonGeometry\n  | FlatComplexPolygonGeometry;\n\nexport type NormalizedPolygonGeometry = FlatSimplePolygonGeometry | FlatComplexPolygonGeometry;\n\n/**\n * Ensure a polygon is valid format\n */\nfunction validate(polygon: PolygonGeometry): void {\n  polygon = (polygon && (polygon as FlatComplexPolygonGeometry).positions) || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\n/** Get the positions from a normalized polygon */\nexport function getPositions(polygon: NormalizedPolygonGeometry): NumericArray {\n  return 'positions' in polygon ? polygon.positions : polygon;\n}\n\n/** Get the hole indices from a normalized polygon */\nexport function getHoleIndices(polygon: NormalizedPolygonGeometry): NumericArray | null {\n  return 'holeIndices' in polygon ? polygon.holeIndices : null;\n}\n\n/**\n * Check if a polygon is nested or flat\n * Returns true if the polygon is a flat polygon (i.e. not an array of polygons)\n */\nfunction isNested(\n  polygon: PolygonGeometry\n): polygon is NestedSimplePolygonGeometry | NestedComplexPolygonGeometry {\n  return Array.isArray(polygon[0]);\n}\n\n/**\n * Check if a polygon is simple or complex\n * Returns true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(\n  polygon: NestedSimplePolygonGeometry | NestedComplexPolygonGeometry\n): polygon is NestedSimplePolygonGeometry {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Check if a simple polygon is a closed ring\n * Returns true if the simple polygon is a closed ring\n */\nfunction isNestedRingClosed(simplePolygon: NestedSimplePolygonGeometry): boolean {\n  // check if first and last vertex are the same\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\n/**\n * Check if a simple flat array is a closed ring\n * Returns true if the simple flat array is a closed ring\n */\nfunction isFlatRingClosed(\n  positions: FlatSimplePolygonGeometry,\n  /** size of a position, 2 (xy) or 3 (xyz) */\n  size: number,\n  /** start index of the path in the positions array */\n  startIndex: number,\n  /** end index of the path in the positions array */\n  endIndex: number\n): boolean {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy a simple polygon coordinates into a flat array, closes the ring if needed.\n * Returns the index of the write head in the destination\n */\nfunction copyNestedRing(\n  /** destination */\n  target: NumericArray,\n  /** index in the destination to start copying into */\n  targetStartIndex: number,\n  /** the source polygon */\n  simplePolygon: NestedSimplePolygonGeometry,\n  /** size of a position, 2 (xy) or 3 (xyz) */\n  size: number,\n  /** modify polygon to be of the specified winding direction */\n  windingDirection: number\n): number {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n\n  return targetIndex;\n}\n\n/**\n * Copy a simple flat array into another flat array, closes the ring if needed.\n * Returns the index of the write head in the destination\n */\nfunction copyFlatRing(\n  /** destination */\n  target: NumericArray,\n  /** index in the destination to start copying into */\n  targetStartIndex: number,\n  /** the source polygon */\n  positions: FlatSimplePolygonGeometry,\n  /** size of a position, 2 (xy) or 3 (xyz) */\n  size: number,\n  /** start index of the path in the positions array */\n  srcStartIndex: number = 0,\n  /** end index of the path in the positions array */\n  srcEndIndex: number,\n  windingDirection: number\n): number {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n\n  return targetIndex;\n}\n\n/**\n * Normalize any polygon representation into the \"complex flat\" format\n */\n/* eslint-disable max-statements */\nexport function normalize(\n  polygon: PolygonGeometry,\n  positionSize: number\n): NormalizedPolygonGeometry {\n  validate(polygon);\n\n  const positions: number[] = [];\n  const holeIndices: number[] = [];\n\n  if ('positions' in polygon) {\n    // complex flat\n    const {positions: srcPositions, holeIndices: srcHoleIndices} = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(\n          positions,\n          targetIndex,\n          srcPositions,\n          positionSize,\n          srcHoleIndices[i - 1],\n          srcHoleIndices[i],\n          i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING\n        );\n        holeIndices.push(targetIndex);\n      }\n      // The last one is not a starting index of a hole, remove\n      holeIndices.pop();\n\n      return {positions, holeIndices};\n    }\n    polygon = srcPositions;\n  }\n  if (!isNested(polygon)) {\n    // simple flat\n    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let targetIndex = 0;\n\n    for (const [polygonIndex, simplePolygon] of polygon.entries()) {\n      targetIndex = copyNestedRing(\n        positions,\n        targetIndex,\n        simplePolygon,\n        positionSize,\n        polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING\n      );\n      holeIndices.push(targetIndex);\n    }\n    // The last one is not a starting index of a hole, remove\n    holeIndices.pop();\n    // last index points to the end of the array, remove it\n    return {positions, holeIndices};\n  }\n  // simple polygon\n  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);\n  return positions;\n}\n/* eslint-enable max-statements */\n\n/*\n * Get vertex indices for drawing polygon mesh (triangulation)\n */\nexport function getSurfaceIndices(\n  polygon: NormalizedPolygonGeometry,\n  positionSize: number,\n  preproject?: (xy: number[]) => number[]\n): number[] {\n  let holeIndices = getHoleIndices(polygon);\n  if (holeIndices) {\n    holeIndices = holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n\n  let positions = getPositions(polygon);\n\n  if (preproject) {\n    // When tesselating lnglat coordinates, project them to the common space for accuracy\n    const n = positions.length;\n    // Clone the array\n    positions = positions.slice();\n    const p: number[] = [];\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n      const xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n    }\n  }\n\n  // Let earcut triangulate the polygon\n  return earcut(positions, holeIndices, positionSize);\n}\n"]},"metadata":{},"sourceType":"module"}