{"ast":null,"code":"export function replaceInRange({\n  data,\n  getIndex,\n  dataRange,\n  replace\n}) {\n  const {\n    startRow = 0,\n    endRow = Infinity\n  } = dataRange;\n  const count = data.length;\n  let replaceStart = count;\n  let replaceEnd = count;\n\n  for (let i = 0; i < count; i++) {\n    const row = getIndex(data[i]);\n\n    if (replaceStart > i && row >= startRow) {\n      replaceStart = i;\n    }\n\n    if (row >= endRow) {\n      replaceEnd = i;\n      break;\n    }\n  }\n\n  let index = replaceStart;\n  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;\n  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : undefined;\n\n  for (let i = 0; i < replace.length; i++) {\n    data[index++] = replace[i];\n  }\n\n  if (endChunk) {\n    for (let i = 0; i < endChunk.length; i++) {\n      data[index++] = endChunk[i];\n    }\n\n    data.length = index;\n  }\n\n  return {\n    startRow: replaceStart,\n    endRow: replaceStart + replace.length\n  };\n}","map":{"version":3,"sources":["../../src/utils.ts"],"names":["replace","startRow","endRow","Infinity","count","data","replaceStart","replaceEnd","i","row","getIndex","index","dataLengthChanged","endChunk","length"],"mappings":"AAIA,OAAO,SAAA,cAAA,CAAwB;AAAA,EAAA,IAAA;AAAA,EAAA,QAAA;AAAA,EAAA,SAAA;AAI7BA,EAAAA;AAJ6B,CAAxB,EAUgC;AACrC,QAAM;AAACC,IAAAA,QAAQ,GAAT,CAAA;AAAeC,IAAAA,MAAM,GAAGC;AAAxB,MAAN,SAAA;AACA,QAAMC,KAAK,GAAGC,IAAI,CAAlB,MAAA;AACA,MAAIC,YAAY,GAAhB,KAAA;AACA,MAAIC,UAAU,GAAd,KAAA;;AACA,OAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,KAAA,EAA2BA,CAA3B,EAAA,EAAgC;AAC9B,UAAMC,GAAG,GAAGC,QAAQ,CAACL,IAAI,CAAzB,CAAyB,CAAL,CAApB;;AACA,QAAIC,YAAY,GAAZA,CAAAA,IAAoBG,GAAG,IAA3B,QAAA,EAAyC;AACvCH,MAAAA,YAAY,GAAZA,CAAAA;AACD;;AACD,QAAIG,GAAG,IAAP,MAAA,EAAmB;AACjBF,MAAAA,UAAU,GAAVA,CAAAA;AACA;AACD;AACF;;AACD,MAAII,KAAK,GAAT,YAAA;AACA,QAAMC,iBAAiB,GAAGL,UAAU,GAAVA,YAAAA,KAA8BP,OAAO,CAA/D,MAAA;AAEA,QAAMa,QAAQ,GAAGD,iBAAiB,GAAGP,IAAI,CAAJA,KAAAA,CAAH,UAAGA,CAAH,GAAlC,SAAA;;AAEA,OAAK,IAAIG,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGR,OAAO,CAA3B,MAAA,EAAoCQ,CAApC,EAAA,EAAyC;AACvCH,IAAAA,IAAI,CAACM,KAALN,EAAI,CAAJA,GAAgBL,OAAO,CAAvBK,CAAuB,CAAvBA;AACD;;AACD,MAAA,QAAA,EAAc;AAEZ,SAAK,IAAIG,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGK,QAAQ,CAA5B,MAAA,EAAqCL,CAArC,EAAA,EAA0C;AACxCH,MAAAA,IAAI,CAACM,KAALN,EAAI,CAAJA,GAAgBQ,QAAQ,CAAxBR,CAAwB,CAAxBA;AACD;;AAEDA,IAAAA,IAAI,CAAJA,MAAAA,GAAAA,KAAAA;AACD;;AAED,SAAO;AACLJ,IAAAA,QAAQ,EADH,YAAA;AAELC,IAAAA,MAAM,EAAEI,YAAY,GAAGN,OAAO,CAACc;AAF1B,GAAP;AAID","sourcesContent":["// Assume data array is sorted by <accessor>\n// Replaces the specified range with a new subarray\n// Mutates the data array\n// Returns {startRow, endRow} of the inserted items\nexport function replaceInRange({\n  data,\n  getIndex,\n  dataRange,\n  replace\n}: {\n  data: any[];\n  getIndex: (d: any) => number;\n  dataRange: {startRow?: number; endRow?: number};\n  replace: any[];\n}): {startRow: Number; endRow: number} {\n  const {startRow = 0, endRow = Infinity} = dataRange;\n  const count = data.length;\n  let replaceStart = count;\n  let replaceEnd = count;\n  for (let i = 0; i < count; i++) {\n    const row = getIndex(data[i]);\n    if (replaceStart > i && row >= startRow) {\n      replaceStart = i;\n    }\n    if (row >= endRow) {\n      replaceEnd = i;\n      break;\n    }\n  }\n  let index = replaceStart;\n  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;\n  // Save the items after replaceEnd before we overwrite data\n  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : undefined;\n  // Insert new items\n  for (let i = 0; i < replace.length; i++) {\n    data[index++] = replace[i];\n  }\n  if (endChunk) {\n    // Append items after replaceEnd\n    for (let i = 0; i < endChunk.length; i++) {\n      data[index++] = endChunk[i];\n    }\n    // Trim additional items\n    data.length = index;\n  }\n\n  return {\n    startRow: replaceStart,\n    endRow: replaceStart + replace.length\n  };\n}\n"]},"metadata":{},"sourceType":"module"}