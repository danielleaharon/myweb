{"ast":null,"code":"import { whichButtons, getOffsetPosition } from './event-utils';\nconst DEFAULT_OPTIONS = {\n  srcElement: 'root',\n  priority: 0\n};\nexport default class EventRegistrar {\n  constructor(eventManager) {\n    /**\n     * Handles hammerjs event\n     */\n    this.handleEvent = event => {\n      if (this.isEmpty()) {\n        return;\n      }\n\n      const mjolnirEvent = this._normalizeEvent(event);\n\n      let target = event.srcEvent.target;\n\n      while (target && target !== mjolnirEvent.rootElement) {\n        this._emit(mjolnirEvent, target);\n\n        if (mjolnirEvent.handled) {\n          return;\n        }\n\n        target = target.parentNode;\n      }\n\n      this._emit(mjolnirEvent, 'root');\n    };\n\n    this.eventManager = eventManager;\n    this.handlers = []; // Element -> handler map\n\n    this.handlersByElement = new Map();\n    this._active = false;\n  } // Returns true if there are no non-passive handlers\n\n\n  isEmpty() {\n    return !this._active;\n  }\n\n  add(type, handler, options, once = false, passive = false) {\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n    let opts = DEFAULT_OPTIONS;\n\n    if (typeof options === 'string' || options && options.addEventListener) {\n      // is DOM element, backward compatibility\n      // @ts-ignore\n      opts = { ...DEFAULT_OPTIONS,\n        srcElement: options\n      };\n    } else if (options) {\n      opts = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n    }\n\n    let entries = handlersByElement.get(opts.srcElement);\n\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n\n    const entry = {\n      type,\n      handler,\n      srcElement: opts.srcElement,\n      priority: opts.priority\n    };\n\n    if (once) {\n      entry.once = true;\n    }\n\n    if (passive) {\n      entry.passive = true;\n    }\n\n    handlers.push(entry);\n    this._active = this._active || !entry.passive; // Sort handlers by descending priority\n    // Handlers with the same priority are excuted in the order of registration\n\n    let insertPosition = entries.length - 1;\n\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n\n      insertPosition--;\n    }\n\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n\n  remove(type, handler) {\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement);\n        entries.splice(entries.indexOf(entry), 1);\n\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n\n    this._active = handlers.some(entry => !entry.passive);\n  }\n  /**\n   * Invoke handlers on a particular element\n   */\n\n\n  _emit(event, srcElement) {\n    const entries = this.handlersByElement.get(srcElement);\n\n    if (entries) {\n      let immediatePropagationStopped = false; // Prevents the current event from bubbling up\n\n      const stopPropagation = () => {\n        event.handled = true;\n      }; // Prevent any remaining listeners from being called\n\n\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n\n      const entriesToRemove = [];\n\n      for (let i = 0; i < entries.length; i++) {\n        const {\n          type,\n          handler,\n          once\n        } = entries[i];\n        handler({ ...event,\n          // @ts-ignore\n          type,\n          stopPropagation,\n          stopImmediatePropagation\n        });\n\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {\n          type,\n          handler\n        } = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n  /**\n   * Normalizes hammerjs and custom events to have predictable fields.\n   */\n\n\n  _normalizeEvent(event) {\n    const rootElement = this.eventManager.getElement();\n    return { ...event,\n      ...whichButtons(event),\n      ...getOffsetPosition(event, rootElement),\n      preventDefault: () => {\n        event.srcEvent.preventDefault();\n      },\n      stopImmediatePropagation: null,\n      stopPropagation: null,\n      handled: false,\n      rootElement\n    };\n  }\n\n}","map":{"version":3,"sources":["../../../src/utils/event-registrar.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { whichButtons, getOffsetPosition } from './event-utils';\nconst DEFAULT_OPTIONS = {\n    srcElement: 'root',\n    priority: 0\n};\nexport default class EventRegistrar {\n    constructor(eventManager) {\n        /**\n         * Handles hammerjs event\n         */\n        this.handleEvent = (event) => {\n            if (this.isEmpty()) {\n                return;\n            }\n            const mjolnirEvent = this._normalizeEvent(event);\n            let target = event.srcEvent.target;\n            while (target && target !== mjolnirEvent.rootElement) {\n                this._emit(mjolnirEvent, target);\n                if (mjolnirEvent.handled) {\n                    return;\n                }\n                target = target.parentNode;\n            }\n            this._emit(mjolnirEvent, 'root');\n        };\n        this.eventManager = eventManager;\n        this.handlers = [];\n        // Element -> handler map\n        this.handlersByElement = new Map();\n        this._active = false;\n    }\n    // Returns true if there are no non-passive handlers\n    isEmpty() {\n        return !this._active;\n    }\n    add(type, handler, options, once = false, passive = false) {\n        const { handlers, handlersByElement } = this;\n        let opts = DEFAULT_OPTIONS;\n        if (typeof options === 'string' || (options && options.addEventListener)) {\n            // is DOM element, backward compatibility\n            // @ts-ignore\n            opts = { ...DEFAULT_OPTIONS, srcElement: options };\n        }\n        else if (options) {\n            opts = { ...DEFAULT_OPTIONS, ...options };\n        }\n        let entries = handlersByElement.get(opts.srcElement);\n        if (!entries) {\n            entries = [];\n            handlersByElement.set(opts.srcElement, entries);\n        }\n        const entry = {\n            type,\n            handler,\n            srcElement: opts.srcElement,\n            priority: opts.priority\n        };\n        if (once) {\n            entry.once = true;\n        }\n        if (passive) {\n            entry.passive = true;\n        }\n        handlers.push(entry);\n        this._active = this._active || !entry.passive;\n        // Sort handlers by descending priority\n        // Handlers with the same priority are excuted in the order of registration\n        let insertPosition = entries.length - 1;\n        while (insertPosition >= 0) {\n            if (entries[insertPosition].priority >= entry.priority) {\n                break;\n            }\n            insertPosition--;\n        }\n        entries.splice(insertPosition + 1, 0, entry);\n    }\n    remove(type, handler) {\n        const { handlers, handlersByElement } = this;\n        for (let i = handlers.length - 1; i >= 0; i--) {\n            const entry = handlers[i];\n            if (entry.type === type && entry.handler === handler) {\n                handlers.splice(i, 1);\n                const entries = handlersByElement.get(entry.srcElement);\n                entries.splice(entries.indexOf(entry), 1);\n                if (entries.length === 0) {\n                    handlersByElement.delete(entry.srcElement);\n                }\n            }\n        }\n        this._active = handlers.some(entry => !entry.passive);\n    }\n    /**\n     * Invoke handlers on a particular element\n     */\n    _emit(event, srcElement) {\n        const entries = this.handlersByElement.get(srcElement);\n        if (entries) {\n            let immediatePropagationStopped = false;\n            // Prevents the current event from bubbling up\n            const stopPropagation = () => {\n                event.handled = true;\n            };\n            // Prevent any remaining listeners from being called\n            const stopImmediatePropagation = () => {\n                event.handled = true;\n                immediatePropagationStopped = true;\n            };\n            const entriesToRemove = [];\n            for (let i = 0; i < entries.length; i++) {\n                const { type, handler, once } = entries[i];\n                handler({\n                    ...event,\n                    // @ts-ignore\n                    type,\n                    stopPropagation,\n                    stopImmediatePropagation\n                });\n                if (once) {\n                    entriesToRemove.push(entries[i]);\n                }\n                if (immediatePropagationStopped) {\n                    break;\n                }\n            }\n            for (let i = 0; i < entriesToRemove.length; i++) {\n                const { type, handler } = entriesToRemove[i];\n                this.remove(type, handler);\n            }\n        }\n    }\n    /**\n     * Normalizes hammerjs and custom events to have predictable fields.\n     */\n    _normalizeEvent(event) {\n        const rootElement = this.eventManager.getElement();\n        return {\n            ...event,\n            ...whichButtons(event),\n            ...getOffsetPosition(event, rootElement),\n            preventDefault: () => {\n                event.srcEvent.preventDefault();\n            },\n            stopImmediatePropagation: null,\n            stopPropagation: null,\n            handled: false,\n            rootElement\n        };\n    }\n}\n//# sourceMappingURL=event-registrar.js.map"]},"metadata":{},"sourceType":"module"}