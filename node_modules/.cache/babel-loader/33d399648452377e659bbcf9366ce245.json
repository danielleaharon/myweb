{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport ComponentState from '../lifecycle/component-state';\nexport default class LayerState extends ComponentState {\n  constructor({\n    attributeManager,\n    layer\n  }) {\n    super(layer);\n\n    _defineProperty(this, \"attributeManager\", void 0);\n\n    _defineProperty(this, \"needsRedraw\", void 0);\n\n    _defineProperty(this, \"needsUpdate\", void 0);\n\n    _defineProperty(this, \"subLayers\", void 0);\n\n    _defineProperty(this, \"usesPickingColorCache\", void 0);\n\n    _defineProperty(this, \"changeFlags\", void 0);\n\n    _defineProperty(this, \"viewport\", void 0);\n\n    _defineProperty(this, \"uniformTransitions\", void 0);\n\n    _defineProperty(this, \"propsInTransition\", void 0);\n\n    this.attributeManager = attributeManager;\n    this.needsRedraw = true;\n    this.needsUpdate = true;\n    this.subLayers = null;\n    this.usesPickingColorCache = false;\n  }\n\n  get layer() {\n    return this.component;\n  }\n\n  set layer(layer) {\n    this.component = layer;\n  }\n\n  _fetch(propName, url) {\n    const fetch = this.component.props.fetch;\n\n    if (fetch) {\n      return fetch(url, {\n        propName,\n        layer: this.layer\n      });\n    }\n\n    return super._fetch(propName, url);\n  }\n\n  _onResolve(propName, value) {\n    const onDataLoad = this.component.props.onDataLoad;\n\n    if (propName === 'data' && onDataLoad) {\n      onDataLoad(value, {\n        propName,\n        layer: this.layer\n      });\n    }\n  }\n\n  _onError(propName, error) {\n    this.layer.raiseError(error, \"loading \".concat(propName, \" of \").concat(this.layer));\n  }\n\n}","map":{"version":3,"sources":["../../../src/lib/layer-state.ts"],"names":["constructor","layer","_fetch","fetch","_onResolve","onDataLoad","propName","_onError"],"mappings":";AAAA,OAAA,cAAA,MAAA,8BAAA;AAqBA,eAAe,MAAA,UAAA,SAAA,cAAA,CAAsE;AAwBnFA,EAAAA,WAAW,CAAC;AAAA,IAAA,gBAAA;AAEVC,IAAAA;AAFU,GAAD,EAMR;AACD,UAAA,KAAA;;AADC,IAAA,eAAA,CAAA,IAAA,EAAA,kBAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,aAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,aAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,WAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,uBAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,aAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,UAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,oBAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,mBAAA,EAAA,KAAA,CAAA,CAAA;;AAED,SAAA,gBAAA,GAAA,gBAAA;AACA,SAAA,WAAA,GAAA,IAAA;AACA,SAAA,WAAA,GAAA,IAAA;AACA,SAAA,SAAA,GAAA,IAAA;AACA,SAAA,qBAAA,GAAA,KAAA;AACD;;AAEQ,MAALA,KAAK,GAAW;AAClB,WAAO,KAAP,SAAA;AACD;;AAEQ,MAALA,KAAK,CAAA,KAAA,EAAgB;AACvB,SAAA,SAAA,GAAA,KAAA;AACD;;AAISC,EAAAA,MAAM,CAAA,QAAA,EAAA,GAAA,EAAwB;AACtC,UAAMC,KAAK,GAAG,KAAA,SAAA,CAAA,KAAA,CAAd,KAAA;;AACA,QAAA,KAAA,EAAW;AACT,aAAOA,KAAK,CAAA,GAAA,EAAM;AAAA,QAAA,QAAA;AAAWF,QAAAA,KAAK,EAAE,KAAKA;AAAvB,OAAN,CAAZ;AACD;;AACD,WAAO,MAAA,MAAA,CAAA,QAAA,EAAP,GAAO,CAAP;AACD;;AAESG,EAAAA,UAAU,CAAA,QAAA,EAAA,KAAA,EAA+B;AACjD,UAAMC,UAAU,GAAG,KAAA,SAAA,CAAA,KAAA,CAAnB,UAAA;;AACA,QAAIC,QAAQ,KAARA,MAAAA,IAAJ,UAAA,EAAuC;AACrCD,MAAAA,UAAU,CAAA,KAAA,EAAQ;AAAA,QAAA,QAAA;AAAWJ,QAAAA,KAAK,EAAE,KAAKA;AAAvB,OAAR,CAAVI;AACD;AACF;;AAESE,EAAAA,QAAQ,CAAA,QAAA,EAAA,KAAA,EAAiC;AACjD,SAAA,KAAA,CAAA,UAAA,CAAA,KAAA,EAAA,WAAA,MAAA,CAAA,QAAA,EAAA,MAAA,EAAA,MAAA,CAAuD,KAAvD,KAAA,CAAA;AACD;;AAlEkF","sourcesContent":["import ComponentState from '../lifecycle/component-state';\n\nimport type Layer from './layer';\nimport type AttributeManager from './attribute/attribute-manager';\nimport type Viewport from '../viewports/viewport';\nimport type UniformTransitionManager from './uniform-transition-manager';\n\nexport type ChangeFlags = {\n  // Primary changeFlags, can be strings stating reason for change\n  dataChanged: string | false | {startRow: number; endRow?: number}[];\n  propsChanged: string | false;\n  updateTriggersChanged: Record<string, true> | false;\n  extensionsChanged: boolean;\n  viewportChanged: boolean;\n  stateChanged: boolean;\n\n  // Derived changeFlags\n  propsOrDataChanged: boolean;\n  somethingChanged: boolean;\n};\n\nexport default class LayerState<LayerT extends Layer> extends ComponentState<LayerT> {\n  attributeManager: AttributeManager | null;\n  needsRedraw: boolean;\n  needsUpdate: boolean;\n  /**\n   * Sublayers rendered in a previous cycle\n   */\n  subLayers: Layer[] | null;\n  /**\n   * If the layer is using the shared instancedPickingColors buffer\n   */\n  usesPickingColorCache: boolean;\n  /**\n   * Dirty flags of the layer's props and state\n   */\n  changeFlags!: ChangeFlags;\n\n  /** The last viewport rendered by this layer */\n  viewport?: Viewport;\n\n  uniformTransitions!: UniformTransitionManager;\n  /** Populated during uniform transition to replace user-supplied values */\n  propsInTransition?: LayerT['props'];\n\n  constructor({\n    attributeManager,\n    layer\n  }: {\n    attributeManager: AttributeManager | null;\n    layer: LayerT;\n  }) {\n    super(layer);\n    this.attributeManager = attributeManager;\n    this.needsRedraw = true;\n    this.needsUpdate = true;\n    this.subLayers = null;\n    this.usesPickingColorCache = false;\n  }\n\n  get layer(): LayerT {\n    return this.component;\n  }\n\n  set layer(layer: LayerT) {\n    this.component = layer;\n  }\n\n  /* Override base Component methods with Layer-specific handling */\n\n  protected _fetch(propName, url: string) {\n    const fetch = this.component.props.fetch;\n    if (fetch) {\n      return fetch(url, {propName, layer: this.layer});\n    }\n    return super._fetch(propName, url);\n  }\n\n  protected _onResolve(propName: string, value: any) {\n    const onDataLoad = this.component.props.onDataLoad;\n    if (propName === 'data' && onDataLoad) {\n      onDataLoad(value, {propName, layer: this.layer});\n    }\n  }\n\n  protected _onError(propName: string, error: Error) {\n    this.layer.raiseError(error, `loading ${propName} of ${this.layer}`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}