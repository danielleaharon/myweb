{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport LayerManager from './layer-manager';\nimport ViewManager from './view-manager';\nimport MapView from '../views/map-view';\nimport EffectManager from './effect-manager';\nimport DeckRenderer from './deck-renderer';\nimport DeckPicker from './deck-picker';\nimport Tooltip from './tooltip';\nimport log from '../utils/log';\nimport { deepEqual } from '../utils/deep-equal';\nimport typedArrayManager from '../utils/typed-array-manager';\nimport deckGlobal from './init';\nimport { getBrowser } from '@probe.gl/env';\nimport { AnimationLoop, createGLContext, instrumentGLContext, setParameters, Timeline, lumaStats } from '@luma.gl/core';\nimport { Stats } from '@probe.gl/stats';\nimport { EventManager } from 'mjolnir.js';\nimport assert from '../utils/assert';\nimport { EVENTS } from './constants';\n\nfunction noop() {}\n\nconst getCursor = ({\n  isDragging\n}) => isDragging ? 'grabbing' : 'grab';\n\nconst defaultProps = {\n  id: '',\n  width: '100%',\n  height: '100%',\n  style: null,\n  viewState: null,\n  initialViewState: null,\n  pickingRadius: 0,\n  layerFilter: null,\n  glOptions: {},\n  parameters: {},\n  parent: null,\n  gl: null,\n  canvas: null,\n  layers: [],\n  effects: [],\n  views: null,\n  controller: null,\n  useDevicePixels: true,\n  touchAction: 'none',\n  eventRecognizerOptions: {},\n  _framebuffer: null,\n  _animate: false,\n  _pickable: true,\n  _typedArrayManagerProps: {},\n  _customRender: null,\n  onWebGLInitialized: noop,\n  onResize: noop,\n  onViewStateChange: noop,\n  onInteractionStateChange: noop,\n  onBeforeRender: noop,\n  onAfterRender: noop,\n  onLoad: noop,\n  onError: error => log.error(error.message)(),\n  onHover: null,\n  onClick: null,\n  onDragStart: null,\n  onDrag: null,\n  onDragEnd: null,\n  _onMetrics: null,\n  getCursor,\n  getTooltip: null,\n  debug: false,\n  drawPickingColors: false\n};\nexport default class Deck {\n  constructor(props) {\n    _defineProperty(this, \"props\", void 0);\n\n    _defineProperty(this, \"width\", 0);\n\n    _defineProperty(this, \"height\", 0);\n\n    _defineProperty(this, \"userData\", {});\n\n    _defineProperty(this, \"canvas\", null);\n\n    _defineProperty(this, \"viewManager\", null);\n\n    _defineProperty(this, \"layerManager\", null);\n\n    _defineProperty(this, \"effectManager\", null);\n\n    _defineProperty(this, \"deckRenderer\", null);\n\n    _defineProperty(this, \"deckPicker\", null);\n\n    _defineProperty(this, \"eventManager\", null);\n\n    _defineProperty(this, \"tooltip\", null);\n\n    _defineProperty(this, \"metrics\", void 0);\n\n    _defineProperty(this, \"animationLoop\", void 0);\n\n    _defineProperty(this, \"stats\", void 0);\n\n    _defineProperty(this, \"viewState\", void 0);\n\n    _defineProperty(this, \"cursorState\", void 0);\n\n    _defineProperty(this, \"_needsRedraw\", void 0);\n\n    _defineProperty(this, \"_pickRequest\", void 0);\n\n    _defineProperty(this, \"_lastPointerDownInfo\", null);\n\n    _defineProperty(this, \"_metricsCounter\", void 0);\n\n    _defineProperty(this, \"_onPointerMove\", event => {\n      const {\n        _pickRequest\n      } = this;\n\n      if (event.type === 'pointerleave') {\n        _pickRequest.x = -1;\n        _pickRequest.y = -1;\n        _pickRequest.radius = 0;\n      } else if (event.leftButton || event.rightButton) {\n        return;\n      } else {\n        const pos = event.offsetCenter;\n\n        if (!pos) {\n          return;\n        }\n\n        _pickRequest.x = pos.x;\n        _pickRequest.y = pos.y;\n        _pickRequest.radius = this.props.pickingRadius;\n      }\n\n      if (this.layerManager) {\n        this.layerManager.context.mousePosition = {\n          x: _pickRequest.x,\n          y: _pickRequest.y\n        };\n      }\n\n      _pickRequest.event = event;\n    });\n\n    _defineProperty(this, \"_onEvent\", event => {\n      const eventOptions = EVENTS[event.type];\n      const pos = event.offsetCenter;\n\n      if (!eventOptions || !pos || !this.layerManager) {\n        return;\n      }\n\n      const layers = this.layerManager.getLayers();\n      const info = this.deckPicker.getLastPickedObject({\n        x: pos.x,\n        y: pos.y,\n        layers,\n        viewports: this.getViewports(pos)\n      }, this._lastPointerDownInfo);\n      const {\n        layer\n      } = info;\n      const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);\n      const rootHandler = this.props[eventOptions.handler];\n      let handled = false;\n\n      if (layerHandler) {\n        handled = layerHandler.call(layer, info, event);\n      }\n\n      if (!handled && rootHandler) {\n        rootHandler(info, event);\n      }\n    });\n\n    _defineProperty(this, \"_onPointerDown\", event => {\n      const pos = event.offsetCenter;\n\n      const pickedInfo = this._pick('pickObject', 'pickObject Time', {\n        x: pos.x,\n        y: pos.y,\n        radius: this.props.pickingRadius\n      });\n\n      this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;\n    });\n\n    this.props = { ...defaultProps,\n      ...props\n    };\n    props = this.props;\n    this._needsRedraw = 'Initial render';\n    this._pickRequest = {\n      mode: 'hover',\n      x: -1,\n      y: -1,\n      radius: 0,\n      event: null\n    };\n    this.cursorState = {\n      isHovering: false,\n      isDragging: false\n    };\n\n    if (props.viewState && props.initialViewState) {\n      log.warn('View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.')();\n    }\n\n    if (getBrowser() === 'IE') {\n      log.warn('IE 11 is not supported')();\n    }\n\n    this.viewState = props.initialViewState;\n\n    if (!props.gl) {\n      if (typeof document !== 'undefined') {\n        this.canvas = this._createCanvas(props);\n      }\n    }\n\n    this.animationLoop = this._createAnimationLoop(props);\n    this.stats = new Stats({\n      id: 'deck.gl'\n    });\n    this.metrics = {\n      fps: 0,\n      setPropsTime: 0,\n      updateAttributesTime: 0,\n      framesRedrawn: 0,\n      pickTime: 0,\n      pickCount: 0,\n      gpuTime: 0,\n      gpuTimePerFrame: 0,\n      cpuTime: 0,\n      cpuTimePerFrame: 0,\n      bufferMemory: 0,\n      textureMemory: 0,\n      renderbufferMemory: 0,\n      gpuMemory: 0\n    };\n    this._metricsCounter = 0;\n    this.setProps(props);\n\n    if (props._typedArrayManagerProps) {\n      typedArrayManager.setOptions(props._typedArrayManagerProps);\n    }\n\n    this.animationLoop.start();\n  }\n\n  finalize() {\n    var _this$layerManager, _this$viewManager, _this$effectManager, _this$deckRenderer, _this$deckPicker, _this$eventManager, _this$tooltip;\n\n    this.animationLoop.stop();\n    this.animationLoop = null;\n    this._lastPointerDownInfo = null;\n    (_this$layerManager = this.layerManager) === null || _this$layerManager === void 0 ? void 0 : _this$layerManager.finalize();\n    this.layerManager = null;\n    (_this$viewManager = this.viewManager) === null || _this$viewManager === void 0 ? void 0 : _this$viewManager.finalize();\n    this.viewManager = null;\n    (_this$effectManager = this.effectManager) === null || _this$effectManager === void 0 ? void 0 : _this$effectManager.finalize();\n    this.effectManager = null;\n    (_this$deckRenderer = this.deckRenderer) === null || _this$deckRenderer === void 0 ? void 0 : _this$deckRenderer.finalize();\n    this.deckRenderer = null;\n    (_this$deckPicker = this.deckPicker) === null || _this$deckPicker === void 0 ? void 0 : _this$deckPicker.finalize();\n    this.deckPicker = null;\n    (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.destroy();\n    this.eventManager = null;\n    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.remove();\n    this.tooltip = null;\n\n    if (!this.props.canvas && !this.props.gl && this.canvas) {\n      var _this$canvas$parentEl;\n\n      (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 ? void 0 : _this$canvas$parentEl.removeChild(this.canvas);\n      this.canvas = null;\n    }\n  }\n\n  setProps(props) {\n    this.stats.get('setProps Time').timeStart();\n\n    if ('onLayerHover' in props) {\n      log.removed('onLayerHover', 'onHover')();\n    }\n\n    if ('onLayerClick' in props) {\n      log.removed('onLayerClick', 'onClick')();\n    }\n\n    if (props.initialViewState && !deepEqual(this.props.initialViewState, props.initialViewState)) {\n      this.viewState = props.initialViewState;\n    }\n\n    Object.assign(this.props, props);\n\n    this._setCanvasSize(this.props);\n\n    const resolvedProps = Object.create(this.props);\n    Object.assign(resolvedProps, {\n      views: this._getViews(),\n      width: this.width,\n      height: this.height,\n      viewState: this._getViewState()\n    });\n    this.animationLoop.setProps(resolvedProps);\n\n    if (this.layerManager) {\n      this.viewManager.setProps(resolvedProps);\n      this.layerManager.activateViewport(this.getViewports()[0]);\n      this.layerManager.setProps(resolvedProps);\n      this.effectManager.setProps(resolvedProps);\n      this.deckRenderer.setProps(resolvedProps);\n      this.deckPicker.setProps(resolvedProps);\n    }\n\n    this.stats.get('setProps Time').timeEnd();\n  }\n\n  needsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    if (!this.layerManager) {\n      return false;\n    }\n\n    if (this.props._animate) {\n      return 'Deck._animate';\n    }\n\n    let redraw = this._needsRedraw;\n\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);\n    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);\n    const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);\n    const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);\n    redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;\n    return redraw;\n  }\n\n  redraw(reason) {\n    if (!this.layerManager) {\n      return;\n    }\n\n    let redrawReason = this.needsRedraw({\n      clearRedrawFlags: true\n    });\n    redrawReason = reason || redrawReason;\n\n    if (!redrawReason) {\n      return;\n    }\n\n    this.stats.get('Redraw Count').incrementCount();\n\n    if (this.props._customRender) {\n      this.props._customRender(redrawReason);\n    } else {\n      this._drawLayers(redrawReason);\n    }\n  }\n\n  get isInitialized() {\n    return this.viewManager !== null;\n  }\n\n  getViews() {\n    assert(this.viewManager);\n    return this.viewManager.views;\n  }\n\n  getViewports(rect) {\n    assert(this.viewManager);\n    return this.viewManager.getViewports(rect);\n  }\n\n  pickObject(opts) {\n    const infos = this._pick('pickObject', 'pickObject Time', opts).result;\n\n    return infos.length ? infos[0] : null;\n  }\n\n  pickMultipleObjects(opts) {\n    opts.depth = opts.depth || 10;\n    return this._pick('pickObject', 'pickMultipleObjects Time', opts).result;\n  }\n\n  pickObjects(opts) {\n    return this._pick('pickObjects', 'pickObjects Time', opts);\n  }\n\n  _addResources(resources, forceUpdate = false) {\n    for (const id in resources) {\n      this.layerManager.resourceManager.add({\n        resourceId: id,\n        data: resources[id],\n        forceUpdate\n      });\n    }\n  }\n\n  _removeResources(resourceIds) {\n    for (const id of resourceIds) {\n      this.layerManager.resourceManager.remove(id);\n    }\n  }\n\n  _pick(method, statKey, opts) {\n    assert(this.deckPicker);\n    const {\n      stats\n    } = this;\n    stats.get('Pick Count').incrementCount();\n    stats.get(statKey).timeStart();\n    const infos = this.deckPicker[method]({\n      layers: this.layerManager.getLayers(opts),\n      views: this.viewManager.getViews(),\n      viewports: this.getViewports(opts),\n      onViewportActive: this.layerManager.activateViewport,\n      effects: this.effectManager.getEffects(),\n      ...opts\n    });\n    stats.get(statKey).timeEnd();\n    return infos;\n  }\n\n  _createCanvas(props) {\n    let canvas = props.canvas;\n\n    if (typeof canvas === 'string') {\n      canvas = document.getElementById(canvas);\n      assert(canvas);\n    }\n\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.id = props.id || 'deckgl-overlay';\n      const parent = props.parent || document.body;\n      parent.appendChild(canvas);\n    }\n\n    Object.assign(canvas.style, props.style);\n    return canvas;\n  }\n\n  _setCanvasSize(props) {\n    if (!this.canvas) {\n      return;\n    }\n\n    const {\n      width,\n      height\n    } = props;\n\n    if (width || width === 0) {\n      const cssWidth = Number.isFinite(width) ? \"\".concat(width, \"px\") : width;\n      this.canvas.style.width = cssWidth;\n    }\n\n    if (height || height === 0) {\n      var _props$style;\n\n      const cssHeight = Number.isFinite(height) ? \"\".concat(height, \"px\") : height;\n      this.canvas.style.position = ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.position) || 'absolute';\n      this.canvas.style.height = cssHeight;\n    }\n  }\n\n  _updateCanvasSize() {\n    const {\n      canvas\n    } = this;\n\n    if (!canvas) {\n      return;\n    }\n\n    const newWidth = canvas.clientWidth || canvas.width;\n    const newHeight = canvas.clientHeight || canvas.height;\n\n    if (newWidth !== this.width || newHeight !== this.height) {\n      var _this$viewManager2;\n\n      this.width = newWidth;\n      this.height = newHeight;\n      (_this$viewManager2 = this.viewManager) === null || _this$viewManager2 === void 0 ? void 0 : _this$viewManager2.setProps({\n        width: newWidth,\n        height: newHeight\n      });\n      this.props.onResize({\n        width: newWidth,\n        height: newHeight\n      });\n    }\n  }\n\n  _createAnimationLoop(props) {\n    const {\n      width,\n      height,\n      gl,\n      glOptions,\n      debug,\n      onError,\n      onBeforeRender,\n      onAfterRender,\n      useDevicePixels\n    } = props;\n    return new AnimationLoop({\n      width,\n      height,\n      useDevicePixels,\n      autoResizeViewport: false,\n      gl,\n      onCreateContext: opts => createGLContext({ ...glOptions,\n        ...opts,\n        canvas: this.canvas,\n        debug,\n        onContextLost: () => this._onContextLost()\n      }),\n      onInitialize: context => this._setGLContext(context.gl),\n      onRender: this._onRenderFrame.bind(this),\n      onBeforeRender,\n      onAfterRender,\n      onError\n    });\n  }\n\n  _getViewState() {\n    return this.props.viewState || this.viewState;\n  }\n\n  _getViews() {\n    let views = this.props.views || [new MapView({\n      id: 'default-view'\n    })];\n    views = Array.isArray(views) ? views : [views];\n\n    if (views.length && this.props.controller) {\n      views[0].props.controller = this.props.controller;\n    }\n\n    return views;\n  }\n\n  _onContextLost() {\n    const {\n      onError\n    } = this.props;\n\n    if (this.animationLoop && onError) {\n      onError(new Error('WebGL context is lost'));\n    }\n  }\n\n  _pickAndCallback() {\n    const {\n      _pickRequest\n    } = this;\n\n    if (_pickRequest.event) {\n      const {\n        result,\n        emptyInfo\n      } = this._pick('pickObject', 'pickObject Time', _pickRequest);\n\n      this.cursorState.isHovering = result.length > 0;\n      let pickedInfo = emptyInfo;\n      let handled = false;\n\n      for (const info of result) {\n        var _info$layer;\n\n        pickedInfo = info;\n        handled = ((_info$layer = info.layer) === null || _info$layer === void 0 ? void 0 : _info$layer.onHover(info, _pickRequest.event)) || handled;\n      }\n\n      if (!handled && this.props.onHover) {\n        this.props.onHover(pickedInfo, _pickRequest.event);\n      }\n\n      if (this.props.getTooltip && this.tooltip) {\n        const displayInfo = this.props.getTooltip(pickedInfo);\n        this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);\n      }\n\n      _pickRequest.event = null;\n    }\n  }\n\n  _updateCursor() {\n    const container = this.props.parent || this.canvas;\n\n    if (container) {\n      container.style.cursor = this.props.getCursor(this.cursorState);\n    }\n  }\n\n  _setGLContext(gl) {\n    if (this.layerManager) {\n      return;\n    }\n\n    if (!this.canvas) {\n      this.canvas = gl.canvas;\n      instrumentGLContext(gl, {\n        enable: true,\n        copyState: true\n      });\n    }\n\n    this.tooltip = new Tooltip(this.canvas);\n    setParameters(gl, {\n      blend: true,\n      blendFunc: [770, 771, 1, 771],\n      polygonOffsetFill: true,\n      depthTest: true,\n      depthFunc: 515\n    });\n    this.props.onWebGLInitialized(gl);\n    const timeline = new Timeline();\n    timeline.play();\n    this.animationLoop.attachTimeline(timeline);\n    this.eventManager = new EventManager(this.props.parent || gl.canvas, {\n      touchAction: this.props.touchAction,\n      recognizerOptions: this.props.eventRecognizerOptions,\n      events: {\n        pointerdown: this._onPointerDown,\n        pointermove: this._onPointerMove,\n        pointerleave: this._onPointerMove\n      }\n    });\n\n    for (const eventType in EVENTS) {\n      this.eventManager.on(eventType, this._onEvent);\n    }\n\n    this.viewManager = new ViewManager({\n      timeline,\n      eventManager: this.eventManager,\n      onViewStateChange: this._onViewStateChange.bind(this),\n      onInteractionStateChange: this._onInteractionStateChange.bind(this),\n      views: this._getViews(),\n      viewState: this._getViewState(),\n      width: this.width,\n      height: this.height\n    });\n    const viewport = this.viewManager.getViewports()[0];\n    this.layerManager = new LayerManager(gl, {\n      deck: this,\n      stats: this.stats,\n      viewport,\n      timeline\n    });\n    this.effectManager = new EffectManager();\n    this.deckRenderer = new DeckRenderer(gl);\n    this.deckPicker = new DeckPicker(gl);\n    this.setProps(this.props);\n\n    this._updateCanvasSize();\n\n    this.props.onLoad();\n  }\n\n  _drawLayers(redrawReason, renderOptions) {\n    const {\n      gl\n    } = this.layerManager.context;\n    setParameters(gl, this.props.parameters);\n    this.props.onBeforeRender({\n      gl\n    });\n    this.deckRenderer.renderLayers({\n      target: this.props._framebuffer,\n      layers: this.layerManager.getLayers(),\n      viewports: this.viewManager.getViewports(),\n      onViewportActive: this.layerManager.activateViewport,\n      views: this.viewManager.getViews(),\n      pass: 'screen',\n      redrawReason,\n      effects: this.effectManager.getEffects(),\n      ...renderOptions\n    });\n    this.props.onAfterRender({\n      gl\n    });\n  }\n\n  _onRenderFrame(animationProps) {\n    this._getFrameStats();\n\n    if (this._metricsCounter++ % 60 === 0) {\n      this._getMetrics();\n\n      this.stats.reset();\n      log.table(4, this.metrics)();\n\n      if (this.props._onMetrics) {\n        this.props._onMetrics(this.metrics);\n      }\n    }\n\n    this._updateCanvasSize();\n\n    this._updateCursor();\n\n    if (this.tooltip.isVisible && this.viewManager.needsRedraw()) {\n      this.tooltip.setTooltip(null);\n    }\n\n    this.layerManager.updateLayers();\n\n    this._pickAndCallback();\n\n    this.redraw();\n\n    if (this.viewManager) {\n      this.viewManager.updateViewStates();\n    }\n  }\n\n  _onViewStateChange(params) {\n    const viewState = this.props.onViewStateChange(params) || params.viewState;\n\n    if (this.viewState) {\n      this.viewState = { ...this.viewState,\n        [params.viewId]: viewState\n      };\n\n      if (!this.props.viewState) {\n        if (this.viewManager) {\n          this.viewManager.setProps({\n            viewState: this.viewState\n          });\n        }\n      }\n    }\n  }\n\n  _onInteractionStateChange(interactionState) {\n    this.cursorState.isDragging = interactionState.isDragging || false;\n    this.props.onInteractionStateChange(interactionState);\n  }\n\n  _getFrameStats() {\n    const {\n      stats\n    } = this;\n    stats.get('frameRate').timeEnd();\n    stats.get('frameRate').timeStart();\n    const animationLoopStats = this.animationLoop.stats;\n    stats.get('GPU Time').addTime(animationLoopStats.get('GPU Time').lastTiming);\n    stats.get('CPU Time').addTime(animationLoopStats.get('CPU Time').lastTiming);\n  }\n\n  _getMetrics() {\n    const {\n      metrics,\n      stats\n    } = this;\n    metrics.fps = stats.get('frameRate').getHz();\n    metrics.setPropsTime = stats.get('setProps Time').time;\n    metrics.updateAttributesTime = stats.get('Update Attributes').time;\n    metrics.framesRedrawn = stats.get('Redraw Count').count;\n    metrics.pickTime = stats.get('pickObject Time').time + stats.get('pickMultipleObjects Time').time + stats.get('pickObjects Time').time;\n    metrics.pickCount = stats.get('Pick Count').count;\n    metrics.gpuTime = stats.get('GPU Time').time;\n    metrics.cpuTime = stats.get('CPU Time').time;\n    metrics.gpuTimePerFrame = stats.get('GPU Time').getAverageTime();\n    metrics.cpuTimePerFrame = stats.get('CPU Time').getAverageTime();\n    const memoryStats = lumaStats.get('Memory Usage');\n    metrics.bufferMemory = memoryStats.get('Buffer Memory').count;\n    metrics.textureMemory = memoryStats.get('Texture Memory').count;\n    metrics.renderbufferMemory = memoryStats.get('Renderbuffer Memory').count;\n    metrics.gpuMemory = memoryStats.get('GPU Memory').count;\n  }\n\n}\n\n_defineProperty(Deck, \"defaultProps\", defaultProps);\n\n_defineProperty(Deck, \"VERSION\", deckGlobal.VERSION);","map":{"version":3,"sources":["../../../src/lib/deck.ts"],"names":["getCursor","isDragging","defaultProps","id","width","height","style","viewState","initialViewState","pickingRadius","layerFilter","glOptions","parameters","parent","gl","canvas","layers","effects","views","controller","useDevicePixels","touchAction","eventRecognizerOptions","_framebuffer","_animate","_pickable","_typedArrayManagerProps","_customRender","onWebGLInitialized","onResize","onViewStateChange","onInteractionStateChange","onBeforeRender","onAfterRender","onLoad","onError","error","log","onHover","onClick","onDragStart","onDrag","onDragEnd","_onMetrics","getTooltip","debug","drawPickingColors","Deck","deckGlobal","VERSION","constructor","props","mode","x","y","radius","event","isHovering","getBrowser","fps","setPropsTime","updateAttributesTime","framesRedrawn","pickTime","pickCount","gpuTime","gpuTimePerFrame","cpuTime","cpuTimePerFrame","bufferMemory","textureMemory","renderbufferMemory","gpuMemory","typedArrayManager","finalize","setProps","deepEqual","Object","resolvedProps","needsRedraw","opts","clearRedrawFlags","redraw","viewManagerNeedsRedraw","layerManagerNeedsRedraw","effectManagerNeedsRedraw","deckRendererNeedsRedraw","redrawReason","reason","isInitialized","getViews","assert","getViewports","pickObject","infos","pickMultipleObjects","pickObjects","_addResources","forceUpdate","resourceId","data","resources","_removeResources","_pick","stats","viewports","onViewportActive","_createCanvas","document","_setCanvasSize","cssWidth","Number","cssHeight","_updateCanvasSize","newWidth","newHeight","_createAnimationLoop","autoResizeViewport","onCreateContext","createGLContext","onContextLost","onInitialize","context","onRender","_getViewState","_getViews","Array","_onContextLost","_pickRequest","pos","_pickAndCallback","emptyInfo","result","pickedInfo","handled","displayInfo","_updateCursor","container","_setGLContext","instrumentGLContext","enable","copyState","setParameters","blend","blendFunc","polygonOffsetFill","depthTest","depthFunc","timeline","recognizerOptions","events","pointerdown","pointermove","pointerleave","_onPointerMove","eventManager","viewport","deck","_drawLayers","target","pass","renderOptions","_onRenderFrame","_onViewStateChange","params","_onInteractionStateChange","interactionState","eventOptions","EVENTS","info","layer","layerHandler","rootHandler","_getFrameStats","animationLoopStats","_getMetrics","metrics","memoryStats","lumaStats"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport LayerManager from './layer-manager';\nimport ViewManager from './view-manager';\nimport MapView from '../views/map-view';\nimport EffectManager from './effect-manager';\nimport DeckRenderer from './deck-renderer';\nimport DeckPicker from './deck-picker';\nimport Tooltip from './tooltip';\nimport log from '../utils/log';\nimport {deepEqual} from '../utils/deep-equal';\nimport typedArrayManager from '../utils/typed-array-manager';\nimport deckGlobal from './init';\n\nimport {getBrowser} from '@probe.gl/env';\nimport GL from '@luma.gl/constants';\nimport {\n  AnimationLoop,\n  createGLContext,\n  instrumentGLContext,\n  setParameters,\n  Timeline,\n  lumaStats\n} from '@luma.gl/core';\nimport {Stats} from '@probe.gl/stats';\nimport {EventManager} from 'mjolnir.js';\n\nimport assert from '../utils/assert';\nimport {EVENTS} from './constants';\n\nimport type {Effect} from './effect';\nimport type {FilterContext} from '../passes/layers-pass';\nimport type Layer from './layer';\nimport type View from '../views/view';\nimport type Viewport from '../viewports/viewport';\nimport type {RecognizerOptions, MjolnirGestureEvent, MjolnirPointerEvent} from 'mjolnir.js';\nimport type {Framebuffer} from '@luma.gl/core';\nimport type {TypedArrayManagerOptions} from '../utils/typed-array-manager';\nimport type {ViewStateChangeParameters, InteractionState} from '../controllers/controller';\nimport type {PickingInfo} from './picking/pick-info';\nimport type {PickByPointOptions, PickByRectOptions} from './deck-picker';\nimport type {LayersList} from './layer-manager';\nimport type {TooltipContent} from './tooltip';\n\n/* global document */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n\nconst getCursor = ({isDragging}) => (isDragging ? 'grabbing' : 'grab');\n\nexport type DeckMetrics = {\n  fps: number;\n  setPropsTime: number;\n  updateAttributesTime: number;\n  framesRedrawn: number;\n  pickTime: number;\n  pickCount: number;\n  gpuTime: number;\n  gpuTimePerFrame: number;\n  cpuTime: number;\n  cpuTimePerFrame: number;\n  bufferMemory: number;\n  textureMemory: number;\n  renderbufferMemory: number;\n  gpuMemory: number;\n};\n\ntype CursorState = {\n  /** Whether the cursor is over a pickable object */\n  isHovering: boolean;\n  /** Whether the cursor is down */\n  isDragging: boolean;\n};\n\nexport type DeckProps = {\n  /** Id of this Deck instance */\n  id?: string;\n  /** Width of the canvas, a number in pixels or a valid CSS string.\n   * @default `'100%'`\n   */\n  width?: string | number | null;\n  /** Height of the canvas, a number in pixels or a valid CSS string.\n   * @default `'100%'`\n   */\n  height?: string | number | null;\n  /** Additional CSS styles for the canvas. */\n  style?: Partial<CSSStyleDeclaration> | null;\n\n  /** Controls the resolution of drawing buffer used for rendering.\n   * @default `true` (use browser devicePixelRatio)\n   */\n  useDevicePixels?: boolean | number;\n  /** Extra pixels around the pointer to include while picking.\n   * @default `0`\n   */\n  pickingRadius?: number;\n\n  /** WebGL parameters to be set before each frame is rendered.\n   * @see https://github.com/visgl/luma.gl/blob/8.5-release/modules/gltools/docs/api-reference/parameter-setting.md#parameters\n   */\n  parameters?: any;\n  /** If supplied, will be called before a layer is drawn to determine whether it should be rendered. */\n  layerFilter?: ((context: FilterContext) => boolean) | null;\n\n  /** The container to append the auto-created canvas to.\n   * @default `document.body`\n   */\n  parent?: HTMLDivElement | null;\n  /** The canvas to render into.\n   * Can be either a HTMLCanvasElement or the element id.\n   * Will be auto-created if not supplied.\n   */\n  canvas?: HTMLCanvasElement | string | null;\n  /** WebGL context. Will be auto-created if not supplied. */\n  gl?: WebGLRenderingContext | null;\n  /** Additional options used when creating the WebGL context. */\n  glOptions?: WebGLContextAttributes;\n\n  /**\n   * The array of Layer instances to be rendered.\n   * Nested arrays are accepted, as well as falsy values (`null`, `false`, `undefined`)\n   */\n  layers?: LayersList;\n  /** The array of effects to be rendered. A lighting effect will be added if an empty array is supplied. */\n  effects?: Effect[];\n  /** A single View instance, or an array of `View` instances.\n   * @default `new MapView()`\n   */\n  views?: View | View[] | null;\n  /** Options for viewport interactivity, e.g. pan, rotate and zoom with mouse, touch and keyboard.\n   * This is a shorthand for defining interaction with the `views` prop if you are using the default view (i.e. a single `MapView`)\n   */\n  controller?: View['props']['controller'];\n  /**\n   * An object that describes the view state for each view in the `views` prop.\n   * Use if the camera state should be managed external to the `Deck` instance.\n   */\n  viewState?: any;\n  /**\n   * If provided, the `Deck` instance will track camera state changes automatically,\n   * with `initialViewState` as its initial settings.\n   */\n  initialViewState?: any;\n\n  /** Allow browser default touch actions.\n   * @default `'none'`\n   */\n  touchAction?: string;\n  /** Set Hammer.js recognizer options for gesture recognition. See documentation for details. */\n  eventRecognizerOptions?: {\n    [type: string]: RecognizerOptions;\n  };\n\n  /** (Experimental) Render to a custom frame buffer other than to screen. */\n  _framebuffer?: Framebuffer | null;\n  /** (Experimental) Forces deck.gl to redraw layers every animation frame. */\n  _animate?: boolean;\n  /** (Experimental) If set to `false`, force disables all picking features, disregarding the `pickable` prop set in any layer. */\n  _pickable?: boolean;\n  /** (Experimental) Fine-tune attribute memory usage. See documentation for details. */\n  _typedArrayManagerProps?: TypedArrayManagerOptions;\n\n  /** Called once the WebGL context has been initiated. */\n  onWebGLInitialized?: (gl: WebGLRenderingContext) => void;\n  /** Called when the canvas resizes. */\n  onResize?: (dimensions: {width: number; height: number}) => void;\n  /** Called when the user has interacted with the deck.gl canvas, e.g. using mouse, touch or keyboard. */\n  onViewStateChange?: (params: ViewStateChangeParameters & {viewId: string}) => any;\n  /** Called when the user has interacted with the deck.gl canvas, e.g. using mouse, touch or keyboard. */\n  onInteractionStateChange?: (state: InteractionState) => void;\n  /** Called just before the canvas rerenders. */\n  onBeforeRender?: (context: {gl: WebGLRenderingContext}) => void;\n  /** Called right after the canvas rerenders. */\n  onAfterRender?: (context: {gl: WebGLRenderingContext}) => void;\n  /** Called once after gl context and all Deck components are created. */\n  onLoad?: () => void;\n  /** Called if deck.gl encounters an error.\n   * If this callback is set to `null`, errors are silently ignored.\n   * @default `console.error`\n   */\n  onError?: ((error: Error, layer?: Layer) => void) | null;\n  /** Called when the pointer moves over the canvas. */\n  onHover?: ((info: PickingInfo, event: MjolnirPointerEvent) => void) | null;\n  /** Called when clicking on the canvas. */\n  onClick?: ((info: PickingInfo, event: MjolnirGestureEvent) => void) | null;\n  /** Called when the user starts dragging on the canvas. */\n  onDragStart?: ((info: PickingInfo, event: MjolnirGestureEvent) => void) | null;\n  /** Called when dragging the canvas. */\n  onDrag?: ((info: PickingInfo, event: MjolnirGestureEvent) => void) | null;\n  /** Called when the user releases from dragging the canvas. */\n  onDragEnd?: ((info: PickingInfo, event: MjolnirGestureEvent) => void) | null;\n\n  /** (Experimental) Replace the default redraw procedure */\n  _customRender?: ((reason: string) => void) | null;\n  /** (Experimental) Called once every second with performance metrics. */\n  _onMetrics?: ((metrics: DeckMetrics) => void) | null;\n\n  /** A custom callback to retrieve the cursor type. */\n  getCursor?: (state: CursorState) => string;\n  /** Callback that takes a hovered-over point and renders a tooltip. */\n  getTooltip?: ((info: PickingInfo) => TooltipContent) | null;\n\n  /** (Debug) Flag to enable WebGL debug mode. Requires importing `@luma.gl/debug`. */\n  debug?: boolean;\n  /** (Debug) Render the picking buffer to screen. */\n  drawPickingColors?: boolean;\n};\n\nconst defaultProps = {\n  id: '',\n  width: '100%',\n  height: '100%',\n  style: null,\n  viewState: null,\n  initialViewState: null,\n  pickingRadius: 0,\n  layerFilter: null,\n  glOptions: {},\n  parameters: {},\n  parent: null,\n  gl: null,\n  canvas: null,\n  layers: [],\n  effects: [],\n  views: null,\n  controller: null, // Rely on external controller, e.g. react-map-gl\n  useDevicePixels: true,\n  touchAction: 'none',\n  eventRecognizerOptions: {},\n  _framebuffer: null,\n  _animate: false,\n  _pickable: true,\n  _typedArrayManagerProps: {},\n  _customRender: null,\n\n  onWebGLInitialized: noop,\n  onResize: noop,\n  onViewStateChange: noop,\n  onInteractionStateChange: noop,\n  onBeforeRender: noop,\n  onAfterRender: noop,\n  onLoad: noop,\n  onError: (error: Error) => log.error(error.message)(),\n  onHover: null,\n  onClick: null,\n  onDragStart: null,\n  onDrag: null,\n  onDragEnd: null,\n  _onMetrics: null,\n\n  getCursor,\n  getTooltip: null,\n\n  debug: false,\n  drawPickingColors: false\n};\n\n/* eslint-disable max-statements */\nexport default class Deck {\n  static defaultProps = defaultProps;\n  // This is used to defeat tree shaking of init.js\n  // https://github.com/visgl/deck.gl/issues/3213\n  static VERSION = deckGlobal.VERSION;\n\n  readonly props: Required<DeckProps>;\n  readonly width: number = 0;\n  readonly height: number = 0;\n  // Allows attaching arbitrary data to the instance\n  readonly userData: Record<string, any> = {};\n\n  protected canvas: HTMLCanvasElement | null = null;\n  protected viewManager: ViewManager | null = null;\n  protected layerManager: LayerManager | null = null;\n  protected effectManager: EffectManager | null = null;\n  protected deckRenderer: DeckRenderer | null = null;\n  protected deckPicker: DeckPicker | null = null;\n  protected eventManager: EventManager | null = null;\n  protected tooltip: Tooltip | null = null;\n  protected metrics: DeckMetrics;\n  protected animationLoop: AnimationLoop;\n  protected stats: Stats;\n\n  /** Internal view state if no callback is supplied */\n  protected viewState: any;\n  protected cursorState: CursorState;\n\n  private _needsRedraw: false | string;\n  private _pickRequest: {\n    mode: string;\n    event: MjolnirPointerEvent | null;\n    x: number;\n    y: number;\n    radius: number;\n  };\n  /**\n   * Pick and store the object under the pointer on `pointerdown`.\n   * This object is reused for subsequent `onClick` and `onDrag*` callbacks.\n   */\n  private _lastPointerDownInfo: PickingInfo | null = null;\n  private _metricsCounter: number;\n\n  constructor(props: DeckProps) {\n    this.props = {...defaultProps, ...props};\n    props = this.props;\n\n    this._needsRedraw = 'Initial render';\n    this._pickRequest = {\n      mode: 'hover',\n      x: -1,\n      y: -1,\n      radius: 0,\n      event: null\n    };\n\n    this.cursorState = {\n      isHovering: false,\n      isDragging: false\n    };\n\n    if (props.viewState && props.initialViewState) {\n      log.warn(\n        'View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.'\n      )();\n    }\n    if (getBrowser() === 'IE') {\n      log.warn('IE 11 is not supported')();\n    }\n    this.viewState = props.initialViewState;\n\n    if (!props.gl) {\n      // Note: LayerManager creation deferred until gl context available\n      if (typeof document !== 'undefined') {\n        this.canvas = this._createCanvas(props);\n      }\n    }\n    this.animationLoop = this._createAnimationLoop(props);\n\n    this.stats = new Stats({id: 'deck.gl'});\n    this.metrics = {\n      fps: 0,\n      setPropsTime: 0,\n      updateAttributesTime: 0,\n      framesRedrawn: 0,\n      pickTime: 0,\n      pickCount: 0,\n      gpuTime: 0,\n      gpuTimePerFrame: 0,\n      cpuTime: 0,\n      cpuTimePerFrame: 0,\n      bufferMemory: 0,\n      textureMemory: 0,\n      renderbufferMemory: 0,\n      gpuMemory: 0\n    };\n    this._metricsCounter = 0;\n\n    this.setProps(props);\n\n    // UNSAFE/experimental prop: only set at initialization to avoid performance hit\n    if (props._typedArrayManagerProps) {\n      typedArrayManager.setOptions(props._typedArrayManagerProps);\n    }\n\n    this.animationLoop.start();\n  }\n\n  /** Stop rendering and dispose all resources */\n  finalize() {\n    this.animationLoop.stop();\n    this.animationLoop = null;\n    this._lastPointerDownInfo = null;\n\n    this.layerManager?.finalize();\n    this.layerManager = null;\n\n    this.viewManager?.finalize();\n    this.viewManager = null;\n\n    this.effectManager?.finalize();\n    this.effectManager = null;\n\n    this.deckRenderer?.finalize();\n    this.deckRenderer = null;\n\n    this.deckPicker?.finalize();\n    this.deckPicker = null;\n\n    this.eventManager?.destroy();\n    this.eventManager = null;\n\n    this.tooltip?.remove();\n    this.tooltip = null;\n\n    if (!this.props.canvas && !this.props.gl && this.canvas) {\n      // remove internally created canvas\n      this.canvas.parentElement?.removeChild(this.canvas);\n      this.canvas = null;\n    }\n  }\n\n  /** Partially update props */\n  setProps(props: DeckProps): void {\n    this.stats.get('setProps Time').timeStart();\n\n    if ('onLayerHover' in props) {\n      log.removed('onLayerHover', 'onHover')();\n    }\n    if ('onLayerClick' in props) {\n      log.removed('onLayerClick', 'onClick')();\n    }\n    if (props.initialViewState && !deepEqual(this.props.initialViewState, props.initialViewState)) {\n      // Overwrite internal view state\n      this.viewState = props.initialViewState;\n    }\n\n    // Merge with existing props\n    Object.assign(this.props, props);\n\n    // Update CSS size of canvas\n    this._setCanvasSize(this.props);\n\n    // We need to overwrite CSS style width and height with actual, numeric values\n    const resolvedProps: Required<DeckProps> & {\n      width: number;\n      height: number;\n      views: View[];\n      viewState: Record<string, any>;\n    } = Object.create(this.props);\n    Object.assign(resolvedProps, {\n      views: this._getViews(),\n      width: this.width,\n      height: this.height,\n      viewState: this._getViewState()\n    });\n\n    // Update the animation loop\n    this.animationLoop.setProps(resolvedProps);\n\n    // If initialized, update sub manager props\n    if (this.layerManager) {\n      this.viewManager!.setProps(resolvedProps);\n      // Make sure that any new layer gets initialized with the current viewport\n      this.layerManager.activateViewport(this.getViewports()[0]);\n      this.layerManager.setProps(resolvedProps);\n      this.effectManager!.setProps(resolvedProps);\n      this.deckRenderer!.setProps(resolvedProps);\n      this.deckPicker!.setProps(resolvedProps);\n    }\n\n    this.stats.get('setProps Time').timeEnd();\n  }\n\n  // Public API\n\n  /**\n   * Check if a redraw is needed\n   * @returns `false` or a string summarizing the redraw reason\n   */\n  needsRedraw(\n    opts: {\n      /** Reset the redraw flag afterwards. Default `true` */\n      clearRedrawFlags: boolean;\n    } = {clearRedrawFlags: false}\n  ): false | string {\n    if (!this.layerManager) {\n      // Not initialized or already finalized\n      return false;\n    }\n    if (this.props._animate) {\n      return 'Deck._animate';\n    }\n\n    let redraw: false | string = this._needsRedraw;\n\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    const viewManagerNeedsRedraw = this.viewManager!.needsRedraw(opts);\n    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);\n    const effectManagerNeedsRedraw = this.effectManager!.needsRedraw(opts);\n    const deckRendererNeedsRedraw = this.deckRenderer!.needsRedraw(opts);\n\n    redraw =\n      redraw ||\n      viewManagerNeedsRedraw ||\n      layerManagerNeedsRedraw ||\n      effectManagerNeedsRedraw ||\n      deckRendererNeedsRedraw;\n    return redraw;\n  }\n\n  /**\n   * Redraw the GL context\n   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.\n   * @returns\n   */\n  redraw(reason?: string): void {\n    if (!this.layerManager) {\n      // Not yet initialized\n      return;\n    }\n    // Check if we need to redraw\n    let redrawReason = this.needsRedraw({clearRedrawFlags: true});\n    // User-supplied should take precedent, however the redraw flags get cleared regardless\n    redrawReason = reason || redrawReason;\n\n    if (!redrawReason) {\n      return;\n    }\n\n    this.stats.get('Redraw Count').incrementCount();\n    if (this.props._customRender) {\n      this.props._customRender(redrawReason);\n    } else {\n      this._drawLayers(redrawReason);\n    }\n  }\n\n  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */\n  get isInitialized(): boolean {\n    return this.viewManager !== null;\n  }\n\n  /** Get a list of views that are currently rendered */\n  getViews(): View[] {\n    assert(this.viewManager);\n    return this.viewManager.views;\n  }\n\n  /** Get a list of viewports that are currently rendered.\n   * @param rect If provided, only returns viewports within the given bounding box.\n   */\n  getViewports(rect?: {x: number; y: number; width?: number; height?: number}): Viewport[] {\n    assert(this.viewManager);\n    return this.viewManager.getViewports(rect);\n  }\n\n  /** Query the object rendered on top at a given point */\n  pickObject(opts: {\n    /** x position in pixels */\n    x: number;\n    /** y position in pixels */\n    y: number;\n    /** Radius of tolerance in pixels. Default `0`. */\n    radius?: number;\n    /** A list of layer ids to query from. If not specified, then all pickable and visible layers are queried. */\n    layerIds?: string[];\n    /** If `true`, `info.coordinate` will be a 3D point by unprojecting the `x, y` screen coordinates onto the picked geometry. Default `false`. */\n    unproject3D?: boolean;\n  }): PickingInfo | null {\n    const infos = this._pick('pickObject', 'pickObject Time', opts).result;\n    return infos.length ? infos[0] : null;\n  }\n\n  /* Query all rendered objects at a given point */\n  pickMultipleObjects(opts: {\n    /** x position in pixels */\n    x: number;\n    /** y position in pixels */\n    y: number;\n    /** Radius of tolerance in pixels. Default `0`. */\n    radius?: number;\n    /** Specifies the max number of objects to return. Default `10`. */\n    depth?: number;\n    /** A list of layer ids to query from. If not specified, then all pickable and visible layers are queried. */\n    layerIds?: string[];\n    /** If `true`, `info.coordinate` will be a 3D point by unprojecting the `x, y` screen coordinates onto the picked geometry. Default `false`. */\n    unproject3D?: boolean;\n  }): PickingInfo[] {\n    opts.depth = opts.depth || 10;\n    return this._pick('pickObject', 'pickMultipleObjects Time', opts).result;\n  }\n\n  /* Query all objects rendered on top within a bounding box */\n  pickObjects(opts: {\n    /** Left of the bounding box in pixels */\n    x: number;\n    /** Top of the bounding box in pixels */\n    y: number;\n    /** Width of the bounding box in pixels. Default `1` */\n    width?: number;\n    /** Height of the bounding box in pixels. Default `1` */\n    height?: number;\n    /** A list of layer ids to query from. If not specified, then all pickable and visible layers are queried. */\n    layerIds?: string[];\n    /** If specified, limits the number of objects that can be returned. */\n    maxObjects?: number | null;\n  }): PickingInfo[] {\n    return this._pick('pickObjects', 'pickObjects Time', opts);\n  }\n\n  /** Experimental\n   * Add a global resource for sharing among layers\n   */\n  _addResources(\n    resources: {\n      [id: string]: any;\n    },\n    forceUpdate = false\n  ) {\n    for (const id in resources) {\n      this.layerManager!.resourceManager.add({resourceId: id, data: resources[id], forceUpdate});\n    }\n  }\n\n  /** Experimental\n   * Remove a global resource\n   */\n  _removeResources(resourceIds: string[]) {\n    for (const id of resourceIds) {\n      this.layerManager!.resourceManager.remove(id);\n    }\n  }\n\n  // Private Methods\n\n  private _pick(\n    method: 'pickObject',\n    statKey: string,\n    opts: PickByPointOptions & {layerIds?: string[]}\n  ): {\n    result: PickingInfo[];\n    emptyInfo: PickingInfo;\n  };\n  private _pick(\n    method: 'pickObjects',\n    statKey: string,\n    opts: PickByRectOptions & {layerIds?: string[]}\n  ): PickingInfo[];\n\n  private _pick(\n    method: 'pickObject' | 'pickObjects',\n    statKey: string,\n    opts: (PickByPointOptions | PickByRectOptions) & {layerIds?: string[]}\n  ) {\n    assert(this.deckPicker);\n\n    const {stats} = this;\n\n    stats.get('Pick Count').incrementCount();\n    stats.get(statKey).timeStart();\n\n    const infos = this.deckPicker[method]({\n      // layerManager, viewManager and effectManager are always defined if deckPicker is\n      layers: this.layerManager!.getLayers(opts),\n      views: this.viewManager!.getViews(),\n      viewports: this.getViewports(opts),\n      onViewportActive: this.layerManager!.activateViewport,\n      effects: this.effectManager!.getEffects(),\n      ...opts\n    });\n\n    stats.get(statKey).timeEnd();\n\n    return infos;\n  }\n\n  /** Resolve props.canvas to element */\n  private _createCanvas(props: DeckProps): HTMLCanvasElement {\n    let canvas = props.canvas;\n\n    // TODO EventManager should accept element id\n    if (typeof canvas === 'string') {\n      canvas = document.getElementById(canvas) as HTMLCanvasElement;\n      assert(canvas);\n    }\n\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.id = props.id || 'deckgl-overlay';\n      const parent = props.parent || document.body;\n      parent.appendChild(canvas);\n    }\n\n    Object.assign(canvas.style, props.style);\n\n    return canvas;\n  }\n\n  /** Updates canvas width and/or height, if provided as props */\n  private _setCanvasSize(props: Required<DeckProps>): void {\n    if (!this.canvas) {\n      return;\n    }\n\n    const {width, height} = props;\n    // Set size ONLY if props are being provided, otherwise let canvas be layouted freely\n    if (width || width === 0) {\n      const cssWidth = Number.isFinite(width) ? `${width}px` : (width as string);\n      this.canvas.style.width = cssWidth;\n    }\n    if (height || height === 0) {\n      const cssHeight = Number.isFinite(height) ? `${height}px` : (height as string);\n      // Note: position==='absolute' required for height 100% to work\n      this.canvas.style.position = props.style?.position || 'absolute';\n      this.canvas.style.height = cssHeight;\n    }\n  }\n\n  /** If canvas size has changed, reads out the new size and update */\n  private _updateCanvasSize(): void {\n    const {canvas} = this;\n    if (!canvas) {\n      return;\n    }\n    // Fallback to width/height when clientWidth/clientHeight are 0 or undefined.\n    const newWidth = canvas.clientWidth || canvas.width;\n    const newHeight = canvas.clientHeight || canvas.height;\n    if (newWidth !== this.width || newHeight !== this.height) {\n      // @ts-expect-error private assign to read-only property\n      this.width = newWidth;\n      // @ts-expect-error private assign to read-only property\n      this.height = newHeight;\n      this.viewManager?.setProps({width: newWidth, height: newHeight});\n      this.props.onResize({width: newWidth, height: newHeight});\n    }\n  }\n\n  private _createAnimationLoop(props: DeckProps): AnimationLoop {\n    const {\n      width,\n      height,\n      gl,\n      glOptions,\n      debug,\n      onError,\n      onBeforeRender,\n      onAfterRender,\n      useDevicePixels\n    } = props;\n\n    return new AnimationLoop({\n      width,\n      height,\n      useDevicePixels,\n      autoResizeViewport: false,\n      gl,\n      onCreateContext: opts =>\n        createGLContext({\n          ...glOptions,\n          ...opts,\n          canvas: this.canvas,\n          debug,\n          onContextLost: () => this._onContextLost()\n        }),\n      onInitialize: context => this._setGLContext(context.gl),\n      onRender: this._onRenderFrame.bind(this),\n      onBeforeRender,\n      onAfterRender,\n      onError\n    });\n  }\n\n  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState\n  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState\n  private _getViewState(): Record<string, any> {\n    return this.props.viewState || this.viewState;\n  }\n\n  // Get the view descriptor list\n  private _getViews(): View[] {\n    // Default to a full screen map view port\n    let views = this.props.views || [new MapView({id: 'default-view'})];\n    views = Array.isArray(views) ? views : [views];\n    if (views.length && this.props.controller) {\n      // Backward compatibility: support controller prop\n      views[0].props.controller = this.props.controller;\n    }\n    return views;\n  }\n\n  private _onContextLost() {\n    const {onError} = this.props;\n    if (this.animationLoop && onError) {\n      onError(new Error('WebGL context is lost'));\n    }\n  }\n\n  // The `pointermove` event may fire multiple times in between two animation frames,\n  // it's a waste of time to run picking without rerender. Instead we save the last pick\n  // request and only do it once on the next animation frame.\n  /** Internal use only: event handler for pointerdown */\n  _onPointerMove = (event: MjolnirPointerEvent) => {\n    const {_pickRequest} = this;\n    if (event.type === 'pointerleave') {\n      _pickRequest.x = -1;\n      _pickRequest.y = -1;\n      _pickRequest.radius = 0;\n    } else if (event.leftButton || event.rightButton) {\n      // Do not trigger onHover callbacks if mouse button is down.\n      return;\n    } else {\n      const pos = event.offsetCenter;\n      // Do not trigger callbacks when click/hover position is invalid. Doing so will cause a\n      // assertion error when attempting to unproject the position.\n      if (!pos) {\n        return;\n      }\n      _pickRequest.x = pos.x;\n      _pickRequest.y = pos.y;\n      _pickRequest.radius = this.props.pickingRadius;\n    }\n\n    if (this.layerManager) {\n      this.layerManager.context.mousePosition = {x: _pickRequest.x, y: _pickRequest.y};\n    }\n\n    _pickRequest.event = event;\n  };\n\n  /** Actually run picking */\n  private _pickAndCallback() {\n    const {_pickRequest} = this;\n\n    if (_pickRequest.event) {\n      // Perform picking\n      const {result, emptyInfo} = this._pick('pickObject', 'pickObject Time', _pickRequest);\n      this.cursorState.isHovering = result.length > 0;\n\n      // There are 4 possible scenarios:\n      // result is [outInfo, pickedInfo] (moved from one pickable layer to another)\n      // result is [outInfo] (moved outside of a pickable layer)\n      // result is [pickedInfo] (moved into or over a pickable layer)\n      // result is [] (nothing is or was picked)\n      //\n      // `layer.props.onHover` should be called on all affected layers (out/over)\n      // `deck.props.onHover` should be called with the picked info if any, or empty info otherwise\n      // `deck.props.getTooltip` should be called with the picked info if any, or empty info otherwise\n\n      // Execute callbacks\n      let pickedInfo = emptyInfo;\n      let handled = false;\n      for (const info of result) {\n        pickedInfo = info;\n        handled = info.layer?.onHover(info, _pickRequest.event) || handled;\n      }\n      if (!handled && this.props.onHover) {\n        this.props.onHover(pickedInfo, _pickRequest.event);\n      }\n\n      // Update tooltip\n      if (this.props.getTooltip && this.tooltip) {\n        const displayInfo = this.props.getTooltip(pickedInfo);\n        this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);\n      }\n\n      // Clear pending pickRequest\n      _pickRequest.event = null;\n    }\n  }\n\n  private _updateCursor(): void {\n    const container = this.props.parent || this.canvas;\n    if (container) {\n      container.style.cursor = this.props.getCursor(this.cursorState);\n    }\n  }\n\n  private _setGLContext(gl: WebGLRenderingContext) {\n    if (this.layerManager) {\n      return;\n    }\n\n    // if external context...\n    if (!this.canvas) {\n      this.canvas = gl.canvas;\n      instrumentGLContext(gl, {enable: true, copyState: true});\n    }\n\n    this.tooltip = new Tooltip(this.canvas);\n\n    setParameters(gl, {\n      blend: true,\n      blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA],\n      polygonOffsetFill: true,\n      depthTest: true,\n      depthFunc: GL.LEQUAL\n    });\n\n    this.props.onWebGLInitialized(gl);\n\n    // timeline for transitions\n    const timeline = new Timeline();\n    timeline.play();\n    this.animationLoop.attachTimeline(timeline);\n\n    this.eventManager = new EventManager(this.props.parent || gl.canvas, {\n      touchAction: this.props.touchAction,\n      recognizerOptions: this.props.eventRecognizerOptions,\n      events: {\n        pointerdown: this._onPointerDown,\n        pointermove: this._onPointerMove,\n        pointerleave: this._onPointerMove\n      }\n    });\n    for (const eventType in EVENTS) {\n      this.eventManager.on(eventType as keyof typeof EVENTS, this._onEvent);\n    }\n\n    this.viewManager = new ViewManager({\n      timeline,\n      eventManager: this.eventManager,\n      onViewStateChange: this._onViewStateChange.bind(this),\n      onInteractionStateChange: this._onInteractionStateChange.bind(this),\n      views: this._getViews(),\n      viewState: this._getViewState(),\n      width: this.width,\n      height: this.height\n    });\n\n    // viewManager must be initialized before layerManager\n    // layerManager depends on viewport created by viewManager.\n    const viewport = this.viewManager.getViewports()[0];\n\n    // Note: avoid React setState due GL animation loop / setState timing issue\n    this.layerManager = new LayerManager(gl, {\n      deck: this,\n      stats: this.stats,\n      viewport,\n      timeline\n    });\n\n    this.effectManager = new EffectManager();\n\n    this.deckRenderer = new DeckRenderer(gl);\n\n    this.deckPicker = new DeckPicker(gl);\n\n    this.setProps(this.props);\n\n    this._updateCanvasSize();\n    this.props.onLoad();\n  }\n\n  /** Internal only: default render function (redraw all layers and views) */\n  _drawLayers(\n    redrawReason: string,\n    renderOptions?: {\n      target?: Framebuffer;\n      layerFilter?: (context: FilterContext) => boolean;\n      layers?: Layer[];\n      viewports?: Viewport[];\n      views?: {[viewId: string]: View};\n      pass?: string;\n      effects?: Effect[];\n      clearStack?: boolean;\n      clearCanvas?: boolean;\n    }\n  ) {\n    const {gl} = this.layerManager!.context;\n\n    setParameters(gl, this.props.parameters);\n\n    this.props.onBeforeRender({gl});\n\n    this.deckRenderer!.renderLayers({\n      target: this.props._framebuffer,\n      layers: this.layerManager!.getLayers(),\n      viewports: this.viewManager!.getViewports(),\n      onViewportActive: this.layerManager!.activateViewport,\n      views: this.viewManager!.getViews(),\n      pass: 'screen',\n      redrawReason,\n      effects: this.effectManager!.getEffects(),\n      ...renderOptions\n    });\n\n    this.props.onAfterRender({gl});\n  }\n\n  // Callbacks\n\n  private _onRenderFrame(animationProps: any) {\n    this._getFrameStats();\n\n    // Log perf stats every second\n    if (this._metricsCounter++ % 60 === 0) {\n      this._getMetrics();\n      this.stats.reset();\n      log.table(4, this.metrics)();\n\n      // Experimental: report metrics\n      if (this.props._onMetrics) {\n        this.props._onMetrics(this.metrics);\n      }\n    }\n\n    this._updateCanvasSize();\n\n    this._updateCursor();\n\n    // If view state has changed, clear tooltip\n    if (this.tooltip!.isVisible && this.viewManager!.needsRedraw()) {\n      this.tooltip!.setTooltip(null);\n    }\n\n    // Update layers if needed (e.g. some async prop has loaded)\n    // Note: This can trigger a redraw\n    this.layerManager!.updateLayers();\n\n    // Perform picking request if any\n    this._pickAndCallback();\n\n    // Redraw if necessary\n    this.redraw();\n\n    // Update viewport transition if needed\n    // Note: this can trigger `onViewStateChange`, and affect layers\n    // We want to defer these changes to the next frame\n    if (this.viewManager) {\n      this.viewManager.updateViewStates();\n    }\n  }\n\n  // Callbacks\n\n  private _onViewStateChange(params: ViewStateChangeParameters & {viewId: string}) {\n    // Let app know that view state is changing, and give it a chance to change it\n    const viewState = this.props.onViewStateChange(params) || params.viewState;\n\n    // If initialViewState was set on creation, auto track position\n    if (this.viewState) {\n      this.viewState = {...this.viewState, [params.viewId]: viewState};\n      if (!this.props.viewState) {\n        // Apply internal view state\n        if (this.viewManager) {\n          this.viewManager.setProps({viewState: this.viewState});\n        }\n      }\n    }\n  }\n\n  private _onInteractionStateChange(interactionState: InteractionState) {\n    this.cursorState.isDragging = interactionState.isDragging || false;\n    this.props.onInteractionStateChange(interactionState);\n  }\n\n  /** Internal use only: event handler for click & drag */\n  _onEvent = (event: MjolnirGestureEvent) => {\n    const eventOptions = EVENTS[event.type];\n    const pos = event.offsetCenter;\n\n    if (!eventOptions || !pos || !this.layerManager) {\n      return;\n    }\n\n    // Reuse last picked object\n    const layers = this.layerManager.getLayers();\n    const info = this.deckPicker!.getLastPickedObject(\n      {\n        x: pos.x,\n        y: pos.y,\n        layers,\n        viewports: this.getViewports(pos)\n      },\n      this._lastPointerDownInfo\n    );\n\n    const {layer} = info;\n    const layerHandler =\n      layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);\n    const rootHandler = this.props[eventOptions.handler];\n    let handled = false;\n\n    if (layerHandler) {\n      handled = layerHandler.call(layer, info, event);\n    }\n    if (!handled && rootHandler) {\n      rootHandler(info, event);\n    }\n  };\n\n  /** Internal use only: evnet handler for pointerdown */\n  _onPointerDown = (event: MjolnirPointerEvent) => {\n    const pos = event.offsetCenter;\n    const pickedInfo = this._pick('pickObject', 'pickObject Time', {\n      x: pos.x,\n      y: pos.y,\n      radius: this.props.pickingRadius\n    });\n    this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;\n  };\n\n  private _getFrameStats(): void {\n    const {stats} = this;\n    stats.get('frameRate').timeEnd();\n    stats.get('frameRate').timeStart();\n\n    // Get individual stats from luma.gl so reset works\n    const animationLoopStats = this.animationLoop.stats;\n    stats.get('GPU Time').addTime(animationLoopStats.get('GPU Time').lastTiming);\n    stats.get('CPU Time').addTime(animationLoopStats.get('CPU Time').lastTiming);\n  }\n\n  private _getMetrics(): void {\n    const {metrics, stats} = this;\n    metrics.fps = stats.get('frameRate').getHz();\n    metrics.setPropsTime = stats.get('setProps Time').time;\n    metrics.updateAttributesTime = stats.get('Update Attributes').time;\n    metrics.framesRedrawn = stats.get('Redraw Count').count;\n    metrics.pickTime =\n      stats.get('pickObject Time').time +\n      stats.get('pickMultipleObjects Time').time +\n      stats.get('pickObjects Time').time;\n    metrics.pickCount = stats.get('Pick Count').count;\n\n    // Luma stats\n    metrics.gpuTime = stats.get('GPU Time').time;\n    metrics.cpuTime = stats.get('CPU Time').time;\n    metrics.gpuTimePerFrame = stats.get('GPU Time').getAverageTime();\n    metrics.cpuTimePerFrame = stats.get('CPU Time').getAverageTime();\n\n    const memoryStats = lumaStats.get('Memory Usage');\n    metrics.bufferMemory = memoryStats.get('Buffer Memory').count;\n    metrics.textureMemory = memoryStats.get('Texture Memory').count;\n    metrics.renderbufferMemory = memoryStats.get('Renderbuffer Memory').count;\n    metrics.gpuMemory = memoryStats.get('GPU Memory').count;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}