{"ast":null,"code":"import { Manager } from './utils/hammer';\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\nimport EventRegistrar from './utils/event-registrar';\nimport { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';\nconst DEFAULT_OPTIONS = {\n  // event handlers\n  events: null,\n  // custom recognizers\n  recognizers: null,\n  recognizerOptions: {},\n  // Manager class\n  Manager,\n  // allow browser default touch action\n  // https://github.com/uber/react-map-gl/issues/506\n  touchAction: 'none',\n  tabIndex: 0\n}; // Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\n\nexport default class EventManager {\n  constructor(element = null, options) {\n    /**\n     * Handle basic events using the 'hammer.input' Hammer.js API:\n     * Before running Recognizers, Hammer emits a 'hammer.input' event\n     * with the basic event info. This function emits all basic events\n     * aliased to the \"class\" of event received.\n     * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n     */\n    this._onBasicInput = event => {\n      const {\n        srcEvent\n      } = event;\n      const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n\n      if (alias) {\n        // fire all events aliased to srcEvent.type\n        this.manager.emit(alias, event);\n      }\n    };\n    /**\n     * Handle events not supported by Hammer.js,\n     * and pipe back out through same (Hammer) channel used by other events.\n     */\n\n\n    this._onOtherEvent = event => {\n      // console.log('onotherevent', event.type, event)\n      this.manager.emit(event.type, event);\n    };\n\n    this.options = { ...DEFAULT_OPTIONS,\n      ...options\n    };\n    this.events = new Map();\n    this.setElement(element); // Register all passed events.\n\n    const {\n      events\n    } = this.options;\n\n    if (events) {\n      this.on(events);\n    }\n  }\n\n  getElement() {\n    return this.element;\n  }\n\n  setElement(element) {\n    if (this.element) {\n      // unregister all events\n      this.destroy();\n    }\n\n    this.element = element;\n\n    if (!element) {\n      return;\n    }\n\n    const {\n      options\n    } = this;\n    const ManagerClass = options.Manager;\n    this.manager = new ManagerClass(element, {\n      touchAction: options.touchAction,\n      recognizers: options.recognizers || RECOGNIZERS\n    }).on('hammer.input', this._onBasicInput);\n\n    if (!options.recognizers) {\n      // Set default recognize withs\n      // http://hammerjs.github.io/recognize-with/\n      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n        const recognizer = this.manager.get(name);\n\n        if (recognizer) {\n          RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n            recognizer.recognizeWith(otherName);\n          });\n        }\n      });\n    } // Set recognizer options\n\n\n    for (const recognizerName in options.recognizerOptions) {\n      const recognizer = this.manager.get(recognizerName);\n\n      if (recognizer) {\n        const recognizerOption = options.recognizerOptions[recognizerName]; // `enable` is managed by the event registrations\n\n        delete recognizerOption.enable;\n        recognizer.set(recognizerOption);\n      }\n    } // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n\n\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    }); // Register all existing events\n\n    for (const [eventAlias, eventRegistrar] of this.events) {\n      if (!eventRegistrar.isEmpty()) {\n        // Enable recognizer for this event.\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n\n        this.manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n  } // Tear down internal event management implementations.\n\n\n  destroy() {\n    if (this.element) {\n      // wheelInput etc. are created in setElement() and therefore\n      // cannot exist if there is no element\n      this.wheelInput.destroy();\n      this.moveInput.destroy();\n      this.keyInput.destroy();\n      this.contextmenuInput.destroy();\n      this.manager.destroy();\n      this.wheelInput = null;\n      this.moveInput = null;\n      this.keyInput = null;\n      this.contextmenuInput = null;\n      this.manager = null;\n      this.element = null;\n    }\n  }\n  /** Register an event handler function to be called on `event` */\n\n\n  on(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n\n  once(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n\n  watch(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n\n  off(event, handler) {\n    this._removeEventHandler(event, handler);\n  }\n  /*\n   * Enable/disable recognizer for the given event\n   */\n\n\n  _toggleRecognizer(name, enabled) {\n    const {\n      manager\n    } = this;\n\n    if (!manager) {\n      return;\n    }\n\n    const recognizer = manager.get(name); // @ts-ignore\n\n    if (recognizer && recognizer.options.enable !== enabled) {\n      recognizer.set({\n        enable: enabled\n      });\n      const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n\n      if (fallbackRecognizers && !this.options.recognizers) {\n        // Set default require failures\n        // http://hammerjs.github.io/require-failure/\n        fallbackRecognizers.forEach(otherName => {\n          const otherRecognizer = manager.get(otherName);\n\n          if (enabled) {\n            // Wait for this recognizer to fail\n            otherRecognizer.requireFailure(name);\n            /**\n             * This seems to be a bug in hammerjs:\n             * requireFailure() adds both ways\n             * dropRequireFailure() only drops one way\n             * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n               recognizer-constructor.js#L136\n             */\n\n            recognizer.dropRequireFailure(otherName);\n          } else {\n            // Do not wait for this recognizer to fail\n            otherRecognizer.dropRequireFailure(name);\n          }\n        });\n      }\n    }\n\n    this.wheelInput.enableEventType(name, enabled);\n    this.moveInput.enableEventType(name, enabled);\n    this.keyInput.enableEventType(name, enabled);\n    this.contextmenuInput.enableEventType(name, enabled);\n  }\n  /**\n   * Process the event registration for a single event + handler.\n   */\n\n\n  _addEventHandler(event, handler, opts, once, passive) {\n    if (typeof event !== 'string') {\n      // @ts-ignore\n      opts = handler; // If `event` is a map, call `on()` for each entry.\n\n      for (const eventName in event) {\n        this._addEventHandler(eventName, event[eventName], opts, once, passive);\n      }\n\n      return;\n    }\n\n    const {\n      manager,\n      events\n    } = this; // Alias to a recognized gesture as necessary.\n\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n    let eventRegistrar = events.get(eventAlias);\n\n    if (!eventRegistrar) {\n      eventRegistrar = new EventRegistrar(this);\n      events.set(eventAlias, eventRegistrar); // Enable recognizer for this event.\n\n      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias; // Listen to the event\n\n      if (manager) {\n        manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n\n    eventRegistrar.add(event, handler, opts, once, passive);\n\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n\n\n  _removeEventHandler(event, handler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const eventName in event) {\n        this._removeEventHandler(eventName, event[eventName]);\n      }\n\n      return;\n    }\n\n    const {\n      events\n    } = this; // Alias to a recognized gesture as necessary.\n\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n    const eventRegistrar = events.get(eventAlias);\n\n    if (!eventRegistrar) {\n      return;\n    }\n\n    eventRegistrar.remove(event, handler);\n\n    if (eventRegistrar.isEmpty()) {\n      const {\n        recognizerName\n      } = eventRegistrar; // Disable recognizer if no more handlers are attached to its events\n\n      let isRecognizerUsed = false;\n\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["../../src/event-manager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Manager } from './utils/hammer';\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\nimport EventRegistrar from './utils/event-registrar';\nimport { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';\nconst DEFAULT_OPTIONS = {\n    // event handlers\n    events: null,\n    // custom recognizers\n    recognizers: null,\n    recognizerOptions: {},\n    // Manager class\n    Manager,\n    // allow browser default touch action\n    // https://github.com/uber/react-map-gl/issues/506\n    touchAction: 'none',\n    tabIndex: 0\n};\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport default class EventManager {\n    constructor(element = null, options) {\n        /**\n         * Handle basic events using the 'hammer.input' Hammer.js API:\n         * Before running Recognizers, Hammer emits a 'hammer.input' event\n         * with the basic event info. This function emits all basic events\n         * aliased to the \"class\" of event received.\n         * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n         */\n        this._onBasicInput = (event) => {\n            const { srcEvent } = event;\n            const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n            if (alias) {\n                // fire all events aliased to srcEvent.type\n                this.manager.emit(alias, event);\n            }\n        };\n        /**\n         * Handle events not supported by Hammer.js,\n         * and pipe back out through same (Hammer) channel used by other events.\n         */\n        this._onOtherEvent = (event) => {\n            // console.log('onotherevent', event.type, event)\n            this.manager.emit(event.type, event);\n        };\n        this.options = { ...DEFAULT_OPTIONS, ...options };\n        this.events = new Map();\n        this.setElement(element);\n        // Register all passed events.\n        const { events } = this.options;\n        if (events) {\n            this.on(events);\n        }\n    }\n    getElement() {\n        return this.element;\n    }\n    setElement(element) {\n        if (this.element) {\n            // unregister all events\n            this.destroy();\n        }\n        this.element = element;\n        if (!element) {\n            return;\n        }\n        const { options } = this;\n        const ManagerClass = options.Manager;\n        this.manager = new ManagerClass(element, {\n            touchAction: options.touchAction,\n            recognizers: options.recognizers || RECOGNIZERS\n        }).on('hammer.input', this._onBasicInput);\n        if (!options.recognizers) {\n            // Set default recognize withs\n            // http://hammerjs.github.io/recognize-with/\n            Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n                const recognizer = this.manager.get(name);\n                if (recognizer) {\n                    RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n                        recognizer.recognizeWith(otherName);\n                    });\n                }\n            });\n        }\n        // Set recognizer options\n        for (const recognizerName in options.recognizerOptions) {\n            const recognizer = this.manager.get(recognizerName);\n            if (recognizer) {\n                const recognizerOption = options.recognizerOptions[recognizerName];\n                // `enable` is managed by the event registrations\n                delete recognizerOption.enable;\n                recognizer.set(recognizerOption);\n            }\n        }\n        // Handle events not handled by Hammer.js:\n        // - mouse wheel\n        // - pointer/touch/mouse move\n        this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n            enable: false\n        });\n        this.moveInput = new MoveInput(element, this._onOtherEvent, {\n            enable: false\n        });\n        this.keyInput = new KeyInput(element, this._onOtherEvent, {\n            enable: false,\n            tabIndex: options.tabIndex\n        });\n        this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n            enable: false\n        });\n        // Register all existing events\n        for (const [eventAlias, eventRegistrar] of this.events) {\n            if (!eventRegistrar.isEmpty()) {\n                // Enable recognizer for this event.\n                this._toggleRecognizer(eventRegistrar.recognizerName, true);\n                this.manager.on(eventAlias, eventRegistrar.handleEvent);\n            }\n        }\n    }\n    // Tear down internal event management implementations.\n    destroy() {\n        if (this.element) {\n            // wheelInput etc. are created in setElement() and therefore\n            // cannot exist if there is no element\n            this.wheelInput.destroy();\n            this.moveInput.destroy();\n            this.keyInput.destroy();\n            this.contextmenuInput.destroy();\n            this.manager.destroy();\n            this.wheelInput = null;\n            this.moveInput = null;\n            this.keyInput = null;\n            this.contextmenuInput = null;\n            this.manager = null;\n            this.element = null;\n        }\n    }\n    /** Register an event handler function to be called on `event` */\n    on(event, handler, opts) {\n        this._addEventHandler(event, handler, opts, false);\n    }\n    once(event, handler, opts) {\n        this._addEventHandler(event, handler, opts, true);\n    }\n    watch(event, handler, opts) {\n        this._addEventHandler(event, handler, opts, false, true);\n    }\n    off(event, handler) {\n        this._removeEventHandler(event, handler);\n    }\n    /*\n     * Enable/disable recognizer for the given event\n     */\n    _toggleRecognizer(name, enabled) {\n        const { manager } = this;\n        if (!manager) {\n            return;\n        }\n        const recognizer = manager.get(name);\n        // @ts-ignore\n        if (recognizer && recognizer.options.enable !== enabled) {\n            recognizer.set({ enable: enabled });\n            const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n            if (fallbackRecognizers && !this.options.recognizers) {\n                // Set default require failures\n                // http://hammerjs.github.io/require-failure/\n                fallbackRecognizers.forEach(otherName => {\n                    const otherRecognizer = manager.get(otherName);\n                    if (enabled) {\n                        // Wait for this recognizer to fail\n                        otherRecognizer.requireFailure(name);\n                        /**\n                         * This seems to be a bug in hammerjs:\n                         * requireFailure() adds both ways\n                         * dropRequireFailure() only drops one way\n                         * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n                           recognizer-constructor.js#L136\n                         */\n                        recognizer.dropRequireFailure(otherName);\n                    }\n                    else {\n                        // Do not wait for this recognizer to fail\n                        otherRecognizer.dropRequireFailure(name);\n                    }\n                });\n            }\n        }\n        this.wheelInput.enableEventType(name, enabled);\n        this.moveInput.enableEventType(name, enabled);\n        this.keyInput.enableEventType(name, enabled);\n        this.contextmenuInput.enableEventType(name, enabled);\n    }\n    /**\n     * Process the event registration for a single event + handler.\n     */\n    _addEventHandler(event, handler, opts, once, passive) {\n        if (typeof event !== 'string') {\n            // @ts-ignore\n            opts = handler;\n            // If `event` is a map, call `on()` for each entry.\n            for (const eventName in event) {\n                this._addEventHandler(eventName, event[eventName], opts, once, passive);\n            }\n            return;\n        }\n        const { manager, events } = this;\n        // Alias to a recognized gesture as necessary.\n        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n        let eventRegistrar = events.get(eventAlias);\n        if (!eventRegistrar) {\n            eventRegistrar = new EventRegistrar(this);\n            events.set(eventAlias, eventRegistrar);\n            // Enable recognizer for this event.\n            eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n            // Listen to the event\n            if (manager) {\n                manager.on(eventAlias, eventRegistrar.handleEvent);\n            }\n        }\n        eventRegistrar.add(event, handler, opts, once, passive);\n        if (!eventRegistrar.isEmpty()) {\n            this._toggleRecognizer(eventRegistrar.recognizerName, true);\n        }\n    }\n    /**\n     * Process the event deregistration for a single event + handler.\n     */\n    _removeEventHandler(event, handler) {\n        if (typeof event !== 'string') {\n            // If `event` is a map, call `off()` for each entry.\n            for (const eventName in event) {\n                this._removeEventHandler(eventName, event[eventName]);\n            }\n            return;\n        }\n        const { events } = this;\n        // Alias to a recognized gesture as necessary.\n        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n        const eventRegistrar = events.get(eventAlias);\n        if (!eventRegistrar) {\n            return;\n        }\n        eventRegistrar.remove(event, handler);\n        if (eventRegistrar.isEmpty()) {\n            const { recognizerName } = eventRegistrar;\n            // Disable recognizer if no more handlers are attached to its events\n            let isRecognizerUsed = false;\n            for (const eh of events.values()) {\n                if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n                    isRecognizerUsed = true;\n                    break;\n                }\n            }\n            if (!isRecognizerUsed) {\n                this._toggleRecognizer(recognizerName, false);\n            }\n        }\n    }\n}\n//# sourceMappingURL=event-manager.js.map"]},"metadata":{},"sourceType":"module"}