{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { COORDINATE_SYSTEM, OPERATION } from './constants';\nimport AttributeManager from './attribute/attribute-manager';\nimport UniformTransitionManager from './uniform-transition-manager';\nimport { diffProps, validateProps } from '../lifecycle/props';\nimport { LIFECYCLE } from '../lifecycle/constants';\nimport { count } from '../utils/count';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport { withParameters, setParameters } from '@luma.gl/core';\nimport assert from '../utils/assert';\nimport memoize from '../utils/memoize';\nimport { mergeShaders } from '../utils/shader';\nimport { projectPosition, getWorldPosition } from '../shaderlib/project/project-functions';\nimport typedArrayManager from '../utils/typed-array-manager';\nimport Component from '../lifecycle/component';\nimport LayerState from './layer-state';\nimport { worldToPixels } from '@math.gl/web-mercator';\nimport { load } from '@loaders.gl/core';\nconst TRACE_CHANGE_FLAG = 'layer.changeFlag';\nconst TRACE_INITIALIZE = 'layer.initialize';\nconst TRACE_UPDATE = 'layer.update';\nconst TRACE_FINALIZE = 'layer.finalize';\nconst TRACE_MATCHED = 'layer.matched';\nconst MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;\nconst EMPTY_ARRAY = Object.freeze([]);\nconst areViewportsEqual = memoize(({\n  oldViewport,\n  viewport\n}) => {\n  return oldViewport.equals(viewport);\n});\nlet pickingColorCache = new Uint8ClampedArray(0);\nconst defaultProps = {\n  data: {\n    type: 'data',\n    value: EMPTY_ARRAY,\n    async: true\n  },\n  dataComparator: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  _dataDiff: {\n    type: 'function',\n    value: data => data && data.__diff,\n    compare: false,\n    optional: true\n  },\n  dataTransform: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  onDataLoad: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  onError: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  fetch: {\n    type: 'function',\n    value: (url, {\n      propName,\n      layer,\n      loaders,\n      loadOptions,\n      signal\n    }) => {\n      const {\n        resourceManager\n      } = layer.context;\n      loadOptions = loadOptions || layer.getLoadOptions();\n      loaders = loaders || layer.props.loaders;\n\n      if (signal) {\n        var _loadOptions;\n\n        loadOptions = { ...loadOptions,\n          fetch: { ...((_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch),\n            signal\n          }\n        };\n      }\n\n      let inResourceManager = resourceManager.contains(url);\n\n      if (!inResourceManager && !loadOptions) {\n        resourceManager.add({\n          resourceId: url,\n          data: load(url, loaders),\n          persistent: false\n        });\n        inResourceManager = true;\n      }\n\n      if (inResourceManager) {\n        return resourceManager.subscribe({\n          resourceId: url,\n          onChange: data => {\n            var _layer$internalState;\n\n            return (_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.reloadAsyncProp(propName, data);\n          },\n          consumerId: layer.id,\n          requestId: propName\n        });\n      }\n\n      return load(url, loaders, loadOptions);\n    },\n    compare: false\n  },\n  updateTriggers: {},\n  visible: true,\n  pickable: false,\n  opacity: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  operation: OPERATION.DRAW,\n  onHover: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  onClick: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  onDragStart: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  onDrag: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  onDragEnd: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n  coordinateOrigin: {\n    type: 'array',\n    value: [0, 0, 0],\n    compare: true\n  },\n  modelMatrix: {\n    type: 'array',\n    value: null,\n    compare: true,\n    optional: true\n  },\n  wrapLongitude: false,\n  positionFormat: 'XYZ',\n  colorFormat: 'RGBA',\n  parameters: {\n    type: 'object',\n    value: {},\n    optional: true,\n    compare: true\n  },\n  transitions: null,\n  extensions: [],\n  loaders: {\n    type: 'array',\n    value: [],\n    optional: true,\n    compare: true\n  },\n  getPolygonOffset: {\n    type: 'function',\n    value: ({\n      layerIndex\n    }) => [0, -layerIndex * 100],\n    compare: false\n  },\n  highlightedObjectIndex: null,\n  autoHighlight: false,\n  highlightColor: {\n    type: 'accessor',\n    value: [0, 0, 128, 128]\n  }\n};\nexport default class Layer extends Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"internalState\", null);\n\n    _defineProperty(this, \"lifecycle\", LIFECYCLE.NO_STATE);\n\n    _defineProperty(this, \"context\", void 0);\n\n    _defineProperty(this, \"state\", void 0);\n\n    _defineProperty(this, \"parent\", null);\n  }\n\n  get root() {\n    let layer = this;\n\n    while (layer.parent) {\n      layer = layer.parent;\n    }\n\n    return layer;\n  }\n\n  toString() {\n    const className = this.constructor.layerName || this.constructor.name;\n    return \"\".concat(className, \"({id: '\").concat(this.props.id, \"'})\");\n  }\n\n  project(xyz) {\n    assert(this.internalState);\n    const viewport = this.internalState.viewport || this.context.viewport;\n    const worldPosition = getWorldPosition(xyz, {\n      viewport,\n      modelMatrix: this.props.modelMatrix,\n      coordinateOrigin: this.props.coordinateOrigin,\n      coordinateSystem: this.props.coordinateSystem\n    });\n    const [x, y, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);\n    return xyz.length === 2 ? [x, y] : [x, y, z];\n  }\n\n  unproject(xy) {\n    assert(this.internalState);\n    const viewport = this.internalState.viewport || this.context.viewport;\n    return viewport.unproject(xy);\n  }\n\n  projectPosition(xyz, params) {\n    assert(this.internalState);\n    const viewport = this.internalState.viewport || this.context.viewport;\n    return projectPosition(xyz, {\n      viewport,\n      modelMatrix: this.props.modelMatrix,\n      coordinateOrigin: this.props.coordinateOrigin,\n      coordinateSystem: this.props.coordinateSystem,\n      ...params\n    });\n  }\n\n  get isComposite() {\n    return false;\n  }\n\n  setState(partialState) {\n    this.setChangeFlags({\n      stateChanged: true\n    });\n    Object.assign(this.state, partialState);\n    this.setNeedsRedraw();\n  }\n\n  setNeedsRedraw() {\n    if (this.internalState) {\n      this.internalState.needsRedraw = true;\n    }\n  }\n\n  setNeedsUpdate() {\n    if (this.internalState) {\n      this.context.layerManager.setNeedsUpdate(String(this));\n      this.internalState.needsUpdate = true;\n    }\n  }\n\n  get isLoaded() {\n    return this.internalState ? !this.internalState.isAsyncPropLoading() : false;\n  }\n\n  get wrapLongitude() {\n    return this.props.wrapLongitude;\n  }\n\n  isPickable() {\n    return this.props.pickable && this.props.visible;\n  }\n\n  getModels() {\n    return this.state && (this.state.models || this.state.model && [this.state.model]) || [];\n  }\n\n  setModuleParameters(moduleParameters) {\n    for (const model of this.getModels()) {\n      model.updateModuleSettings(moduleParameters);\n    }\n  }\n\n  getAttributeManager() {\n    return this.internalState && this.internalState.attributeManager;\n  }\n\n  getCurrentLayer() {\n    return this.internalState && this.internalState.layer;\n  }\n\n  getLoadOptions() {\n    return this.props.loadOptions;\n  }\n\n  use64bitPositions() {\n    const {\n      coordinateSystem\n    } = this.props;\n    return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  onHover(info, pickingEvent) {\n    if (this.props.onHover) {\n      return this.props.onHover(info, pickingEvent) || false;\n    }\n\n    return false;\n  }\n\n  onClick(info, pickingEvent) {\n    if (this.props.onClick) {\n      return this.props.onClick(info, pickingEvent) || false;\n    }\n\n    return false;\n  }\n\n  nullPickingColor() {\n    return [0, 0, 0];\n  }\n\n  encodePickingColor(i, target = []) {\n    target[0] = i + 1 & 255;\n    target[1] = i + 1 >> 8 & 255;\n    target[2] = i + 1 >> 8 >> 8 & 255;\n    return target;\n  }\n\n  decodePickingColor(color) {\n    assert(color instanceof Uint8Array);\n    const [i1, i2, i3] = color;\n    const index = i1 + i2 * 256 + i3 * 65536 - 1;\n    return index;\n  }\n\n  getNumInstances() {\n    if (Number.isFinite(this.props.numInstances)) {\n      return this.props.numInstances;\n    }\n\n    if (this.state && this.state.numInstances !== undefined) {\n      return this.state.numInstances;\n    }\n\n    return count(this.props.data);\n  }\n\n  getStartIndices() {\n    if (this.props.startIndices) {\n      return this.props.startIndices;\n    }\n\n    if (this.state && this.state.startIndices) {\n      return this.state.startIndices;\n    }\n\n    return null;\n  }\n\n  getBounds() {\n    var _ref;\n\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager) return null;\n    const {\n      positions,\n      instancePositions\n    } = attributeManager.attributes;\n    return (_ref = positions || instancePositions) === null || _ref === void 0 ? void 0 : _ref.getBounds();\n  }\n\n  getShaders(shaders) {\n    for (const extension of this.props.extensions) {\n      shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));\n    }\n\n    return shaders;\n  }\n\n  shouldUpdateState(params) {\n    return params.changeFlags.propsOrDataChanged;\n  }\n\n  updateState(params) {\n    const attributeManager = this.getAttributeManager();\n    const {\n      dataChanged\n    } = params.changeFlags;\n\n    if (dataChanged && attributeManager) {\n      if (Array.isArray(dataChanged)) {\n        for (const dataRange of dataChanged) {\n          attributeManager.invalidateAll(dataRange);\n        }\n      } else {\n        attributeManager.invalidateAll();\n      }\n    }\n\n    const {\n      props,\n      oldProps\n    } = params;\n    const neededPickingBuffer = Number.isInteger(oldProps.highlightedObjectIndex) || oldProps.pickable;\n    const needPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable;\n\n    if (neededPickingBuffer !== needPickingBuffer && attributeManager) {\n      const {\n        pickingColors,\n        instancePickingColors\n      } = attributeManager.attributes;\n      const pickingColorsAttribute = pickingColors || instancePickingColors;\n\n      if (pickingColorsAttribute) {\n        if (needPickingBuffer && pickingColorsAttribute.constant) {\n          pickingColorsAttribute.constant = false;\n          attributeManager.invalidate(pickingColorsAttribute.id);\n        }\n\n        if (!pickingColorsAttribute.value && !needPickingBuffer) {\n          pickingColorsAttribute.constant = true;\n          pickingColorsAttribute.value = [0, 0, 0];\n        }\n      }\n    }\n  }\n\n  finalizeState(context) {\n    for (const model of this.getModels()) {\n      model.delete();\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (attributeManager) {\n      attributeManager.finalize();\n    }\n\n    if (this.context) {\n      this.context.resourceManager.unsubscribe({\n        consumerId: this.id\n      });\n    }\n\n    if (this.internalState) {\n      this.internalState.uniformTransitions.clear();\n      this.internalState.finalize();\n    }\n  }\n\n  draw(opts) {\n    for (const model of this.getModels()) {\n      model.draw(opts);\n    }\n  }\n\n  getPickingInfo({\n    info,\n    mode,\n    sourceLayer\n  }) {\n    const {\n      index\n    } = info;\n\n    if (index >= 0) {\n      if (Array.isArray(this.props.data)) {\n        info.object = this.props.data[index];\n      }\n    }\n\n    return info;\n  }\n\n  raiseError(error, message) {\n    var _this$props$onError, _this$props;\n\n    if (message) {\n      error.message = \"\".concat(message, \": \").concat(error.message);\n    }\n\n    if (!((_this$props$onError = (_this$props = this.props).onError) !== null && _this$props$onError !== void 0 && _this$props$onError.call(_this$props, error))) {\n      var _this$context, _this$context$onError;\n\n      (_this$context = this.context) === null || _this$context === void 0 ? void 0 : (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 ? void 0 : _this$context$onError.call(_this$context, error, this);\n    }\n  }\n\n  getNeedsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    return this._getNeedsRedraw(opts);\n  }\n\n  needsUpdate() {\n    if (!this.internalState) {\n      return false;\n    }\n\n    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());\n  }\n\n  hasUniformTransition() {\n    var _this$internalState;\n\n    return ((_this$internalState = this.internalState) === null || _this$internalState === void 0 ? void 0 : _this$internalState.uniformTransitions.active) || false;\n  }\n\n  activateViewport(viewport) {\n    if (!this.internalState) {\n      return;\n    }\n\n    const oldViewport = this.internalState.viewport;\n    this.internalState.viewport = viewport;\n\n    if (!oldViewport || !areViewportsEqual({\n      oldViewport,\n      viewport\n    })) {\n      this.setChangeFlags({\n        viewportChanged: true\n      });\n\n      if (this.isComposite) {\n        if (this.needsUpdate()) {\n          this.setNeedsUpdate();\n        }\n      } else {\n        this._update();\n      }\n    }\n  }\n\n  invalidateAttribute(name = 'all') {\n    const attributeManager = this.getAttributeManager();\n\n    if (!attributeManager) {\n      return;\n    }\n\n    if (name === 'all') {\n      attributeManager.invalidateAll();\n    } else {\n      attributeManager.invalidate(name);\n    }\n  }\n\n  updateAttributes(changedAttributes) {\n    for (const model of this.getModels()) {\n      this._setModelAttributes(model, changedAttributes);\n    }\n  }\n\n  _updateAttributes() {\n    const attributeManager = this.getAttributeManager();\n\n    if (!attributeManager) {\n      return;\n    }\n\n    const props = this.props;\n    const numInstances = this.getNumInstances();\n    const startIndices = this.getStartIndices();\n    attributeManager.update({\n      data: props.data,\n      numInstances,\n      startIndices,\n      props,\n      transitions: props.transitions,\n      buffers: props.data.attributes,\n      context: this\n    });\n    const changedAttributes = attributeManager.getChangedAttributes({\n      clearChangedFlags: true\n    });\n    this.updateAttributes(changedAttributes);\n  }\n\n  _updateAttributeTransition() {\n    const attributeManager = this.getAttributeManager();\n\n    if (attributeManager) {\n      attributeManager.updateTransition();\n    }\n  }\n\n  _updateUniformTransition() {\n    const {\n      uniformTransitions\n    } = this.internalState;\n\n    if (uniformTransitions.active) {\n      const propsInTransition = uniformTransitions.update();\n      const props = Object.create(this.props);\n\n      for (const key in propsInTransition) {\n        Object.defineProperty(props, key, {\n          value: propsInTransition[key]\n        });\n      }\n\n      return props;\n    }\n\n    return this.props;\n  }\n\n  calculateInstancePickingColors(attribute, {\n    numInstances\n  }) {\n    if (attribute.constant) {\n      return;\n    }\n\n    const cacheSize = Math.floor(pickingColorCache.length / 3);\n    this.internalState.usesPickingColorCache = true;\n\n    if (cacheSize < numInstances) {\n      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {\n        log.warn('Layer has too many data objects. Picking might not be able to distinguish all objects.')();\n      }\n\n      pickingColorCache = typedArrayManager.allocate(pickingColorCache, numInstances, {\n        size: 3,\n        copy: true,\n        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)\n      });\n      const newCacheSize = Math.floor(pickingColorCache.length / 3);\n      const pickingColor = [];\n\n      for (let i = cacheSize; i < newCacheSize; i++) {\n        this.encodePickingColor(i, pickingColor);\n        pickingColorCache[i * 3 + 0] = pickingColor[0];\n        pickingColorCache[i * 3 + 1] = pickingColor[1];\n        pickingColorCache[i * 3 + 2] = pickingColor[2];\n      }\n    }\n\n    attribute.value = pickingColorCache.subarray(0, numInstances * 3);\n  }\n\n  _setModelAttributes(model, changedAttributes) {\n    const attributeManager = this.getAttributeManager();\n    const excludeAttributes = model.userData.excludeAttributes || {};\n    const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);\n    model.setAttributes(shaderAttributes);\n  }\n\n  disablePickingIndex(objectIndex) {\n    this._disablePickingIndex(objectIndex);\n  }\n\n  _disablePickingIndex(objectIndex) {\n    const {\n      pickingColors,\n      instancePickingColors\n    } = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n\n    if (!colors) {\n      return;\n    }\n\n    const start = colors.getVertexOffset(objectIndex);\n    const end = colors.getVertexOffset(objectIndex + 1);\n    colors.buffer.subData({\n      data: new Uint8Array(end - start),\n      offset: start\n    });\n  }\n\n  restorePickingColors() {\n    const {\n      pickingColors,\n      instancePickingColors\n    } = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n\n    if (!colors) {\n      return;\n    }\n\n    if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {\n      colors.value = pickingColorCache.subarray(0, colors.value.length);\n    }\n\n    colors.updateSubBuffer({\n      startOffset: 0\n    });\n  }\n\n  _initialize() {\n    assert(!this.internalState);\n    assert(Number.isFinite(this.props.coordinateSystem));\n    debug(TRACE_INITIALIZE, this);\n\n    const attributeManager = this._getAttributeManager();\n\n    if (attributeManager) {\n      attributeManager.addInstanced({\n        instancePickingColors: {\n          type: 5121,\n          size: 3,\n          noAlloc: true,\n          update: this.calculateInstancePickingColors\n        }\n      });\n    }\n\n    this.internalState = new LayerState({\n      attributeManager,\n      layer: this\n    });\n\n    this._clearChangeFlags();\n\n    this.state = {};\n    Object.defineProperty(this.state, 'attributeManager', {\n      get: () => {\n        log.deprecated('layer.state.attributeManager', 'layer.getAttributeManager()')();\n        return attributeManager;\n      }\n    });\n    this.internalState.layer = this;\n    this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);\n    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);\n    this.internalState.setAsyncProps(this.props);\n    this.initializeState(this.context);\n\n    for (const extension of this.props.extensions) {\n      extension.initializeState.call(this, this.context, extension);\n    }\n\n    this.setChangeFlags({\n      dataChanged: 'init',\n      propsChanged: 'init',\n      viewportChanged: true,\n      extensionsChanged: true\n    });\n\n    this._update();\n  }\n\n  _transferState(oldLayer) {\n    debug(TRACE_MATCHED, this, this === oldLayer);\n    const {\n      state,\n      internalState\n    } = oldLayer;\n\n    if (this === oldLayer) {\n      return;\n    }\n\n    this.internalState = internalState;\n    this.internalState.layer = this;\n    this.state = state;\n    this.internalState.setAsyncProps(this.props);\n\n    this._diffProps(this.props, this.internalState.getOldProps());\n  }\n\n  _update() {\n    const stateNeedsUpdate = this.needsUpdate();\n    debug(TRACE_UPDATE, this, stateNeedsUpdate);\n\n    if (!stateNeedsUpdate) {\n      return;\n    }\n\n    const currentProps = this.props;\n    const context = this.context;\n    const internalState = this.internalState;\n    const currentViewport = context.viewport;\n\n    const propsInTransition = this._updateUniformTransition();\n\n    internalState.propsInTransition = propsInTransition;\n    context.viewport = internalState.viewport || currentViewport;\n    this.props = propsInTransition;\n\n    try {\n      const updateParams = this._getUpdateParams();\n\n      const oldModels = this.getModels();\n\n      if (context.gl) {\n        this.updateState(updateParams);\n      } else {\n        try {\n          this.updateState(updateParams);\n        } catch (error) {}\n      }\n\n      for (const extension of this.props.extensions) {\n        extension.updateState.call(this, updateParams, extension);\n      }\n\n      const modelChanged = this.getModels()[0] !== oldModels[0];\n\n      this._postUpdate(updateParams, modelChanged);\n    } finally {\n      context.viewport = currentViewport;\n      this.props = currentProps;\n\n      this._clearChangeFlags();\n\n      internalState.needsUpdate = false;\n      internalState.resetOldProps();\n    }\n  }\n\n  _finalize() {\n    debug(TRACE_FINALIZE, this);\n    this.finalizeState(this.context);\n\n    for (const extension of this.props.extensions) {\n      extension.finalizeState.call(this, extension);\n    }\n  }\n\n  _drawLayer({\n    moduleParameters = null,\n    uniforms = {},\n    parameters = {}\n  }) {\n    this._updateAttributeTransition();\n\n    const currentProps = this.props;\n    const context = this.context;\n    this.props = this.internalState.propsInTransition || currentProps;\n    const opacity = this.props.opacity;\n    uniforms.opacity = Math.pow(opacity, 1 / 2.2);\n\n    try {\n      if (moduleParameters) {\n        this.setModuleParameters(moduleParameters);\n      }\n\n      const {\n        getPolygonOffset\n      } = this.props;\n      const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];\n      setParameters(context.gl, {\n        polygonOffset: offsets\n      });\n      withParameters(context.gl, parameters, () => {\n        const opts = {\n          moduleParameters,\n          uniforms,\n          parameters,\n          context\n        };\n\n        for (const extension of this.props.extensions) {\n          extension.draw.call(this, opts, extension);\n        }\n\n        this.draw(opts);\n      });\n    } finally {\n      this.props = currentProps;\n    }\n  }\n\n  getChangeFlags() {\n    var _this$internalState2;\n\n    return (_this$internalState2 = this.internalState) === null || _this$internalState2 === void 0 ? void 0 : _this$internalState2.changeFlags;\n  }\n\n  setChangeFlags(flags) {\n    if (!this.internalState) {\n      return;\n    }\n\n    const {\n      changeFlags\n    } = this.internalState;\n\n    for (const key in flags) {\n      if (flags[key]) {\n        let flagChanged = false;\n\n        switch (key) {\n          case 'dataChanged':\n            const dataChangedReason = flags[key];\n            const prevDataChangedReason = changeFlags[key];\n\n            if (dataChangedReason && Array.isArray(prevDataChangedReason)) {\n              changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;\n              flagChanged = true;\n            }\n\n          default:\n            if (!changeFlags[key]) {\n              changeFlags[key] = flags[key];\n              flagChanged = true;\n            }\n\n        }\n\n        if (flagChanged) {\n          debug(TRACE_CHANGE_FLAG, this, key, flags);\n        }\n      }\n    }\n\n    const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);\n    changeFlags.propsOrDataChanged = propsOrDataChanged;\n    changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;\n  }\n\n  _clearChangeFlags() {\n    this.internalState.changeFlags = {\n      dataChanged: false,\n      propsChanged: false,\n      updateTriggersChanged: false,\n      viewportChanged: false,\n      stateChanged: false,\n      extensionsChanged: false,\n      propsOrDataChanged: false,\n      somethingChanged: false\n    };\n  }\n\n  _diffProps(newProps, oldProps) {\n    const changeFlags = diffProps(newProps, oldProps);\n\n    if (changeFlags.updateTriggersChanged) {\n      for (const key in changeFlags.updateTriggersChanged) {\n        if (changeFlags.updateTriggersChanged[key]) {\n          this.invalidateAttribute(key);\n        }\n      }\n    }\n\n    if (changeFlags.transitionsChanged) {\n      for (const key in changeFlags.transitionsChanged) {\n        var _newProps$transitions;\n\n        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], (_newProps$transitions = newProps.transitions) === null || _newProps$transitions === void 0 ? void 0 : _newProps$transitions[key]);\n      }\n    }\n\n    return this.setChangeFlags(changeFlags);\n  }\n\n  validateProps() {\n    validateProps(this.props);\n  }\n\n  updateAutoHighlight(info) {\n    if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {\n      this._updateAutoHighlight(info);\n    }\n  }\n\n  _updateAutoHighlight(info) {\n    const pickingModuleParameters = {\n      pickingSelectedColor: info.picked ? info.color : null\n    };\n    const {\n      highlightColor\n    } = this.props;\n\n    if (info.picked && typeof highlightColor === 'function') {\n      pickingModuleParameters.pickingHighlightColor = highlightColor(info);\n    }\n\n    this.setModuleParameters(pickingModuleParameters);\n    this.setNeedsRedraw();\n  }\n\n  _getAttributeManager() {\n    const context = this.context;\n    return new AttributeManager(context.gl, {\n      id: this.props.id,\n      stats: context.stats,\n      timeline: context.timeline\n    });\n  }\n\n  _postUpdate(updateParams, forceUpdate) {\n    const {\n      props,\n      oldProps\n    } = updateParams;\n    this.setNeedsRedraw();\n\n    this._updateAttributes();\n\n    const {\n      model\n    } = this.state;\n    model === null || model === void 0 ? void 0 : model.setInstanceCount(this.getNumInstances());\n    const {\n      autoHighlight,\n      highlightedObjectIndex,\n      highlightColor\n    } = props;\n\n    if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {\n      const parameters = {};\n\n      if (!autoHighlight) {\n        parameters.pickingSelectedColor = null;\n      }\n\n      if (Array.isArray(highlightColor)) {\n        parameters.pickingHighlightColor = highlightColor;\n      }\n\n      if (Number.isInteger(highlightedObjectIndex)) {\n        parameters.pickingSelectedColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;\n      }\n\n      this.setModuleParameters(parameters);\n    }\n  }\n\n  _getUpdateParams() {\n    return {\n      props: this.props,\n      oldProps: this.internalState.getOldProps(),\n      context: this.context,\n      changeFlags: this.internalState.changeFlags\n    };\n  }\n\n  _getNeedsRedraw(opts) {\n    if (!this.internalState) {\n      return false;\n    }\n\n    let redraw = false;\n    redraw = redraw || this.internalState.needsRedraw && this.id;\n    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;\n    const attributeManager = this.getAttributeManager();\n    const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;\n    redraw = redraw || attributeManagerNeedsRedraw;\n    return redraw;\n  }\n\n  _onAsyncPropUpdated() {\n    this._diffProps(this.props, this.internalState.getOldProps());\n\n    this.setNeedsUpdate();\n  }\n\n}\n\n_defineProperty(Layer, \"defaultProps\", defaultProps);\n\n_defineProperty(Layer, \"layerName\", 'Layer');","map":{"version":3,"sources":["../../../src/lib/layer.ts"],"names":["TRACE_CHANGE_FLAG","TRACE_INITIALIZE","TRACE_UPDATE","TRACE_FINALIZE","TRACE_MATCHED","MAX_PICKING_COLOR_CACHE_SIZE","EMPTY_ARRAY","Object","areViewportsEqual","memoize","viewport","oldViewport","pickingColorCache","defaultProps","data","type","value","async","dataComparator","compare","optional","_dataDiff","dataTransform","onDataLoad","onError","fetch","signal","resourceManager","layer","loadOptions","loaders","inResourceManager","resourceId","load","persistent","onChange","consumerId","requestId","propName","updateTriggers","visible","pickable","opacity","min","max","operation","OPERATION","onHover","onClick","onDragStart","onDrag","onDragEnd","coordinateSystem","COORDINATE_SYSTEM","coordinateOrigin","modelMatrix","wrapLongitude","positionFormat","colorFormat","parameters","transitions","extensions","getPolygonOffset","layerIndex","highlightedObjectIndex","autoHighlight","highlightColor","Layer","LIFECYCLE","root","toString","className","project","assert","worldPosition","getWorldPosition","worldToPixels","xyz","unproject","projectPosition","params","isComposite","setState","stateChanged","setNeedsRedraw","setNeedsUpdate","String","isLoaded","isPickable","getModels","setModuleParameters","model","getAttributeManager","getCurrentLayer","getLoadOptions","use64bitPositions","nullPickingColor","encodePickingColor","target","i","decodePickingColor","color","index","i1","i2","i3","getNumInstances","Number","count","getStartIndices","getBounds","attributeManager","instancePositions","positions","getShaders","shaders","mergeShaders","extension","shouldUpdateState","updateState","dataChanged","Array","oldProps","neededPickingBuffer","needPickingBuffer","props","instancePickingColors","pickingColorsAttribute","pickingColors","finalizeState","id","draw","getPickingInfo","sourceLayer","info","raiseError","error","getNeedsRedraw","opts","clearRedrawFlags","needsUpdate","hasUniformTransition","activateViewport","viewportChanged","invalidateAttribute","name","updateAttributes","_updateAttributes","numInstances","startIndices","buffers","context","changedAttributes","clearChangedFlags","_updateAttributeTransition","_updateUniformTransition","uniformTransitions","propsInTransition","calculateInstancePickingColors","attribute","cacheSize","Math","log","size","copy","maxCount","newCacheSize","pickingColor","_setModelAttributes","excludeAttributes","shaderAttributes","disablePickingIndex","_disablePickingIndex","colors","start","end","objectIndex","offset","restorePickingColors","startOffset","_initialize","debug","noAlloc","update","get","propsChanged","extensionsChanged","_transferState","internalState","_update","stateNeedsUpdate","currentProps","currentViewport","updateParams","oldModels","modelChanged","_finalize","_drawLayer","moduleParameters","uniforms","offsets","setParameters","polygonOffset","withParameters","getChangeFlags","setChangeFlags","changeFlags","flags","flagChanged","dataChangedReason","prevDataChangedReason","propsOrDataChanged","Boolean","_clearChangeFlags","updateTriggersChanged","somethingChanged","_diffProps","diffProps","newProps","validateProps","updateAutoHighlight","_updateAutoHighlight","pickingModuleParameters","pickingSelectedColor","_getAttributeManager","stats","timeline","_postUpdate","forceUpdate","_getUpdateParams","_getNeedsRedraw","redraw","attributeManagerNeedsRedraw","_onAsyncPropUpdated"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable react/no-direct-mutation-state */\nimport {COORDINATE_SYSTEM, OPERATION} from './constants';\nimport AttributeManager from './attribute/attribute-manager';\nimport UniformTransitionManager from './uniform-transition-manager';\nimport {diffProps, validateProps} from '../lifecycle/props';\nimport {LIFECYCLE, Lifecycle} from '../lifecycle/constants';\nimport {count} from '../utils/count';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport GL from '@luma.gl/constants';\nimport {withParameters, setParameters} from '@luma.gl/core';\nimport assert from '../utils/assert';\nimport memoize from '../utils/memoize';\nimport {mergeShaders} from '../utils/shader';\nimport {projectPosition, getWorldPosition} from '../shaderlib/project/project-functions';\nimport typedArrayManager from '../utils/typed-array-manager';\n\nimport Component from '../lifecycle/component';\nimport LayerState, {ChangeFlags} from './layer-state';\n\nimport {worldToPixels} from '@math.gl/web-mercator';\n\nimport {load} from '@loaders.gl/core';\n\nimport type {Loader} from '@loaders.gl/loader-utils';\nimport type {CoordinateSystem} from './constants';\nimport type Attribute from './attribute/attribute';\nimport type {Model} from '@luma.gl/engine';\nimport type {PickingInfo, GetPickingInfoParams} from './picking/pick-info';\nimport type Viewport from '../viewports/viewport';\nimport type {NumericArray} from '../types/types';\nimport type {DefaultProps} from '../lifecycle/prop-types';\nimport type {LayerProps} from '../types/layer-props';\nimport type {LayerContext} from './layer-manager';\n\nconst TRACE_CHANGE_FLAG = 'layer.changeFlag';\nconst TRACE_INITIALIZE = 'layer.initialize';\nconst TRACE_UPDATE = 'layer.update';\nconst TRACE_FINALIZE = 'layer.finalize';\nconst TRACE_MATCHED = 'layer.matched';\n\nconst MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;\n\nconst EMPTY_ARRAY = Object.freeze([]);\n\n// Only compare the same two viewports once\nconst areViewportsEqual = memoize(\n  ({oldViewport, viewport}: {oldViewport: Viewport; viewport: Viewport}): boolean => {\n    return oldViewport.equals(viewport);\n  }\n);\n\nlet pickingColorCache = new Uint8ClampedArray(0);\n\nconst defaultProps: DefaultProps<LayerProps> = {\n  // data: Special handling for null, see below\n  data: {type: 'data', value: EMPTY_ARRAY, async: true},\n  dataComparator: {type: 'function', value: null, compare: false, optional: true},\n  _dataDiff: {\n    type: 'function',\n    // @ts-ignore __diff is not defined on data\n    value: data => data && data.__diff,\n    compare: false,\n    optional: true\n  },\n  dataTransform: {type: 'function', value: null, compare: false, optional: true},\n  onDataLoad: {type: 'function', value: null, compare: false, optional: true},\n  onError: {type: 'function', value: null, compare: false, optional: true},\n  fetch: {\n    type: 'function',\n    value: <LayerT extends Layer>(\n      url: string,\n      {\n        propName,\n        layer,\n        loaders,\n        loadOptions,\n        signal\n      }: {\n        propName: string;\n        layer: LayerT;\n        loaders?: Loader[];\n        loadOptions?: any;\n        signal?: AbortSignal;\n      }\n    ) => {\n      const {resourceManager} = layer.context;\n      loadOptions = loadOptions || layer.getLoadOptions();\n      loaders = loaders || layer.props.loaders;\n      if (signal) {\n        loadOptions = {\n          ...loadOptions,\n          fetch: {\n            ...loadOptions?.fetch,\n            signal\n          }\n        };\n      }\n\n      let inResourceManager = resourceManager.contains(url);\n\n      if (!inResourceManager && !loadOptions) {\n        // If there is no layer-specific load options, then attempt to cache this resource in the data manager\n        resourceManager.add({resourceId: url, data: load(url, loaders), persistent: false});\n        inResourceManager = true;\n      }\n      if (inResourceManager) {\n        return resourceManager.subscribe({\n          resourceId: url,\n          onChange: data => layer.internalState?.reloadAsyncProp(propName, data),\n          consumerId: layer.id,\n          requestId: propName\n        });\n      }\n\n      return load(url, loaders, loadOptions);\n    },\n    compare: false\n  },\n  updateTriggers: {}, // Update triggers: a core change detection mechanism in deck.gl\n\n  visible: true,\n  pickable: false,\n  opacity: {type: 'number', min: 0, max: 1, value: 1},\n  operation: OPERATION.DRAW,\n\n  onHover: {type: 'function', value: null, compare: false, optional: true},\n  onClick: {type: 'function', value: null, compare: false, optional: true},\n  onDragStart: {type: 'function', value: null, compare: false, optional: true},\n  onDrag: {type: 'function', value: null, compare: false, optional: true},\n  onDragEnd: {type: 'function', value: null, compare: false, optional: true},\n\n  coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n  coordinateOrigin: {type: 'array', value: [0, 0, 0], compare: true},\n  modelMatrix: {type: 'array', value: null, compare: true, optional: true},\n  wrapLongitude: false,\n  positionFormat: 'XYZ',\n  colorFormat: 'RGBA',\n\n  parameters: {type: 'object', value: {}, optional: true, compare: true},\n  transitions: null,\n  extensions: [],\n  loaders: {type: 'array', value: [], optional: true, compare: true},\n\n  // Offset depth based on layer index to avoid z-fighting.\n  // Negative values pull layer towards the camera\n  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm\n  getPolygonOffset: {\n    type: 'function',\n    value: ({layerIndex}) => [0, -layerIndex * 100],\n    compare: false\n  },\n\n  // Selection/Highlighting\n  highlightedObjectIndex: null,\n  autoHighlight: false,\n  highlightColor: {type: 'accessor', value: [0, 0, 128, 128]}\n};\n\nexport type UpdateParameters<LayerT extends Layer> = {\n  props: LayerT['props'];\n  oldProps: LayerT['props'];\n  context: LayerContext;\n  changeFlags: ChangeFlags;\n};\n\nexport default abstract class Layer<PropsT = {}> extends Component<PropsT & Required<LayerProps>> {\n  static defaultProps = defaultProps;\n  static layerName: string = 'Layer';\n\n  internalState: LayerState<this> | null = null;\n  lifecycle: Lifecycle = LIFECYCLE.NO_STATE; // Helps track and debug the life cycle of the layers\n\n  // context and state can technically be null before a layer is initialized/matched.\n  // However, they are most extensively accessed in a layer's lifecycle methods, where they are always defined.\n  // Checking for null state constantly in layer implementation is unnecessarily verbose.\n  context!: LayerContext; // Will reference layer manager's context, contains state shared by layers\n  state!: Record<string, any>; // Will be set to the shared layer state object during layer matching\n\n  parent: Layer | null = null;\n\n  get root(): Layer {\n    // eslint-disable-next-line\n    let layer: Layer = this;\n    while (layer.parent) {\n      layer = layer.parent;\n    }\n    return layer;\n  }\n\n  toString(): string {\n    const className = (this.constructor as typeof Layer).layerName || this.constructor.name;\n    return `${className}({id: '${this.props.id}'})`;\n  }\n\n  // Public API for users\n\n  /** Projects a point with current view state from the current layer's coordinate system to screen */\n  project(xyz: number[]): number[] {\n    assert(this.internalState);\n    const viewport = this.internalState.viewport || this.context.viewport;\n\n    const worldPosition = getWorldPosition(xyz, {\n      viewport,\n      modelMatrix: this.props.modelMatrix,\n      coordinateOrigin: this.props.coordinateOrigin,\n      coordinateSystem: this.props.coordinateSystem\n    });\n    const [x, y, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);\n    return xyz.length === 2 ? [x, y] : [x, y, z];\n  }\n\n  /** Unprojects a screen pixel to the current view's default coordinate system\n      Note: this does not reverse `project`. */\n  unproject(xy: number[]): number[] {\n    assert(this.internalState);\n    const viewport = this.internalState.viewport || this.context.viewport;\n    return viewport.unproject(xy);\n  }\n\n  /** Projects a point with current view state from the current layer's coordinate system to the world space */\n  projectPosition(\n    xyz: number[],\n    params?: {\n      /** The viewport to use */\n      viewport?: Viewport;\n      /** The coordinate system that the supplied position is in. Default to the same as `coordinateSystem`. */\n      fromCoordinateSystem?: CoordinateSystem;\n      /** The coordinate origin that the supplied position is in. Default to the same as `coordinateOrigin`. */\n      fromCoordinateOrigin?: [number, number, number];\n    }\n  ): [number, number, number] {\n    assert(this.internalState);\n    const viewport = this.internalState.viewport || this.context.viewport;\n\n    return projectPosition(xyz, {\n      viewport,\n      modelMatrix: this.props.modelMatrix,\n      coordinateOrigin: this.props.coordinateOrigin,\n      coordinateSystem: this.props.coordinateSystem,\n      ...params\n    });\n  }\n\n  // Public API for custom layer implementation\n\n  /** `true` if this layer renders other layers */\n  get isComposite(): boolean {\n    return false;\n  }\n\n  /** Updates selected state members and marks the layer for redraw */\n  setState(partialState: any): void {\n    this.setChangeFlags({stateChanged: true});\n    Object.assign(this.state, partialState);\n    this.setNeedsRedraw();\n  }\n\n  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */\n  setNeedsRedraw(): void {\n    if (this.internalState) {\n      this.internalState.needsRedraw = true;\n    }\n  }\n\n  /** Mark this layer as needs a deep update */\n  setNeedsUpdate() {\n    if (this.internalState) {\n      this.context.layerManager.setNeedsUpdate(String(this));\n      this.internalState.needsUpdate = true;\n    }\n  }\n\n  /** Returns true if all async resources are loaded */\n  get isLoaded(): boolean {\n    return this.internalState ? !this.internalState.isAsyncPropLoading() : false;\n  }\n\n  /** Returns true if using shader-based WGS84 longitude wrapping */\n  get wrapLongitude(): boolean {\n    return this.props.wrapLongitude;\n  }\n\n  /** Returns true if the layer is visible in the picking pass */\n  isPickable(): boolean {\n    return this.props.pickable && this.props.visible;\n  }\n\n  /** Returns an array of models used by this layer, can be overriden by layer subclass */\n  getModels(): Model[] {\n    return (this.state && (this.state.models || (this.state.model && [this.state.model]))) || [];\n  }\n\n  /** Update shader module parameters */\n  setModuleParameters(moduleParameters: any): void {\n    for (const model of this.getModels()) {\n      model.updateModuleSettings(moduleParameters);\n    }\n  }\n\n  /** Returns the attribute manager of this layer */\n  getAttributeManager(): AttributeManager | null {\n    return this.internalState && this.internalState.attributeManager;\n  }\n\n  /** Returns the most recent layer that matched to this state\n    (When reacting to an async event, this layer may no longer be the latest) */\n  getCurrentLayer(): Layer<PropsT> | null {\n    return this.internalState && this.internalState.layer;\n  }\n\n  /** Returns the default parse options for async props */\n  getLoadOptions(): any {\n    return this.props.loadOptions;\n  }\n\n  use64bitPositions(): boolean {\n    const {coordinateSystem} = this.props;\n    return (\n      coordinateSystem === COORDINATE_SYSTEM.DEFAULT ||\n      coordinateSystem === COORDINATE_SYSTEM.LNGLAT ||\n      coordinateSystem === COORDINATE_SYSTEM.CARTESIAN\n    );\n  }\n\n  // Event handling\n  onHover(info: PickingInfo, pickingEvent): boolean {\n    if (this.props.onHover) {\n      return this.props.onHover(info, pickingEvent) || false;\n    }\n    return false;\n  }\n\n  onClick(info: PickingInfo, pickingEvent): boolean {\n    if (this.props.onClick) {\n      return this.props.onClick(info, pickingEvent) || false;\n    }\n    return false;\n  }\n\n  // Returns the picking color that doesn't match any subfeature\n  // Use if some graphics do not belong to any pickable subfeature\n  // @return {Array} - a black color\n  nullPickingColor() {\n    return [0, 0, 0];\n  }\n\n  // Returns the picking color that doesn't match any subfeature\n  // Use if some graphics do not belong to any pickable subfeature\n  encodePickingColor(i, target: number[] = []): number[] {\n    target[0] = (i + 1) & 255;\n    target[1] = ((i + 1) >> 8) & 255;\n    target[2] = (((i + 1) >> 8) >> 8) & 255;\n    return target;\n  }\n\n  // Returns the index corresponding to a picking color that doesn't match any subfeature\n  // @param {Uint8Array} color - color array to be decoded\n  // @return {Array} - the decoded picking color\n  decodePickingColor(color) {\n    assert(color instanceof Uint8Array);\n    const [i1, i2, i3] = color;\n    // 1 was added to seperate from no selection\n    const index = i1 + i2 * 256 + i3 * 65536 - 1;\n    return index;\n  }\n\n  /** Deduces number of instances. Intention is to support:\n    - Explicit setting of numInstances\n    - Auto-deduction for ES6 containers that define a size member\n    - Auto-deduction for Classic Arrays via the built-in length attribute\n    - Auto-deduction via arrays */\n  getNumInstances(): number {\n    // First Check if app has provided an explicit value\n    if (Number.isFinite(this.props.numInstances)) {\n      return this.props.numInstances as number;\n    }\n\n    // Second check if the layer has set its own value\n    if (this.state && this.state.numInstances !== undefined) {\n      return this.state.numInstances;\n    }\n\n    // Use container library to get a count for any ES6 container or object\n    return count(this.props.data);\n  }\n\n  /** Buffer layout describes how many attribute values are packed for each data object\n      The default (null) is one value each object.\n      Some data formats (e.g. paths, polygons) have various length. Their buffer layout\n      is in the form of [L0, L1, L2, ...] */\n  getStartIndices(): NumericArray | null {\n    // First Check if startIndices is provided as an explicit value\n    if (this.props.startIndices) {\n      return this.props.startIndices;\n    }\n\n    // Second check if the layer has set its own value\n    if (this.state && this.state.startIndices) {\n      return this.state.startIndices;\n    }\n\n    return null;\n  }\n\n  // Default implementation\n  // Sublayers chould override this method to provide an accurate calculation of the bounds\n  getBounds(): [number[], number[]] | null {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager) return null;\n    const {positions, instancePositions} = attributeManager.attributes;\n    return (positions || instancePositions)?.getBounds();\n  }\n\n  // / LIFECYCLE METHODS - overridden by the layer subclasses\n\n  /** Called once to set up the initial state. Layers can create WebGL resources here. */\n  abstract initializeState(context: LayerContext): void;\n\n  getShaders(shaders: any): any {\n    for (const extension of this.props.extensions) {\n      shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));\n    }\n    return shaders;\n  }\n\n  /** Controls if updateState should be called. By default returns true if any prop has changed */\n  shouldUpdateState(params: UpdateParameters<Layer<PropsT>>): boolean {\n    return params.changeFlags.propsOrDataChanged;\n  }\n\n  /* eslint-disable-next-line complexity */\n  /** Default implementation, all attributes will be invalidated and updated when data changes */\n  updateState(params: UpdateParameters<Layer<PropsT>>): void {\n    const attributeManager = this.getAttributeManager();\n    const {dataChanged} = params.changeFlags;\n    if (dataChanged && attributeManager) {\n      if (Array.isArray(dataChanged)) {\n        // is partial update\n        for (const dataRange of dataChanged) {\n          attributeManager.invalidateAll(dataRange);\n        }\n      } else {\n        attributeManager.invalidateAll();\n      }\n    }\n\n    const {props, oldProps} = params;\n    const neededPickingBuffer =\n      Number.isInteger(oldProps.highlightedObjectIndex) || oldProps.pickable;\n    const needPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable;\n    if (neededPickingBuffer !== needPickingBuffer && attributeManager) {\n      const {pickingColors, instancePickingColors} = attributeManager.attributes;\n      const pickingColorsAttribute = pickingColors || instancePickingColors;\n      if (pickingColorsAttribute) {\n        if (needPickingBuffer && pickingColorsAttribute.constant) {\n          pickingColorsAttribute.constant = false;\n          attributeManager.invalidate(pickingColorsAttribute.id);\n        }\n        if (!pickingColorsAttribute.value && !needPickingBuffer) {\n          pickingColorsAttribute.constant = true;\n          pickingColorsAttribute.value = [0, 0, 0];\n        }\n      }\n    }\n  }\n\n  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */\n  finalizeState(context: LayerContext): void {\n    for (const model of this.getModels()) {\n      model.delete();\n    }\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.finalize();\n    }\n    if (this.context) {\n      this.context.resourceManager.unsubscribe({consumerId: this.id});\n    }\n    if (this.internalState) {\n      this.internalState.uniformTransitions.clear();\n      this.internalState.finalize();\n    }\n  }\n\n  // If state has a model, draw it with supplied uniforms\n  draw(opts) {\n    for (const model of this.getModels()) {\n      model.draw(opts);\n    }\n  }\n\n  // called to populate the info object that is passed to the event handler\n  // @return null to cancel event\n  getPickingInfo({info, mode, sourceLayer}: GetPickingInfoParams) {\n    const {index} = info;\n\n    if (index >= 0) {\n      // If props.data is an indexable array, get the object\n      if (Array.isArray(this.props.data)) {\n        info.object = this.props.data[index];\n      }\n    }\n\n    return info;\n  }\n\n  // END LIFECYCLE METHODS\n\n  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker\n\n  /** (Internal) Propagate an error event through the system */\n  raiseError(error: Error, message: string): void {\n    if (message) {\n      error.message = `${message}: ${error.message}`;\n    }\n    if (!this.props.onError?.(error)) {\n      this.context?.onError?.(error, this);\n    }\n  }\n\n  /** (Internal) Checks if this layer needs redraw */\n  getNeedsRedraw(\n    opts: {\n      /** Reset redraw flags to false after the check */\n      clearRedrawFlags: boolean;\n    } = {clearRedrawFlags: false}\n  ): string | false {\n    return this._getNeedsRedraw(opts);\n  }\n\n  /** (Internal) Checks if this layer needs a deep update */\n  needsUpdate(): boolean {\n    if (!this.internalState) {\n      return false;\n    }\n\n    // Call subclass lifecycle method\n    return (\n      this.internalState.needsUpdate ||\n      this.hasUniformTransition() ||\n      this.shouldUpdateState(this._getUpdateParams())\n    );\n    // End lifecycle method\n  }\n\n  /** Checks if this layer has ongoing uniform transition */\n  hasUniformTransition(): boolean {\n    return this.internalState?.uniformTransitions.active || false;\n  }\n\n  /** Called when this layer is rendered into the given viewport */\n  activateViewport(viewport: Viewport): void {\n    if (!this.internalState) {\n      return;\n    }\n\n    const oldViewport = this.internalState.viewport;\n    this.internalState.viewport = viewport;\n\n    if (!oldViewport || !areViewportsEqual({oldViewport, viewport})) {\n      this.setChangeFlags({viewportChanged: true});\n\n      if (this.isComposite) {\n        if (this.needsUpdate()) {\n          // Composite layers may add/remove sublayers on viewport change\n          // Because we cannot change the layers list during a draw cycle, we don't want to update sublayers right away\n          // This will not call update immediately, but mark the layerManager as needs update on the next frame\n          this.setNeedsUpdate();\n        }\n      } else {\n        this._update();\n      }\n    }\n  }\n\n  /** Default implementation of attribute invalidation, can be redefined */\n  protected invalidateAttribute(name = 'all'): void {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager) {\n      return;\n    }\n\n    if (name === 'all') {\n      attributeManager.invalidateAll();\n    } else {\n      attributeManager.invalidate(name);\n    }\n  }\n\n  /** Send updated attributes to the WebGL model */\n  protected updateAttributes(changedAttributes: {[id: string]: Attribute}) {\n    for (const model of this.getModels()) {\n      this._setModelAttributes(model, changedAttributes);\n    }\n  }\n\n  /** Recalculate any attributes if needed */\n  protected _updateAttributes(): void {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager) {\n      return;\n    }\n    const props = this.props;\n\n    // Figure out data length\n    const numInstances = this.getNumInstances();\n    const startIndices = this.getStartIndices();\n\n    attributeManager.update({\n      data: props.data,\n      numInstances,\n      startIndices,\n      props,\n      transitions: props.transitions,\n      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types\n      buffers: props.data.attributes,\n      context: this\n    });\n\n    const changedAttributes = attributeManager.getChangedAttributes({clearChangedFlags: true});\n    this.updateAttributes(changedAttributes);\n  }\n\n  /** Update attribute transitions. This is called in drawLayer, no model updates required. */\n  private _updateAttributeTransition() {\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.updateTransition();\n    }\n  }\n\n  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */\n  private _updateUniformTransition(): Layer<PropsT>['props'] {\n    // @ts-ignore (TS2339) internalState is alwasy defined when this method is called\n    const {uniformTransitions} = this.internalState;\n    if (uniformTransitions.active) {\n      // clone props\n      const propsInTransition = uniformTransitions.update();\n      const props = Object.create(this.props);\n      for (const key in propsInTransition) {\n        Object.defineProperty(props, key, {value: propsInTransition[key]});\n      }\n      return props;\n    }\n    return this.props;\n  }\n\n  /** Updater for the automatically populated instancePickingColors attribute */\n  protected calculateInstancePickingColors(\n    attribute: Attribute,\n    {numInstances}: {numInstances: number}\n  ) {\n    if (attribute.constant) {\n      return;\n    }\n\n    // calculateInstancePickingColors always generates the same sequence.\n    // pickingColorCache saves the largest generated sequence for reuse\n    const cacheSize = Math.floor(pickingColorCache.length / 3);\n\n    // Record when using the picking buffer cache, so that layers can always point at the most recently allocated cache\n    // @ts-ignore (TS2531) internalState is always defined when this method is called\n    this.internalState.usesPickingColorCache = true;\n\n    if (cacheSize < numInstances) {\n      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {\n        log.warn(\n          'Layer has too many data objects. Picking might not be able to distinguish all objects.'\n        )();\n      }\n\n      pickingColorCache = typedArrayManager.allocate(pickingColorCache, numInstances, {\n        size: 3,\n        copy: true,\n        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)\n      });\n\n      // If the attribute is larger than the cache, resize the cache and populate the missing chunk\n      const newCacheSize = Math.floor(pickingColorCache.length / 3);\n      const pickingColor = [];\n      for (let i = cacheSize; i < newCacheSize; i++) {\n        this.encodePickingColor(i, pickingColor);\n        pickingColorCache[i * 3 + 0] = pickingColor[0];\n        pickingColorCache[i * 3 + 1] = pickingColor[1];\n        pickingColorCache[i * 3 + 2] = pickingColor[2];\n      }\n    }\n\n    attribute.value = pickingColorCache.subarray(0, numInstances * 3);\n  }\n\n  /** Apply changed attributes to  */\n  protected _setModelAttributes(\n    model: Model,\n    changedAttributes: {\n      [id: string]: Attribute;\n    }\n  ) {\n    const attributeManager = this.getAttributeManager();\n    // @ts-ignore luma.gl type issue\n    const excludeAttributes = model.userData.excludeAttributes || {};\n    // @ts-ignore (TS2531) this method is only called internally with attributeManager defined\n    const shaderAttributes = attributeManager.getShaderAttributes(\n      changedAttributes,\n      excludeAttributes\n    );\n\n    model.setAttributes(shaderAttributes);\n  }\n\n  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.\n     This method may be overriden by layer implementations */\n  disablePickingIndex(objectIndex: number): void {\n    this._disablePickingIndex(objectIndex);\n  }\n\n  // TODO - simplify subclassing interface\n  protected _disablePickingIndex(objectIndex: number): void {\n    // @ts-ignore (TS2531) this method is only called internally with attributeManager defined\n    const {pickingColors, instancePickingColors} = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n    if (!colors) {\n      return;\n    }\n\n    const start = colors.getVertexOffset(objectIndex);\n    const end = colors.getVertexOffset(objectIndex + 1);\n\n    // Fill the sub buffer with 0s\n    colors.buffer.subData({\n      data: new Uint8Array(end - start),\n      offset: start // 1 byte per element\n    });\n  }\n\n  /** (Internal) Re-enable all picking indices after multi-depth picking */\n  restorePickingColors(): void {\n    // @ts-ignore (TS2531) this method is only called internally with attributeManager defined\n    const {pickingColors, instancePickingColors} = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n    if (!colors) {\n      return;\n    }\n    // The picking color cache may have been freed and then reallocated. This ensures we read from the currently allocated cache.\n    if (\n      // @ts-ignore (TS2531) this method is only called internally with internalState defined\n      this.internalState.usesPickingColorCache &&\n      (colors.value as Uint8ClampedArray).buffer !== pickingColorCache.buffer\n    ) {\n      colors.value = pickingColorCache.subarray(0, (colors.value as Uint8ClampedArray).length);\n    }\n    colors.updateSubBuffer({startOffset: 0});\n  }\n\n  /* eslint-disable max-statements */\n  /* (Internal) Called by layer manager when a new layer is found */\n  _initialize() {\n    assert(!this.internalState); // finalized layer cannot be reused\n    assert(Number.isFinite(this.props.coordinateSystem)); // invalid coordinateSystem\n\n    debug(TRACE_INITIALIZE, this);\n\n    const attributeManager = this._getAttributeManager();\n\n    if (attributeManager) {\n      // All instanced layers get instancePickingColors attribute by default\n      // Their shaders can use it to render a picking scene\n      // TODO - this slightly slows down non instanced layers\n      attributeManager.addInstanced({\n        instancePickingColors: {\n          type: GL.UNSIGNED_BYTE,\n          size: 3,\n          noAlloc: true,\n          // Updaters are always called with `this` pointing to the layer\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          update: this.calculateInstancePickingColors\n        }\n      });\n    }\n\n    this.internalState = new LayerState<this>({\n      attributeManager,\n      layer: this\n    });\n    this._clearChangeFlags(); // populate this.internalState.changeFlags\n\n    this.state = {};\n    // for backwards compatibility with older layers\n    // TODO - remove in next release\n    /* eslint-disable accessor-pairs */\n    Object.defineProperty(this.state, 'attributeManager', {\n      get: () => {\n        log.deprecated('layer.state.attributeManager', 'layer.getAttributeManager()')();\n        return attributeManager;\n      }\n    });\n    /* eslint-enable accessor-pairs */\n\n    this.internalState.layer = this;\n    this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);\n    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);\n\n    // Ensure any async props are updated\n    this.internalState.setAsyncProps(this.props);\n\n    // Call subclass lifecycle methods\n    this.initializeState(this.context);\n\n    // Initialize extensions\n    for (const extension of this.props.extensions) {\n      extension.initializeState.call(this, this.context, extension);\n    }\n    // End subclass lifecycle methods\n\n    // initializeState callback tends to clear state\n    this.setChangeFlags({\n      dataChanged: 'init',\n      propsChanged: 'init',\n      viewportChanged: true,\n      extensionsChanged: true\n    });\n\n    this._update();\n  }\n\n  /** (Internal) Called by layer manager to transfer state from an old layer */\n  _transferState(oldLayer: Layer<PropsT>): void {\n    debug(TRACE_MATCHED, this, this === oldLayer);\n\n    const {state, internalState} = oldLayer;\n\n    if (this === oldLayer) {\n      return;\n    }\n\n    // Move internalState\n    this.internalState = internalState as LayerState<this>;\n    this.internalState.layer = this;\n\n    // Move state\n    this.state = state;\n    // We keep the state ref on old layers to support async actions\n    // oldLayer.state = null;\n\n    // Ensure any async props are updated\n    this.internalState.setAsyncProps(this.props);\n\n    this._diffProps(this.props, this.internalState.getOldProps() as Layer<PropsT>['props']);\n  }\n\n  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */\n  _update(): void {\n    // Call subclass lifecycle method\n    const stateNeedsUpdate = this.needsUpdate();\n    // End lifecycle method\n    debug(TRACE_UPDATE, this, stateNeedsUpdate);\n\n    if (!stateNeedsUpdate) {\n      return;\n    }\n\n    const currentProps = this.props;\n    const context = this.context;\n    const internalState = this.internalState as LayerState<this>;\n\n    const currentViewport = context.viewport;\n    const propsInTransition = this._updateUniformTransition();\n    internalState.propsInTransition = propsInTransition;\n    // Overwrite this.context.viewport during update to use the last activated viewport on this layer\n    // In multi-view applications, a layer may only be drawn in one of the views\n    // Which would make the \"active\" viewport different from the shared context\n    context.viewport = internalState.viewport || currentViewport;\n    // Overwrite this.props during update to use in-transition prop values\n    this.props = propsInTransition;\n\n    try {\n      const updateParams = this._getUpdateParams();\n      const oldModels = this.getModels();\n\n      // Safely call subclass lifecycle methods\n      if (context.gl) {\n        this.updateState(updateParams);\n      } else {\n        try {\n          this.updateState(updateParams);\n        } catch (error) {\n          // ignore error if gl context is missing\n        }\n      }\n      // Execute extension updates\n      for (const extension of this.props.extensions) {\n        extension.updateState.call(this, updateParams, extension);\n      }\n\n      const modelChanged = this.getModels()[0] !== oldModels[0];\n      this._postUpdate(updateParams, modelChanged);\n      // End subclass lifecycle methods\n    } finally {\n      // Restore shared context\n      context.viewport = currentViewport;\n      this.props = currentProps;\n      this._clearChangeFlags();\n      internalState.needsUpdate = false;\n      internalState.resetOldProps();\n    }\n  }\n  /* eslint-enable max-statements */\n\n  /** (Internal) Called by manager when layer is about to be disposed \n      Note: not guaranteed to be called on application shutdown */\n  _finalize(): void {\n    debug(TRACE_FINALIZE, this);\n\n    // Call subclass lifecycle method\n    this.finalizeState(this.context);\n    // Finalize extensions\n    for (const extension of this.props.extensions) {\n      extension.finalizeState.call(this, extension);\n    }\n  }\n\n  // Calculates uniforms\n  _drawLayer({\n    moduleParameters = null,\n    uniforms = {},\n    parameters = {}\n  }: {\n    moduleParameters: any;\n    uniforms: any;\n    parameters: any;\n  }): void {\n    this._updateAttributeTransition();\n\n    const currentProps = this.props;\n    const context = this.context;\n    // Overwrite this.props during redraw to use in-transition prop values\n    // `internalState.propsInTransition` could be missing if `updateState` failed\n    // @ts-ignore (TS2339) internalState is alwasy defined when this method is called\n    this.props = this.internalState.propsInTransition || currentProps;\n\n    const opacity = this.props.opacity;\n    // apply gamma to opacity to make it visually \"linear\"\n    uniforms.opacity = Math.pow(opacity, 1 / 2.2);\n\n    try {\n      // TODO/ib - hack move to luma Model.draw\n      if (moduleParameters) {\n        this.setModuleParameters(moduleParameters);\n      }\n\n      // Apply polygon offset to avoid z-fighting\n      // TODO - move to draw-layers\n      const {getPolygonOffset} = this.props;\n      const offsets = (getPolygonOffset && getPolygonOffset(uniforms)) || [0, 0];\n\n      setParameters(context.gl, {polygonOffset: offsets});\n\n      // Call subclass lifecycle method\n      withParameters(context.gl, parameters, () => {\n        const opts = {moduleParameters, uniforms, parameters, context};\n\n        // extensions\n        for (const extension of this.props.extensions) {\n          extension.draw.call(this, opts, extension);\n        }\n\n        this.draw(opts);\n      });\n    } finally {\n      this.props = currentProps;\n    }\n\n    // End lifecycle method\n  }\n\n  // Helper methods\n  /** Returns the current change flags */\n  getChangeFlags(): ChangeFlags | undefined {\n    return this.internalState?.changeFlags;\n  }\n\n  /* eslint-disable complexity */\n  /** Dirty some change flags, will be handled by updateLayer */\n  setChangeFlags(flags: Partial<ChangeFlags>): void {\n    if (!this.internalState) {\n      return;\n    }\n    const {changeFlags} = this.internalState;\n\n    /* eslint-disable no-fallthrough, max-depth */\n    for (const key in flags) {\n      if (flags[key]) {\n        let flagChanged = false;\n        switch (key) {\n          case 'dataChanged':\n            // changeFlags.dataChanged may be `false`, a string (reason) or an array of ranges\n            const dataChangedReason = flags[key];\n            const prevDataChangedReason = changeFlags[key];\n            if (dataChangedReason && Array.isArray(prevDataChangedReason)) {\n              // Merge partial updates\n              changeFlags.dataChanged = Array.isArray(dataChangedReason)\n                ? prevDataChangedReason.concat(dataChangedReason)\n                : dataChangedReason;\n              flagChanged = true;\n            }\n\n          default:\n            if (!changeFlags[key]) {\n              changeFlags[key] = flags[key];\n              flagChanged = true;\n            }\n        }\n        if (flagChanged) {\n          debug(TRACE_CHANGE_FLAG, this, key, flags);\n        }\n      }\n    }\n    /* eslint-enable no-fallthrough, max-depth */\n\n    // Update composite flags\n    const propsOrDataChanged = Boolean(\n      changeFlags.dataChanged ||\n        changeFlags.updateTriggersChanged ||\n        changeFlags.propsChanged ||\n        changeFlags.extensionsChanged\n    );\n    changeFlags.propsOrDataChanged = propsOrDataChanged;\n    changeFlags.somethingChanged =\n      propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;\n  }\n  /* eslint-enable complexity */\n\n  /** Clear all changeFlags, typically after an update */\n  private _clearChangeFlags(): void {\n    // @ts-ignore TS2531 this method can only be called internally with internalState assigned\n    this.internalState.changeFlags = {\n      dataChanged: false,\n      propsChanged: false,\n      updateTriggersChanged: false,\n      viewportChanged: false,\n      stateChanged: false,\n      extensionsChanged: false,\n      propsOrDataChanged: false,\n      somethingChanged: false\n    };\n  }\n\n  /** Compares the layers props with old props from a matched older layer\n      and extracts change flags that describe what has change so that state\n      can be update correctly with minimal effort */\n  private _diffProps(newProps: Layer<PropsT>['props'], oldProps: Layer<PropsT>['props']) {\n    const changeFlags = diffProps(newProps, oldProps);\n\n    // iterate over changedTriggers\n    if (changeFlags.updateTriggersChanged) {\n      for (const key in changeFlags.updateTriggersChanged) {\n        if (changeFlags.updateTriggersChanged[key]) {\n          this.invalidateAttribute(key);\n        }\n      }\n    }\n\n    // trigger uniform transitions\n    if (changeFlags.transitionsChanged) {\n      for (const key in changeFlags.transitionsChanged) {\n        // prop changed and transition is enabled\n        // @ts-ignore (TS2531) internalState is always defined when this method is called\n        this.internalState.uniformTransitions.add(\n          key,\n          oldProps[key],\n          newProps[key],\n          newProps.transitions?.[key]\n        );\n      }\n    }\n\n    return this.setChangeFlags(changeFlags);\n  }\n\n  /** (Internal) called by layer manager to perform extra props validation (in development only) */\n  validateProps(): void {\n    validateProps(this.props);\n  }\n\n  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */\n  updateAutoHighlight(info: PickingInfo): void {\n    if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {\n      this._updateAutoHighlight(info);\n    }\n  }\n\n  // May be overriden by subclasses\n\n  // TODO - simplify subclassing interface\n  /** Update picking module parameters to highlight the hovered object */\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    const pickingModuleParameters: any = {\n      pickingSelectedColor: info.picked ? info.color : null\n    };\n    const {highlightColor} = this.props;\n    if (info.picked && typeof highlightColor === 'function') {\n      pickingModuleParameters.pickingHighlightColor = highlightColor(info);\n    }\n    this.setModuleParameters(pickingModuleParameters);\n    // setModuleParameters does not trigger redraw\n    this.setNeedsRedraw();\n  }\n\n  /** Create new attribute manager */\n  protected _getAttributeManager(): AttributeManager | null {\n    const context = this.context;\n    return new AttributeManager(context.gl, {\n      id: this.props.id,\n      stats: context.stats,\n      timeline: context.timeline\n    });\n  }\n\n  // Private methods\n\n  /** Called after updateState to perform common tasks */\n  protected _postUpdate(updateParams: UpdateParameters<Layer<PropsT>>, forceUpdate: boolean) {\n    const {props, oldProps} = updateParams;\n\n    this.setNeedsRedraw();\n    // Check if attributes need recalculation\n    this._updateAttributes();\n\n    // Note: Automatic instance count update only works for single layers\n    const {model} = this.state;\n    model?.setInstanceCount(this.getNumInstances());\n\n    // Set picking module parameters to match props\n    const {autoHighlight, highlightedObjectIndex, highlightColor} = props;\n    if (\n      forceUpdate ||\n      oldProps.autoHighlight !== autoHighlight ||\n      oldProps.highlightedObjectIndex !== highlightedObjectIndex ||\n      oldProps.highlightColor !== highlightColor\n    ) {\n      const parameters: any = {};\n      if (!autoHighlight) {\n        parameters.pickingSelectedColor = null;\n      }\n      if (Array.isArray(highlightColor)) {\n        parameters.pickingHighlightColor = highlightColor;\n      }\n\n      // highlightedObjectIndex will overwrite any settings from auto highlighting.\n      if (Number.isInteger(highlightedObjectIndex)) {\n        parameters.pickingSelectedColor =\n          Number.isFinite(highlightedObjectIndex) && (highlightedObjectIndex as number) >= 0\n            ? this.encodePickingColor(highlightedObjectIndex)\n            : null;\n      }\n\n      this.setModuleParameters(parameters);\n    }\n  }\n\n  private _getUpdateParams(): UpdateParameters<Layer<PropsT>> {\n    return {\n      props: this.props,\n      // @ts-ignore TS2531 this method can only be called internally with internalState assigned\n      oldProps: this.internalState.getOldProps() as PropsT,\n      context: this.context,\n      // @ts-ignore TS2531 this method can only be called internally with internalState assigned\n      changeFlags: this.internalState.changeFlags\n    };\n  }\n\n  /** Checks state of attributes and model */\n  private _getNeedsRedraw(opts: {clearRedrawFlags: boolean}): string | false {\n    // this method may be called by the render loop as soon a the layer\n    // has been created, so guard against uninitialized state\n    if (!this.internalState) {\n      return false;\n    }\n\n    let redraw: string | false = false;\n    redraw = redraw || (this.internalState.needsRedraw && this.id);\n    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;\n\n    // TODO - is attribute manager needed? - Model should be enough.\n    const attributeManager = this.getAttributeManager();\n    const attributeManagerNeedsRedraw = attributeManager\n      ? attributeManager.getNeedsRedraw(opts)\n      : false;\n    redraw = redraw || attributeManagerNeedsRedraw;\n\n    return redraw;\n  }\n\n  /** Callback when asyn prop is loaded */\n  private _onAsyncPropUpdated(): void {\n    // @ts-ignore TS2531 this method can only be called internally with internalState assigned\n    this._diffProps(this.props, this.internalState.getOldProps());\n    this.setNeedsUpdate();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}