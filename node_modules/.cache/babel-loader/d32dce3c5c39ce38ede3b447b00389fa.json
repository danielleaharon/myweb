{"ast":null,"code":"import assert from './assert';\nconst RADIANS_TO_DEGREES = 1 / Math.PI * 180;\nconst DEGREES_TO_RADIANS = 1 / 180 * Math.PI;\nexport const config = {\n  EPSILON: 1e-12,\n  debug: false,\n  precision: 4,\n  printTypes: false,\n  printDegrees: false,\n  printRowMajor: true\n};\nexport function configure(options) {\n  for (const key in options) {\n    assert(key in config);\n    config[key] = options[key];\n  }\n\n  return config;\n}\nexport function formatValue(value, {\n  precision = config.precision\n} = {}) {\n  value = round(value);\n  return \"\".concat(parseFloat(value.toPrecision(precision)));\n}\nexport function isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);\n}\nexport function clone(array) {\n  return 'clone' in array ? array.clone() : array.slice();\n}\nexport function toRadians(degrees) {\n  return radians(degrees);\n}\nexport function toDegrees(radians) {\n  return degrees(radians);\n}\nexport function radians(degrees, result) {\n  return map(degrees, degrees => degrees * DEGREES_TO_RADIANS, result);\n}\nexport function degrees(radians, result) {\n  return map(radians, radians => radians * RADIANS_TO_DEGREES, result);\n}\nexport function sin(radians, result) {\n  return map(radians, angle => Math.sin(angle), result);\n}\nexport function cos(radians, result) {\n  return map(radians, angle => Math.cos(angle), result);\n}\nexport function tan(radians, result) {\n  return map(radians, angle => Math.tan(angle), result);\n}\nexport function asin(radians, result) {\n  return map(radians, angle => Math.asin(angle), result);\n}\nexport function acos(radians, result) {\n  return map(radians, angle => Math.acos(angle), result);\n}\nexport function atan(radians, result) {\n  return map(radians, angle => Math.atan(angle), result);\n}\nexport function clamp(value, min, max) {\n  return map(value, value => Math.max(min, Math.min(max, value)));\n}\nexport function lerp(a, b, t) {\n  if (isArray(a)) {\n    return a.map((ai, i) => lerp(ai, b[i], t));\n  }\n\n  return t * b + (1 - t) * a;\n}\nexport function equals(a, b, epsilon) {\n  const oldEpsilon = config.EPSILON;\n\n  if (epsilon) {\n    config.EPSILON = epsilon;\n  }\n\n  try {\n    if (a === b) {\n      return true;\n    }\n\n    if (isArray(a) && isArray(b)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n\n      for (let i = 0; i < a.length; ++i) {\n        if (!equals(a[i], b[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    if (a && a.equals) {\n      return a.equals(b);\n    }\n\n    if (b && b.equals) {\n      return b.equals(a);\n    }\n\n    if (typeof a === 'number' && typeof b === 'number') {\n      return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));\n    }\n\n    return false;\n  } finally {\n    config.EPSILON = oldEpsilon;\n  }\n}\nexport function exactEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a && typeof a === 'object' && b && typeof b === 'object') {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    if (a.exactEquals) {\n      return a.exactEquals(b);\n    }\n  }\n\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; ++i) {\n      if (!exactEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\nexport function withEpsilon(epsilon, func) {\n  const oldPrecision = config.EPSILON;\n  config.EPSILON = epsilon;\n  let value;\n\n  try {\n    value = func();\n  } finally {\n    config.EPSILON = oldPrecision;\n  }\n\n  return value;\n}\n\nfunction round(value) {\n  return Math.round(value / config.EPSILON) * config.EPSILON;\n}\n\nfunction duplicateArray(array) {\n  return array.clone ? array.clone() : new Array(array.length);\n}\n\nfunction map(value, func, result) {\n  if (isArray(value)) {\n    const array = value;\n    result = result || duplicateArray(array);\n\n    for (let i = 0; i < result.length && i < array.length; ++i) {\n      result[i] = func(value[i], i, result);\n    }\n\n    return result;\n  }\n\n  return func(value);\n}","map":{"version":3,"sources":["../../../src/lib/common.ts"],"names":["RADIANS_TO_DEGREES","Math","DEGREES_TO_RADIANS","config","EPSILON","debug","precision","printTypes","printDegrees","printRowMajor","assert","key","options","value","round","parseFloat","Array","ArrayBuffer","array","radians","degrees","map","angle","isArray","a","lerp","b","t","oldEpsilon","i","equals","exactEquals","oldPrecision","func","result","duplicateArray"],"mappings":"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","sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n// MIT License\nimport {NumericArray} from '@math.gl/types';\nimport assert from './assert';\n\nimport type MathArray from '../classes/base/math-array';\n\nexport type ConfigurationOptions = {\n  EPSILON: number;\n  debug?: boolean;\n  precision: number;\n  printTypes?: boolean;\n  printDegrees?: boolean;\n  printRowMajor?: boolean;\n  _cartographicRadians?: boolean;\n};\n\nconst RADIANS_TO_DEGREES = (1 / Math.PI) * 180;\nconst DEGREES_TO_RADIANS = (1 / 180) * Math.PI;\n\n// TODO - remove\nexport const config: ConfigurationOptions = {\n  EPSILON: 1e-12,\n  debug: false,\n  precision: 4,\n  printTypes: false,\n  printDegrees: false,\n  printRowMajor: true\n};\n\nexport function configure(options?: Partial<ConfigurationOptions>): ConfigurationOptions {\n  // Only copy existing keys\n  for (const key in options) {\n    assert(key in config);\n    config[key] = options[key];\n  }\n  return config;\n}\n\n/**\n * Formats a value into a string\n * @param value\n * @param param1\n * @returns\n */\nexport function formatValue(\n  value: number,\n  {precision = config.precision}: {precision?: number} = {}\n): string {\n  value = round(value);\n  // get rid of trailing zeros\n  return `${parseFloat(value.toPrecision(precision))}`;\n}\n\n/**\n * Check if value is an \"array\"\n * Returns `true` if value is either an array or a typed array\n *\n * Note: returns `false` for `ArrayBuffer` and `DataView` instances\n */\nexport function isArray(value: unknown): boolean {\n  return Array.isArray(value) || (ArrayBuffer.isView(value) && !(value instanceof DataView));\n}\n\nexport function clone(array: NumericArray | MathArray): NumericArray {\n  return 'clone' in array ? array.clone() : array.slice();\n}\n\nexport function toRadians(degrees: number): number;\nexport function toRadians(degrees: NumericArray): NumericArray;\n\nexport function toRadians(degrees: number | NumericArray): number | NumericArray {\n  return radians(degrees as NumericArray);\n}\n\nexport function toDegrees(degrees: number): number;\nexport function toDegrees(degrees: NumericArray): NumericArray;\n\nexport function toDegrees(radians: number | NumericArray): number | NumericArray {\n  return degrees(radians as NumericArray);\n}\n\n// GLSL math function equivalents - Works on both single values and vectors\n\n/**\n * \"GLSL equivalent\" radians: Works on single values and vectors\n */\nexport function radians(degrees: number): number;\nexport function radians(degrees: NumericArray, result?: NumericArray): NumericArray;\n\nexport function radians(\n  degrees: number | NumericArray,\n  result?: NumericArray\n): number | NumericArray {\n  return map(degrees, (degrees) => degrees * DEGREES_TO_RADIANS, result);\n}\n\n/**\n * \"GLSL equivalent\" degrees: Works on single values and vectors\n */\nexport function degrees(radians: number): number;\nexport function degrees(radians: NumericArray, result?: NumericArray): NumericArray;\n\nexport function degrees(\n  radians: number | NumericArray,\n  result?: NumericArray\n): number | NumericArray {\n  return map(radians, (radians) => radians * RADIANS_TO_DEGREES, result);\n}\n\n/**\n * \"GLSL equivalent\" of `Math.sin`: Works on single values and vectors\n * @deprecated\n */\nexport function sin(radians: number | NumericArray, result?: NumericArray): number | NumericArray {\n  return map(radians, (angle) => Math.sin(angle), result);\n}\n\n/**\n * \"GLSL equivalent\" of `Math.cos`: Works on single values and vectors\n * @deprecated\n */\nexport function cos(radians: number | NumericArray, result?: NumericArray): number | NumericArray {\n  return map(radians, (angle) => Math.cos(angle), result);\n}\n\n/**\n * \"GLSL equivalent\" of `Math.tan`: Works on single values and vectors\n * @deprecated\n */\nexport function tan(radians: number | NumericArray, result?: NumericArray): number | NumericArray {\n  return map(radians, (angle) => Math.tan(angle), result);\n}\n\n/**\n * \"GLSL equivalent\" of `Math.asin`: Works on single values and vectors\n * @deprecated\n */\nexport function asin(radians: number | NumericArray, result?: NumericArray): number | NumericArray {\n  return map(radians, (angle) => Math.asin(angle), result);\n}\n\n/**\n * \"GLSL equivalent\" of `Math.acos`: Works on single values and vectors\n * @deprecated\n */\nexport function acos(radians: number | NumericArray, result?: NumericArray): number | NumericArray {\n  return map(radians, (angle) => Math.acos(angle), result);\n}\n\n/**\n * \"GLSL equivalent\" of `Math.atan`: Works on single values and vectors\n * @deprecated\n */\nexport function atan(radians: number | NumericArray, result?: NumericArray): number | NumericArray {\n  return map(radians, (angle) => Math.atan(angle), result);\n}\n\n/**\n * GLSL style value clamping: Works on single values and vectors\n */\nexport function clamp(value: number, min: number, max: number): number;\nexport function clamp(value: NumericArray, min: number, max: number): NumericArray;\n\nexport function clamp(\n  value: number | NumericArray,\n  min: number,\n  max: number\n): number | NumericArray {\n  return map(value, (value) => Math.max(min, Math.min(max, value)));\n}\n\n/**\n * Interpolate between two numbers or two arrays\n */\nexport function lerp(a: number, b: number, t: number): number;\nexport function lerp(a: NumericArray, b: NumericArray, t: number): NumericArray;\n\nexport function lerp(\n  a: number | NumericArray,\n  b: number | NumericArray,\n  t: number\n): number | NumericArray {\n  if (isArray(a)) {\n    return (a as NumericArray).map((ai: number, i: number) => lerp(ai, (b as NumericArray)[i], t));\n  }\n  return t * (b as number) + (1 - t) * (a as number);\n}\n\n/* eslint-disable */\n\n/**\n * Compares any two math objects, using `equals` method if available.\n * @param a\n * @param b\n * @param epsilon\n * @returns\n */\nexport function equals(a: any, b: any, epsilon?: number): boolean {\n  const oldEpsilon = config.EPSILON;\n  if (epsilon) {\n    config.EPSILON = epsilon;\n  }\n  try {\n    if (a === b) {\n      return true;\n    }\n    if (isArray(a) && isArray(b)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n      for (let i = 0; i < a.length; ++i) {\n        // eslint-disable-next-line max-depth\n        if (!equals(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (a && a.equals) {\n      return a.equals(b);\n    }\n    if (b && b.equals) {\n      return b.equals(a);\n    }\n    if (typeof a === 'number' && typeof b === 'number') {\n      return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));\n    }\n    return false;\n  } finally {\n    config.EPSILON = oldEpsilon;\n  }\n}\n\nexport function exactEquals(a: any, b: any): boolean {\n  if (a === b) {\n    return true;\n  }\n  if (a && typeof a === 'object' && b && typeof b === 'object') {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n    if (a.exactEquals) {\n      return a.exactEquals(b);\n    }\n  }\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; ++i) {\n      if (!exactEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\n/* eslint-enable */\n\nexport function withEpsilon<T>(epsilon: number, func: () => T): T {\n  const oldPrecision = config.EPSILON;\n  config.EPSILON = epsilon;\n  let value: T;\n  try {\n    value = func();\n  } finally {\n    config.EPSILON = oldPrecision;\n  }\n  return value;\n}\n\n// HELPERS\n\nfunction round(value: number): number {\n  return Math.round(value / config.EPSILON) * config.EPSILON;\n}\n\n// If the array has a clone function, calls it, otherwise returns a copy\nfunction duplicateArray(array: NumericArray): NumericArray {\n  // @ts-expect-error We check for math.gl class methods\n  return array.clone ? array.clone() : (new Array(array.length) as number[]);\n}\n\n// If the argument value is an array, applies the func element wise,\n// otherwise applies func to the argument value\nfunction map(\n  value: number | NumericArray,\n  func: (x: number, index?: number, result?: NumericArray) => number,\n  result?: NumericArray\n): number | NumericArray {\n  if (isArray(value)) {\n    const array = value as NumericArray;\n    result = result || duplicateArray(array);\n    for (let i = 0; i < result.length && i < array.length; ++i) {\n      result[i] = func(value[i], i, result);\n    }\n    return result;\n  }\n  return func(value as number);\n}\n"]},"metadata":{},"sourceType":"module"}