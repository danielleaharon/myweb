{"ast":null,"code":"import { equals } from '@math.gl/core';\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\nexport function modifyPolygonWindingDirection(points, direction, options = {}) {\n  const windingDirection = getPolygonWindingDirection(points, options);\n\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirection(points, options = {}) {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\nexport function getPolygonSignedArea(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  const dim = options.size || 2;\n  let area = 0;\n\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nexport function forEachSegmentInPolygon(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2,\n    isClosed\n  } = options;\n  const numPoints = (end - start) / size;\n\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx = isClosed || equals(points[start], points[endPointIndex]) && equals(points[start + 1], points[endPointIndex + 1]);\n\n  if (!isClosedEx) {\n    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);\n  }\n}\n\nfunction reversePolygon(points, options) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2\n  } = options;\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\nexport function modifyPolygonWindingDirectionPoints(points, direction, options = {}) {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirectionPoints(points, options = {}) {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\nexport function getPolygonSignedAreaPoints(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  let area = 0;\n\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nexport function forEachSegmentInPolygonPoints(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    isClosed\n  } = options;\n\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}","map":{"version":3,"sources":["../../src/polygon-utils.ts"],"names":["WINDING","CLOCKWISE","COUNTER_CLOCKWISE","options","windingDirection","getPolygonWindingDirection","reversePolygon","Math","getPolygonSignedArea","start","end","points","length","dim","area","i","j","size","isClosed","numPoints","visitor","endPointIndex","isClosedEx","equals","numSwaps","b1","b2","tmp","currentDirection","getPolygonWindingDirectionPoints","getPolygonSignedAreaPoints"],"mappings":"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","sourcesContent":["/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\n\nimport {equals} from '@math.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n} as const;\n\n/** Polygon representation where each point is represented as a separate array of positions. */\ntype PointsArray = NumericArray[];\n\n/** Segment visitor callback type for polygons defined with flat arrays, */\ntype SegmentVisitorFlat = (\n  p1x: number,\n  p1y: number,\n  p2x: number,\n  p2y: number,\n  i1: number,\n  i2: number\n) => void;\n\n/** Segment visitor callback type for polygons defined with array of points. */\nexport type SegmentVisitorPoints = (\n  p1: NumericArray,\n  p2: NumericArray,\n  i1: number,\n  i2: number\n) => void;\n\n/** Parameters of a polygon. */\ntype PolygonParams = {\n  start?: number; // Start index of the polygon in the array of positions. Defaults to 0.\n  end?: number; // End index of the polygon in the array of positions. Defaults to number of positions.\n  size?: number; // Size of a point, 2 (XZ) or 3 (XYZ). Defaults to 2. Affects only polygons stored in flat arrays.\n  isClosed?: boolean; // Indicates that the first point of the polygon is equal to the last point, and additional checks should be ommited.\n};\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points An array that represents points of the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirection(\n  points: NumericArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const windingDirection = getPolygonWindingDirection(points, options);\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirection(\n  points: NumericArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n * https://en.wikipedia.org/wiki/Shoelace_formula\n */\nexport function getPolygonSignedArea(points: NumericArray, options: PolygonParams = {}): number {\n  const {start = 0, end = points.length} = options;\n  const dim = options.size || 2;\n  let area = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls the visitor callback for each segment in the polygon.\n * @param points An array that represents points of the polygon\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygon(\n  points: NumericArray,\n  visitor: SegmentVisitorFlat,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, size = 2, isClosed} = options;\n\n  const numPoints = (end - start) / size;\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(\n      points[start + i * size],\n      points[start + i * size + 1],\n      points[start + (i + 1) * size],\n      points[start + (i + 1) * size + 1],\n      i,\n      i + 1\n    );\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx =\n    isClosed ||\n    (equals(points[start], points[endPointIndex]) &&\n      equals(points[start + 1], points[endPointIndex + 1]));\n\n  if (!isClosedEx) {\n    visitor(\n      points[endPointIndex],\n      points[endPointIndex + 1],\n      points[start],\n      points[start + 1],\n      numPoints - 1,\n      0\n    );\n  }\n}\n\nfunction reversePolygon(\n  points: NumericArray,\n  options: {start?: number; end?: number; size?: number}\n): void {\n  const {start = 0, end = points.length, size = 2} = options;\n\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points Array of points that represent the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirectionPoints(\n  points: PointsArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirectionPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n */\nexport function getPolygonSignedAreaPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  const {start = 0, end = points.length} = options;\n  let area = 0;\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls visitor callback for each segment in the polygon.\n * @param points Array of points that represent the polygon.\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygonPoints(\n  points: PointsArray,\n  visitor: SegmentVisitorPoints,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, isClosed} = options;\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}