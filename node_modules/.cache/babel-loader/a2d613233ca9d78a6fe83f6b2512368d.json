{"ast":null,"code":"import config from '../../global/config';\nimport _ from 'lodash';\nlet mapping = []; // store the tile mappings here, for easier access.\n\nlet last_calculated_player_details = {};\nlet gameboard; // this will store positions of the gameboard div.\n\nlet all_ladders = [{\n  id: 'df4s',\n  from: 2,\n  to: 38\n}, {\n  id: 'fgh5',\n  from: 4,\n  to: 24\n}, {\n  id: 'io98',\n  from: 7,\n  to: 56\n}, {\n  id: 'ajsd',\n  from: 8,\n  to: 13\n}, {\n  id: 'dfo4',\n  from: 10,\n  to: 30\n}, {\n  id: '12dd',\n  from: 28,\n  to: 48\n}, {\n  id: '4sce',\n  from: 47,\n  to: 88\n}, {\n  id: 'p98d',\n  from: 57,\n  to: 81\n}, {\n  id: 'pwdi',\n  from: 65,\n  to: 77\n}, {\n  id: 'pi3u',\n  from: 71,\n  to: 91\n}, {\n  id: 'tu83',\n  from: 70,\n  to: 86\n}, {\n  id: 'zxs7',\n  from: 94,\n  to: 97\n}, {\n  id: 'weu2',\n  from: 22,\n  to: 28\n}];\nlet all_snakes = [{\n  id: 'sn_1',\n  from: 25,\n  to: 9\n}, {\n  id: 'sn_2',\n  from: 55,\n  to: 29\n}, {\n  id: 'sn_3',\n  from: 93,\n  to: 75\n}, {\n  id: 'sn_4',\n  from: 99,\n  to: 58\n}, {\n  id: 'sn_5',\n  from: 40,\n  to: 19\n}, {\n  id: 'sn_6',\n  from: 76,\n  to: 46\n}];\nlet game_ladders = [];\nlet game_snakes = [];\nlet calculated_ladder_styles = [];\nlet calculated_snake_styles = [];\nlet calculated_player_positions = [];\nlet calculated_perfect_throw_positions = [];\n/**\n * calculate the total number of perfect throws required to win this game.\n */\n\nexport function calculatePerfectThrowsFromPosition(position) {\n  if (calculated_perfect_throw_positions[position]) {\n    return calculated_perfect_throw_positions[position];\n  }\n\n  let max_tiles = 100;\n  let current_tile = 1;\n  let does_this_tile_have_ladder = tileHasLadder(position);\n\n  if (does_this_tile_have_ladder) {\n    return 'calculating..';\n  } else {\n    current_tile = position;\n    let data = [];\n\n    for (var i = 0; current_tile <= max_tiles; i++) {\n      let result = runTheLoop(current_tile);\n      data.push({\n        from: current_tile,\n        dice: result.dice,\n        position: result.position\n      }); // this is so we can display detailed info if required. Not used currently though.\n\n      current_tile = result.position;\n    }\n\n    if (current_tile >= 100) {\n      // console.log('data',data);\n      calculated_perfect_throw_positions[position] = data.length;\n      return data.length;\n    }\n  }\n}\nconst dice = 6;\n\nfunction runTheLoop(tile) {\n  let ladders = find_ladders_between(tile);\n\n  if (ladders) {\n    return {\n      dice: ladders.dice,\n      position: ladders.position\n    };\n  } else {\n    let snakes = find_snakes_between(tile);\n    return {\n      dice: snakes.dice,\n      position: snakes.position\n    };\n  }\n}\n\nfunction find_ladders_between(tile) {\n  let found_ladders = _.filter(game_ladders, function (ladder) {\n    return ladder.from >= tile && ladder.from <= tile + dice;\n  });\n\n  let ladder;\n\n  if (found_ladders.length > 1) {\n    ladder = _.orderBy(found_ladders, ['to'], ['desc']);\n    ladder = ladder[0];\n  } else {\n    ladder = found_ladders[0];\n  } // if theres a ladder in between use that, ignore about the snakes... they dont matter.\n\n\n  if (ladder) {\n    return {\n      position: ladder.to,\n      dice: ladder.from - tile\n    };\n  } else {\n    return null;\n  }\n}\n\nfunction find_snakes_between(tile) {\n  let moves = dice;\n  let check = false;\n\n  while (!check) {\n    let snake = _.find(game_snakes, function (snake) {\n      return snake.from === tile + moves;\n    });\n\n    if (snake) {\n      moves--;\n    } else {\n      check = true;\n    }\n  }\n\n  return {\n    position: tile + moves,\n    dice: moves\n  };\n}\n\nfunction tileHasLadder(tile) {\n  let ladder = _.find(game_ladders, function (ladder) {\n    return ladder.from === tile;\n  });\n\n  if (ladder) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function generateGameboard() {\n  const total_tiles = 100;\n  const tile_styles = ['yellow', 'white', 'red', 'blue', 'green', 'white', 'red', 'yellow', 'green', 'blue'];\n  let tiles = [];\n  let temp = [];\n  let reverse = false;\n  let count = 0;\n\n  for (let i = total_tiles; i > 0; i--) {\n    count++;\n    let random = Math.floor(Math.random() * 10);\n    let tile = {\n      id: i,\n      type: 'normal',\n      style: tile_styles[random]\n    };\n\n    if (reverse) {\n      temp.unshift(tile);\n    } else {\n      temp.push(tile);\n    }\n\n    if (count === 10) {\n      reverse = !reverse;\n      tiles = tiles.concat(temp);\n      temp = [];\n      count = 0;\n    }\n  }\n\n  _(tiles).forEach(function (tile, index) {\n    mapping[tile.id] = index;\n  });\n\n  return tiles;\n}\nexport function getPlayerStartingPosition() {\n  return mapping[1] || 90;\n}\nexport function getPlayerIndexBasedOnId(players, id) {\n  let index = players.findIndex(item => {\n    return item.id == id;\n  });\n  return index;\n}\nexport function randomBetweenRange(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\nexport function shuffle(o) {\n  for (var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);\n\n  return o;\n}\n;\nexport function generateLadders(difficulty) {\n  // 1: easy, 2: medium, 3: difficult, 4: hell mode\n  let total_ladders = 0;\n\n  if (difficulty === 1) {\n    total_ladders = randomBetweenRange(8, 10);\n  }\n\n  if (difficulty === 2) {\n    total_ladders = randomBetweenRange(4, 7);\n  }\n\n  if (difficulty === 3) {\n    total_ladders = randomBetweenRange(2, 4);\n  }\n\n  if (difficulty === 4) {\n    total_ladders = randomBetweenRange(0, 1);\n  }\n\n  if (total_ladders === 0) {\n    return [];\n  }\n\n  let shuffled_array = shuffle(all_ladders);\n  let ladders = shuffled_array.slice(0, total_ladders);\n  game_ladders = ladders;\n  return ladders;\n}\nexport function generateSnakes(difficulty) {\n  let total_snakes = 0;\n\n  if (difficulty === 1) {\n    total_snakes = randomBetweenRange(1, 3);\n  }\n\n  if (difficulty === 2) {\n    total_snakes = randomBetweenRange(3, 5);\n  }\n\n  if (difficulty === 3) {\n    total_snakes = randomBetweenRange(5, 7);\n  }\n\n  if (difficulty === 4) {\n    total_snakes = randomBetweenRange(7, 10);\n  }\n\n  let shuffled_array = shuffle(all_snakes);\n  let snakes = shuffled_array.slice(0, total_snakes);\n  game_snakes = snakes;\n  return snakes;\n}\nexport function calculatePlayerNewPosition(data) {\n  let pos = data.index + data.moves;\n\n  if (pos > 100) {\n    pos = 100;\n  }\n\n  let new_pos = mapping[pos];\n  let result = {\n    tile: new_pos,\n    index: pos\n  };\n  last_calculated_player_details = result;\n  return result;\n}\nexport function getLastCalculatedPlayerPosition(data) {\n  if (last_calculated_player_details.index) {\n    return last_calculated_player_details;\n  } else {\n    return {\n      index: 1\n    };\n  }\n}\nexport function getPlayerPositionCSSStyles(data) {\n  if (data.index > 100) {\n    data.index = 100;\n  }\n\n  if (!document.getElementById(`tile_${data.index}`)) {\n    let calculated = calculated_player_positions[data.id];\n    return {\n      top: calculated.top,\n      left: calculated.left\n    };\n  }\n\n  let tile = document.getElementById(`tile_${data.index}`).getBoundingClientRect();\n  let gameboard = document.getElementById('gameboard').getBoundingClientRect();\n  let top = tile.top + window.scrollY;\n  let left = tile.left;\n  top = top - (gameboard.top + window.scrollY);\n  left = left - gameboard.left;\n  let padding_left = config.player.width * data.array_index;\n  padding_left = padding_left + 8;\n  left = left + padding_left + data.array_index * 2;\n  let padding_top = (config.tile.width - config.player.width) / 2;\n  top = top + padding_top;\n  let output = {\n    top: `${top}px`,\n    left: `${left}px`\n  };\n  calculated_player_positions[data.id] = output;\n  return output;\n}\nexport function generateLadderStyle(data) {\n  let existing = calculated_ladder_styles[data.id];\n\n  if (existing) {\n    return {\n      top: existing.top,\n      left: existing.left,\n      height: existing.height,\n      width: existing.width,\n      transform: existing.transform || ''\n    };\n  }\n\n  let from_tile = document.getElementById(`tile_${data.from}`).getBoundingClientRect();\n  let to_tile = document.getElementById(`tile_${data.to}`).getBoundingClientRect();\n\n  if (!gameboard) {\n    gameboard = document.getElementById('gameboard').getBoundingClientRect();\n  }\n\n  let to_tile_top = to_tile.top + window.scrollY;\n  let from_tile_top = from_tile.top + window.scrollY;\n  let gameboard_top = gameboard.top + window.scrollY;\n  let ladder_position = 1;\n  let left_tile = {};\n  let right_tile = {};\n\n  if (to_tile.left <= from_tile.left) {\n    left_tile = to_tile;\n    right_tile = from_tile;\n  } else {\n    left_tile = from_tile;\n    right_tile = to_tile;\n  }\n\n  if (to_tile.left < from_tile.left) {\n    ladder_position = -1;\n  }\n\n  let top = to_tile_top - gameboard_top;\n  let height = from_tile_top - to_tile_top + (config.tile.height - config.tile.margin);\n  let left = left_tile.left - gameboard.left;\n  let width = right_tile.left - left_tile.left - config.tile.margin + config.tile.width;\n  let tile_css_styles = {\n    top,\n    left,\n    height,\n    width,\n    ladder_position\n  };\n  tile_css_styles = getLadderTransformStyles(tile_css_styles);\n  calculated_ladder_styles[data.id] = tile_css_styles; // store this ladders calculated styles\n\n  return tile_css_styles;\n}\nexport function getLadderTransformStyles(div) {\n  let tile_count = (div.width + config.tile.margin) / config.tile.width;\n  let tile_row_count = (div.height + config.tile.margin) / config.tile.height;\n  let rotate_deg = 0;\n\n  if (tile_count <= 1) {\n    rotate_deg = 0;\n  } else if (tile_count <= 2) {\n    let number = 7;\n\n    if (div.ladder_position === 1) {\n      if (tile_row_count <= 4) {\n        number = 10;\n      }\n    } else {\n      if (tile_row_count <= 4) {\n        number = 20;\n      }\n    }\n\n    rotate_deg = number * tile_count;\n  } else if (tile_count < 4) {\n    rotate_deg = 7 * tile_count;\n  } else if (tile_count < 5) {\n    let number = 8;\n\n    if (tile_row_count >= 4 && div.ladder_position != 1) {\n      number = 11;\n    }\n\n    rotate_deg = number * tile_count;\n  } else if (tile_count < 7) {\n    rotate_deg = 13 * tile_count;\n    div.top = div.top - 12 * tile_count;\n    div.height = div.height + 26 * tile_count;\n  } else {\n    rotate_deg = 7 * tile_count;\n  }\n\n  if (tile_row_count === 1) {\n    rotate_deg = 90;\n    div.top = div.top - (div.width - div.height) / 2;\n    div.height = div.height + (tile_count - 1) * config.tile.height;\n  }\n\n  let transform = `rotate(${rotate_deg * div.ladder_position}deg)`;\n  let styles = {\n    top: `${div.top}px`,\n    left: `${div.left}px`,\n    height: `${div.height}px`,\n    width: `${div.width}px`\n  };\n\n  if (transform) {\n    styles.transform = transform;\n  }\n\n  return styles;\n}\nexport function generateSnakeStyle(data) {\n  let existing = calculated_snake_styles[data.id];\n\n  if (existing) {\n    return {\n      top: existing.top,\n      left: existing.left,\n      height: existing.height,\n      width: existing.width\n    };\n  }\n\n  let from_tile = document.getElementById(`tile_${data.to}`).getBoundingClientRect();\n  let to_tile = document.getElementById(`tile_${data.from}`).getBoundingClientRect();\n\n  if (!gameboard) {\n    gameboard = document.getElementById('gameboard').getBoundingClientRect();\n  }\n\n  let to_tile_top = to_tile.top + window.scrollY;\n  let from_tile_top = from_tile.top + window.scrollY;\n  let gameboard_top = gameboard.top + window.scrollY;\n  let snake_position = -1;\n  let left_tile = {};\n  let right_tile = {};\n\n  if (to_tile.left <= from_tile.left) {\n    left_tile = to_tile;\n    right_tile = from_tile;\n  } else {\n    left_tile = from_tile;\n    right_tile = to_tile;\n  }\n\n  if (to_tile.left < from_tile.left) {\n    snake_position = 1;\n  }\n\n  let top = to_tile_top - gameboard_top;\n  let height = from_tile_top - to_tile_top + (config.tile.height - config.tile.margin);\n  let left = left_tile.left - gameboard.left;\n  let width = right_tile.left - left_tile.left - config.tile.margin + config.tile.width;\n  let tile_css_styles = {\n    top: `${top}px`,\n    left: `${left}px`,\n    height: `${height}px`,\n    width: `${width}px`\n  };\n\n  if (snake_position === -1) {\n    let tile_count = (width + config.tile.margin) / config.tile.width;\n    tile_css_styles.transform = `rotate(${tile_count * 30}deg)`;\n  }\n\n  calculated_snake_styles[data.id] = tile_css_styles; // store this snake's calculated styles\n\n  return tile_css_styles;\n}","map":{"version":3,"sources":["/Users/user/Desktop/עבודות להגשה/myweb/src/components/snakes/global/utils/Helper.js"],"names":["config","_","mapping","last_calculated_player_details","gameboard","all_ladders","id","from","to","all_snakes","game_ladders","game_snakes","calculated_ladder_styles","calculated_snake_styles","calculated_player_positions","calculated_perfect_throw_positions","calculatePerfectThrowsFromPosition","position","max_tiles","current_tile","does_this_tile_have_ladder","tileHasLadder","data","i","result","runTheLoop","push","dice","length","tile","ladders","find_ladders_between","snakes","find_snakes_between","found_ladders","filter","ladder","orderBy","moves","check","snake","find","generateGameboard","total_tiles","tile_styles","tiles","temp","reverse","count","random","Math","floor","type","style","unshift","concat","forEach","index","getPlayerStartingPosition","getPlayerIndexBasedOnId","players","findIndex","item","randomBetweenRange","min","max","shuffle","o","j","x","parseInt","generateLadders","difficulty","total_ladders","shuffled_array","slice","generateSnakes","total_snakes","calculatePlayerNewPosition","pos","new_pos","getLastCalculatedPlayerPosition","getPlayerPositionCSSStyles","document","getElementById","calculated","top","left","getBoundingClientRect","window","scrollY","padding_left","player","width","array_index","padding_top","output","generateLadderStyle","existing","height","transform","from_tile","to_tile","to_tile_top","from_tile_top","gameboard_top","ladder_position","left_tile","right_tile","margin","tile_css_styles","getLadderTransformStyles","div","tile_count","tile_row_count","rotate_deg","number","styles","generateSnakeStyle","snake_position"],"mappings":"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","sourcesContent":["import config from '../../global/config';\nimport _ from 'lodash';\n\n\nlet mapping = []; // store the tile mappings here, for easier access.\nlet last_calculated_player_details = {};\nlet gameboard; // this will store positions of the gameboard div.\n\nlet all_ladders = [\n\t{ id: 'df4s',  from: 2,   to: 38 },\n\t{ id: 'fgh5',  from: 4,   to: 24 },\n\t{ id: 'io98',  from: 7,   to: 56 },\n\t{ id: 'ajsd',  from: 8,   to: 13 },\n\t{ id: 'dfo4',  from: 10,  to: 30 },\n\t{ id: '12dd',  from: 28,  to: 48 },\n\t{ id: '4sce',  from: 47,  to: 88 },\n\t{ id: 'p98d',  from: 57,  to: 81 },\n\t{ id: 'pwdi',  from: 65,  to: 77 },\n\t{ id: 'pi3u',  from: 71,  to: 91 },\n\t{ id: 'tu83',  from: 70,  to: 86 },\n\t{ id: 'zxs7',  from: 94,  to: 97 },\n\t{ id: 'weu2',  from: 22,  to: 28 },\n];\n\nlet all_snakes = [\n\t{ id: 'sn_1',  from: 25,   to: 9 },\n\t{ id: 'sn_2',  from: 55,   to: 29 },\n\t{ id: 'sn_3',  from: 93,   to: 75 },\n\t{ id: 'sn_4',  from: 99,   to: 58 },\n\t{ id: 'sn_5',  from: 40,   to: 19 },\n\t{ id: 'sn_6',  from: 76,   to: 46 },\n];\n\nlet game_ladders = [];\nlet game_snakes = [];\n\n\n\nlet calculated_ladder_styles = [];\nlet calculated_snake_styles = [];\nlet calculated_player_positions = [];\nlet calculated_perfect_throw_positions = [];\n\n\n\n\n/**\n * calculate the total number of perfect throws required to win this game.\n */\nexport function calculatePerfectThrowsFromPosition( position ) {\n\n\tif( calculated_perfect_throw_positions[position] ) {\n\t\treturn calculated_perfect_throw_positions[position];\n\t}\n\n\tlet max_tiles = 100;\n\tlet current_tile = 1;\n\n\tlet does_this_tile_have_ladder = tileHasLadder(position);\n\tif( does_this_tile_have_ladder ) {\n\t\treturn 'calculating..';\n\t}\n\telse {\n\t\tcurrent_tile = position;\n\t\tlet data = [];\n\n\t\tfor (var i = 0; current_tile <= max_tiles; i++) {\n\t\t\tlet result = runTheLoop( current_tile );\n\t\t\tdata.push({ from: current_tile, dice: result.dice, position: result.position }); // this is so we can display detailed info if required. Not used currently though.\n\t\t\tcurrent_tile = result.position;\n\t\t}\n\n\t\tif( current_tile >= 100 ) {\n\t\t\t// console.log('data',data);\n\t\t\tcalculated_perfect_throw_positions[position] = data.length;\n\t\t\treturn data.length;\n\t\t}\n\n\t}\n\n}\n\n\n\n\n\nconst dice = 6;\n\nfunction runTheLoop( tile ) {\n\tlet ladders = find_ladders_between( tile );\n\tif( ladders ) {\n\t\treturn { dice: ladders.dice, position: ladders.position }\n\t}\n\telse {\n\t\tlet snakes = find_snakes_between( tile );\n\t\treturn { dice: snakes.dice, position: snakes.position }\n\t}\n\n}\n\n\n\n\n\n\nfunction find_ladders_between( tile ) {\n\tlet found_ladders = _.filter( game_ladders, function( ladder ) {\n\t\treturn ladder.from >= tile && ladder.from <= tile+dice;\n\t});\n\n\tlet ladder;\n\tif( found_ladders.length > 1 ) {\n\t\tladder = _.orderBy(found_ladders, [ 'to' ], [ 'desc' ] );\n\t\tladder = ladder[0];\n\t} else { ladder = found_ladders[0]; }\n\n\t// if theres a ladder in between use that, ignore about the snakes... they dont matter.\n\tif( ladder ) {\n\t\treturn { position: ladder.to, dice: ladder.from - tile }\n\t} else { return null; }\n\n}\n\n\nfunction find_snakes_between( tile ) {\n\tlet moves = dice;\n\tlet check = false;\n\n\twhile ( ! check ) {\n\t\tlet snake = _.find( game_snakes, function( snake ) { return snake.from === tile+moves; } );\n\t\tif( snake ) {\n\t\t\tmoves--;\n\t\t} else {\n\t\t\tcheck = true;\n\t\t}\n\t}\n\n\treturn { position: tile+moves, dice: moves }\n}\n\n\nfunction tileHasLadder( tile ) {\n\tlet ladder = _.find( game_ladders, function( ladder ) {\n\t\treturn ladder.from === tile;\n\t});\n\n\tif( ladder ) { return true; }\n\telse { return false; }\n}\n\n\n\n\nexport function generateGameboard() {\n\tconst total_tiles = 100;\n\tconst tile_styles = [ 'yellow', 'white', 'red', 'blue', 'green', 'white', 'red', 'yellow', 'green', 'blue' ];\n\n\tlet tiles = [];\n\tlet temp = [];\n\tlet reverse = false;\n\tlet count = 0;\n\n\tfor ( let i = total_tiles; i > 0; i-- ) {\n\t\tcount++;\n\t\tlet random = Math.floor((Math.random() * 10));\n\n\t\tlet tile = {\n\t\t\tid: i,\n\t\t\ttype: 'normal',\n\t\t\tstyle: tile_styles[random],\n\t\t};\n\n\t\tif( reverse ) {\n\t\t\ttemp.unshift( tile );\n\t\t} else {\n\t\t\ttemp.push( tile );\n\t\t}\n\n\t\tif( count === 10 ) {\n\t\t\treverse = !reverse;\n\t\t\ttiles = tiles.concat(temp);\n\t\t\ttemp = [];\n\t\t\tcount = 0;\n\t\t}\n\n\t}\n\n\t_( tiles ).forEach(function(tile, index) {\n\t\tmapping[tile.id] = index;\n\t});\n\n\treturn tiles;\n\n}\n\n\n\nexport function getPlayerStartingPosition() {\n\treturn mapping[1] || 90;\n}\n\n\nexport function getPlayerIndexBasedOnId( players, id ) {\n\tlet index = players.findIndex( item => { return item.id == id; });\n\treturn index;\n}\n\n\n\n\nexport function randomBetweenRange( min, max ) {\n\treturn Math.floor( Math.random() * (max-min+1) + min );\n}\n\nexport function shuffle( o ) {\n\tfor(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);\n\treturn o;\n};\n\n\nexport function generateLadders( difficulty ) {\n\t// 1: easy, 2: medium, 3: difficult, 4: hell mode\n\tlet total_ladders = 0;\n\n\tif( difficulty === 1 ) {\n\t\ttotal_ladders = randomBetweenRange(8, 10);\n\t}\n\tif( difficulty === 2 ) {\n\t\ttotal_ladders = randomBetweenRange(4, 7);\n\t}\n\tif( difficulty === 3 ) {\n\t\ttotal_ladders = randomBetweenRange(2, 4);\n\t}\n\tif( difficulty === 4 ) {\n\t\ttotal_ladders = randomBetweenRange(0, 1);\n\t}\n\tif( total_ladders === 0 ) {\n\t\treturn [];\n\t}\n\n\tlet shuffled_array = shuffle( all_ladders );\n\tlet ladders = shuffled_array.slice( 0, total_ladders )\n\tgame_ladders = ladders;\n\treturn ladders;\n\n\n}\n\n\n\n\nexport function generateSnakes( difficulty ) {\n\tlet total_snakes = 0;\n\n\tif( difficulty === 1 ) {\n\t\ttotal_snakes = randomBetweenRange(1, 3);\n\t}\n\tif( difficulty === 2 ) {\n\t\ttotal_snakes = randomBetweenRange(3, 5);\n\t}\n\tif( difficulty === 3 ) {\n\t\ttotal_snakes = randomBetweenRange(5, 7);\n\t}\n\tif( difficulty === 4 ) {\n\t\ttotal_snakes = randomBetweenRange(7, 10);\n\t}\n\n\tlet shuffled_array = shuffle( all_snakes );\n\tlet snakes = shuffled_array.slice( 0, total_snakes );\n\tgame_snakes = snakes;\n\treturn snakes;\n\n\n}\n\n\n\nexport function calculatePlayerNewPosition( data ) {\n\tlet pos = data.index + data.moves;\n\tif( pos > 100 ) { pos = 100; }\n\n\tlet new_pos = mapping[pos];\n\n\tlet result = {\n\t\ttile: new_pos,\n\t\tindex: pos,\n\t};\n\n\tlast_calculated_player_details = result;\n\treturn result;\n}\n\n\n\nexport function getLastCalculatedPlayerPosition( data ) {\n\tif( last_calculated_player_details.index ) {\n\t\treturn last_calculated_player_details;\n\t}\n\telse {\n\t\treturn {\n\t\t\tindex: 1\n\t\t}\n\t}\n}\n\n\n\nexport function getPlayerPositionCSSStyles( data ) {\n\tif( data.index > 100 ) { data.index = 100; }\n\n\tif( ! document.getElementById(`tile_${data.index}`) ) {\n\t\tlet calculated = calculated_player_positions[data.id];\n\t\treturn { top: calculated.top, left: calculated.left };\n\t}\n\n\tlet tile = document.getElementById(`tile_${data.index}`).getBoundingClientRect();\n\tlet gameboard = document.getElementById('gameboard').getBoundingClientRect();\n\n\tlet top = tile.top + window.scrollY;\n\tlet left = tile.left;\n\n\ttop = top - ( gameboard.top + window.scrollY );\n\tleft = left - gameboard.left;\n\n\tlet padding_left = config.player.width * data.array_index;\n\tpadding_left = padding_left + 8;\n\tleft = left + padding_left + ( data.array_index * 2 );\n\n\n\tlet padding_top = ( config.tile.width - config.player.width ) / 2;\n\ttop = top + padding_top;\n\n\tlet output = {\n\t\ttop: `${top}px`,\n\t\tleft: `${left}px`,\n\t};\n\n\tcalculated_player_positions[data.id] = output;\n\treturn output;\n\n}\n\n\n\n\nexport function generateLadderStyle( data ) {\n\tlet existing = calculated_ladder_styles[data.id];\n\tif( existing ) {\n\t\treturn {\n\t\t\ttop: existing.top,\n\t\t\tleft: existing.left,\n\t\t\theight: existing.height,\n\t\t\twidth: existing.width,\n\t\t\ttransform: existing.transform || '',\n\t\t};\n\t}\n\n\tlet from_tile = document.getElementById(`tile_${data.from}`).getBoundingClientRect();\n\tlet to_tile = document.getElementById(`tile_${data.to}`).getBoundingClientRect();\n\n\tif( !gameboard ) {\n\t\tgameboard = document.getElementById('gameboard').getBoundingClientRect();\n\t}\n\n\tlet to_tile_top = to_tile.top + window.scrollY;\n\tlet from_tile_top = from_tile.top + window.scrollY;\n\tlet gameboard_top = gameboard.top + window.scrollY;\n\tlet ladder_position = 1;\n\n\tlet left_tile = {};\n\tlet right_tile = {};\n\tif( to_tile.left <= from_tile.left ) {\n\t\tleft_tile = to_tile;\n\t\tright_tile = from_tile;\n\t} else {\n\t\tleft_tile = from_tile;\n\t\tright_tile = to_tile;\n\t}\n\n\tif( to_tile.left < from_tile.left ) { ladder_position = -1; }\n\n\tlet top = to_tile_top - gameboard_top;\n\tlet height = from_tile_top - to_tile_top + ( config.tile.height - config.tile.margin );\n\tlet left = left_tile.left - gameboard.left;\n\tlet width = right_tile.left - left_tile.left - config.tile.margin + config.tile.width;\n\n\tlet tile_css_styles = {\n\t\ttop,\n\t\tleft,\n\t\theight,\n\t\twidth,\n\t\tladder_position\n\t}\n\n\ttile_css_styles = getLadderTransformStyles( tile_css_styles );\n\tcalculated_ladder_styles[data.id] = tile_css_styles;  // store this ladders calculated styles\n\n\treturn tile_css_styles;\n\n}\n\n\n\nexport function getLadderTransformStyles( div ) {\n\tlet tile_count = ( div.width + config.tile.margin ) / config.tile.width;\n\tlet tile_row_count = ( div.height + config.tile.margin ) / config.tile.height;\n\n\tlet rotate_deg = 0;\n\tif( tile_count <= 1 ) { rotate_deg = 0; }\n\telse if( tile_count <= 2 ) {\n\t\tlet number = 7;\n\t\tif( div.ladder_position === 1 ) {\n\t\t\tif( tile_row_count <= 4 ) { number = 10; }\n\t\t} else {\n\t\t\tif( tile_row_count <= 4 ) { number = 20; }\n\t\t}\n\t\trotate_deg = number * tile_count;\n\t}\n\telse if( tile_count < 4 ) { rotate_deg = 7 * tile_count; }\n\n\telse if( tile_count < 5 ) {\n\t\tlet number = 8;\n\t\tif( tile_row_count >= 4 && div.ladder_position != 1 ) { number = 11; }\n\t\trotate_deg = number * tile_count;\n\t}\n\n\telse if( tile_count < 7 ) {\n\t\trotate_deg = 13 * tile_count;\n\t\tdiv.top = div.top - ( 12 * tile_count );\n\t\tdiv.height = div.height + ( 26 * tile_count );\n\t}\n\n\telse { rotate_deg = 7 * tile_count; }\n\n\tif( tile_row_count === 1 ) {\n\t\trotate_deg = 90;\n\t\tdiv.top = div.top - ( (div.width-div.height) / 2 );\n\t\tdiv.height = div.height + ( ( tile_count - 1 ) * config.tile.height );\n\t}\n\n\tlet transform = `rotate(${ rotate_deg * div.ladder_position }deg)`;\n\n\tlet styles = {\n\t\ttop: `${div.top}px`,\n\t\tleft: `${div.left}px`,\n\t\theight: `${div.height}px`,\n\t\twidth: `${div.width}px`,\n\t}\n\tif( transform ) { styles.transform = transform; }\n\n\treturn styles;\n\n}\n\n\n\n\nexport function generateSnakeStyle( data ) {\n\tlet existing = calculated_snake_styles[data.id];\n\tif( existing ) {\n\t\treturn {\n\t\t\ttop: existing.top,\n\t\t\tleft: existing.left,\n\t\t\theight: existing.height,\n\t\t\twidth: existing.width,\n\t\t};\n\t}\n\n\tlet from_tile = document.getElementById(`tile_${data.to}`).getBoundingClientRect();\n\tlet to_tile = document.getElementById(`tile_${data.from}`).getBoundingClientRect();\n\tif( !gameboard ) {\n\t\tgameboard = document.getElementById('gameboard').getBoundingClientRect();\n\t}\n\n\tlet to_tile_top = to_tile.top + window.scrollY;\n\tlet from_tile_top = from_tile.top + window.scrollY;\n\tlet gameboard_top = gameboard.top + window.scrollY;\n\tlet snake_position = -1;\n\n\tlet left_tile = {};\n\tlet right_tile = {};\n\tif( to_tile.left <= from_tile.left ) {\n\t\tleft_tile = to_tile;\n\t\tright_tile = from_tile;\n\t} else {\n\t\tleft_tile = from_tile;\n\t\tright_tile = to_tile;\n\t}\n\n\tif( to_tile.left < from_tile.left ) { snake_position = 1; }\n\n\tlet top = to_tile_top - gameboard_top;\n\tlet height = from_tile_top - to_tile_top + ( config.tile.height - config.tile.margin );\n\tlet left = left_tile.left - gameboard.left;\n\tlet width = right_tile.left - left_tile.left - config.tile.margin + config.tile.width;\n\n\n\tlet tile_css_styles = {\n\t\ttop: `${top}px`,\n\t\tleft: `${left}px`,\n\t\theight: `${height}px`,\n\t\twidth: `${width}px`,\n\t}\n\n\tif( snake_position === -1 ) {\n\t\tlet tile_count = ( width + config.tile.margin ) / config.tile.width;\n\t\ttile_css_styles.transform = `rotate(${ tile_count * 30  }deg)`;\n\t}\n\n\n\tcalculated_snake_styles[data.id] = tile_css_styles; // store this snake's calculated styles\n\n\n\n\treturn tile_css_styles;\n\n}\n\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}