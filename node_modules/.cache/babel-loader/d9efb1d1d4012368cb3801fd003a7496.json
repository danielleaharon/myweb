{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nexport class TypedArrayManager {\n  constructor(options = {}) {\n    _defineProperty(this, \"_pool\", []);\n\n    _defineProperty(this, \"opts\", {\n      overAlloc: 2,\n      poolSize: 100\n    });\n\n    this.setOptions(options);\n  }\n\n  setOptions(options) {\n    Object.assign(this.opts, options);\n  }\n\n  allocate(typedArray, count, {\n    size = 1,\n    type,\n    padding = 0,\n    copy = false,\n    initialize = false,\n    maxCount\n  }) {\n    const Type = type || typedArray && typedArray.constructor || Float32Array;\n    const newSize = count * size + padding;\n\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize);\n      }\n    }\n\n    let maxSize = Infinity;\n\n    if (maxCount) {\n      maxSize = maxCount * size + padding;\n    }\n\n    const newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n\n    return newArray;\n  }\n\n  release(typedArray) {\n    this._release(typedArray);\n  }\n\n  _allocate(Type, size, initialize, maxSize) {\n    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);\n\n    if (sizeToAllocate > maxSize) {\n      sizeToAllocate = maxSize;\n    }\n\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n\n    if (i >= 0) {\n      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n\n      if (initialize) {\n        array.fill(0);\n      }\n\n      return array;\n    }\n\n    return new Type(sizeToAllocate);\n  }\n\n  _release(typedArray) {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n\n    const pool = this._pool;\n    const {\n      buffer\n    } = typedArray;\n    const {\n      byteLength\n    } = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.opts.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n\n    if (pool.length > this.opts.poolSize) {\n      pool.shift();\n    }\n  }\n\n}\nexport default new TypedArrayManager();","map":{"version":3,"sources":["../../../src/utils/typed-array-manager.ts"],"names":["overAlloc","poolSize","constructor","options","setOptions","Object","allocate","size","padding","copy","initialize","maxCount","Type","type","typedArray","newSize","count","ArrayBuffer","maxSize","newArray","release","_allocate","sizeToAllocate","Math","pool","byteLength","i","b","array","_release","buffer"],"mappings":"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","sourcesContent":["import {TypedArray, TypedArrayConstructor} from '../types/types';\n\nexport type TypedArrayManagerOptions = {\n  overAlloc?: number;\n  poolSize?: number;\n};\n\nexport class TypedArrayManager {\n  private _pool: ArrayBuffer[] = [];\n  opts: {\n    overAlloc: number;\n    poolSize: number;\n  } = {overAlloc: 2, poolSize: 100};\n\n  constructor(options: TypedArrayManagerOptions = {}) {\n    this.setOptions(options);\n  }\n\n  setOptions(options: TypedArrayManagerOptions) {\n    Object.assign(this.opts, options);\n  }\n\n  allocate<T extends TypedArray>(\n    typedArray: T | null | undefined,\n    count: number,\n    {\n      size = 1,\n      type,\n      padding = 0,\n      copy = false,\n      initialize = false,\n      maxCount\n    }: {\n      size?: number;\n      type?: TypedArrayConstructor;\n      padding?: number;\n      copy?: boolean;\n      initialize?: boolean;\n      maxCount?: number;\n    }\n  ): T {\n    const Type =\n      type || (typedArray && (typedArray.constructor as TypedArrayConstructor)) || Float32Array;\n\n    const newSize = count * size + padding;\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize) as T;\n      }\n    }\n\n    let maxSize: number = Infinity;\n    if (maxCount) {\n      maxSize = maxCount * size + padding;\n    }\n\n    const newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      // Hack - always initialize the first 4 elements. NaNs crash the Attribute validation\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n    return newArray as T;\n  }\n\n  release(typedArray: TypedArray | null | undefined) {\n    this._release(typedArray);\n  }\n\n  private _allocate(\n    Type: TypedArrayConstructor,\n    size: number,\n    initialize: boolean,\n    maxSize: number\n  ): TypedArray {\n    // Allocate at least one element to ensure a valid buffer\n    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);\n    // Don't over allocate after certain specified number of elements\n    if (sizeToAllocate > maxSize) {\n      sizeToAllocate = maxSize;\n    }\n\n    // Check if available in pool\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i >= 0) {\n      // Create a new array using an existing buffer\n      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n      if (initialize) {\n        // Viewing a buffer with a different type may create NaNs\n        array.fill(0);\n      }\n      return array;\n    }\n    return new Type(sizeToAllocate);\n  }\n\n  private _release(typedArray: TypedArray | null | undefined): void {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n    const pool = this._pool;\n    const {buffer} = typedArray;\n    // Save the buffer of the released array into the pool\n    // Sort buffers by size\n    // TODO - implement binary search?\n    const {byteLength} = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.opts.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n    if (pool.length > this.opts.poolSize) {\n      // Drop the smallest one\n      pool.shift();\n    }\n  }\n}\n\nexport default new TypedArrayManager();\n"]},"metadata":{},"sourceType":"module"}