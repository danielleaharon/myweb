{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/webgl';\nexport default class Tesselator {\n  constructor(opts) {\n    _defineProperty(this, \"opts\", void 0);\n\n    _defineProperty(this, \"typedArrayManager\", void 0);\n\n    _defineProperty(this, \"indexStarts\", [0]);\n\n    _defineProperty(this, \"vertexStarts\", [0]);\n\n    _defineProperty(this, \"vertexCount\", 0);\n\n    _defineProperty(this, \"instanceCount\", 0);\n\n    _defineProperty(this, \"attributes\", void 0);\n\n    _defineProperty(this, \"_attributeDefs\", void 0);\n\n    _defineProperty(this, \"data\", void 0);\n\n    _defineProperty(this, \"getGeometry\", void 0);\n\n    _defineProperty(this, \"geometryBuffer\", void 0);\n\n    _defineProperty(this, \"buffers\", void 0);\n\n    _defineProperty(this, \"positionSize\", void 0);\n\n    _defineProperty(this, \"normalize\", void 0);\n\n    const {\n      attributes = {}\n    } = opts;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n  }\n\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    if (geometryBuffer) {\n      assert(data.startIndices);\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        buffers.positions = geometryBuffer;\n      }\n    }\n\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({\n    startRow,\n    endRow\n  }) {\n    this._rebuildGeometry({\n      startRow,\n      endRow\n    });\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n\n    if (!ArrayBuffer.isView(value)) {\n      return null;\n    }\n\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  _allocate(instanceCount, copy) {\n    const {\n      attributes,\n      buffers,\n      _attributeDefs,\n      typedArrayManager\n    } = this;\n\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        def.copy = copy;\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {\n      data,\n      getGeometry\n    } = this;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  _rebuildGeometry(dataRange) {\n    if (!this.data) {\n      return;\n    }\n\n    let {\n      indexStarts,\n      vertexStarts,\n      instanceCount\n    } = this;\n    const {\n      data,\n      geometryBuffer\n    } = this;\n    const {\n      startRow = 0,\n      endRow = Infinity\n    } = dataRange || {};\n    const normalizedData = {};\n\n    if (!dataRange) {\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry((geometry, dataIndex) => {\n        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n        normalizedData[dataIndex] = normalizedGeometry;\n        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n      }, startRow, endRow);\n\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n    const context = {};\n\n    this._forEachGeometry((geometry, dataIndex) => {\n      const normalizedGeometry = normalizedData[dataIndex] || geometry;\n      context.vertexStart = vertexStarts[dataIndex];\n      context.indexStart = indexStarts[dataIndex];\n      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n      context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n      context.geometryIndex = dataIndex;\n      this.updateGeometryAttributes(normalizedGeometry, context);\n    }, startRow, endRow);\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n\n}","map":{"version":3,"sources":["../../../src/utils/tesselator.ts"],"names":["constructor","attributes","updateGeometry","Object","buffers","normalize","geometryBuffer","positionFormat","assert","data","Array","updatePartialGeometry","endRow","getGeometryFromBuffer","value","ArrayBuffer","getAccessorFromBuffer","size","offset","stride","startIndices","_allocate","typedArrayManager","name","def","_attributeDefs","_forEachGeometry","getGeometry","objectInfo","createIterable","geometry","visitor","_rebuildGeometry","instanceCount","startRow","Infinity","dataRange","normalizedData","indexStarts","vertexStarts","normalizedGeometry","dataIndex","byteStride","bufferValue","elementStride","Boolean","context","vertexEnd"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/webgl';\n\nimport type {BinaryAttribute} from '../lib/attribute/attribute';\nimport type {TypedArray} from '../types/types';\nimport type {AccessorFunction} from '../types/layer-props';\nimport type {TypedArrayManager} from './typed-array-manager';\n\ntype ExternalBuffer = TypedArray | Buffer | BinaryAttribute;\n\ntype TesselatorOptions<GeometryT, ExtraOptionsT> = ExtraOptionsT & {\n  attributes?: Record<string, any>;\n  getGeometry?: AccessorFunction<any, GeometryT>;\n  data?: any;\n  buffers?: Record<string, ExternalBuffer>;\n  geometryBuffer?: ExternalBuffer;\n  positionFormat?: 'XY' | 'XYZ';\n  dataChanged?: {startRow: number; endRow?: number}[] | string | false;\n  normalize?: boolean;\n};\n\nexport type GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\nexport default abstract class Tesselator<GeometryT, NormalizedGeometryT, ExtraOptionsT> {\n  opts: TesselatorOptions<GeometryT, ExtraOptionsT>;\n  typedArrayManager: TypedArrayManager;\n  indexStarts: number[] = [0];\n  vertexStarts: number[] = [0];\n  vertexCount: number = 0;\n  instanceCount: number = 0;\n  attributes: Record<string, TypedArray | null>;\n\n  protected _attributeDefs: any;\n  protected data: any;\n  protected getGeometry?: AccessorFunction<any, GeometryT> | null;\n  protected geometryBuffer?: ExternalBuffer;\n  protected buffers!: Record<string, ExternalBuffer>;\n  protected positionSize!: number;\n  protected normalize!: boolean;\n\n  constructor(opts: TesselatorOptions<GeometryT, ExtraOptionsT>) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n  }\n\n  /* Public methods */\n  updateGeometry(opts: TesselatorOptions<GeometryT, ExtraOptionsT>): void {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged as {startRow: number; endRow?: number}[]) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}: {startRow: number; endRow: number}): void {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  // Subclass interface\n\n  /** Convert geometry to a uniform shape */\n  protected abstract normalizeGeometry(geometry: GeometryT): NormalizedGeometryT;\n\n  /** Update the positions buffer of a single geometry */\n  protected abstract updateGeometryAttributes(\n    geometry: NormalizedGeometryT | null,\n    context: GeometryUpdateContext\n  );\n\n  /** Get the number of vertices in a geometry */\n  protected abstract getGeometrySize(geometry: NormalizedGeometryT): number;\n\n  protected getGeometryFromBuffer(\n    geometryBuffer: ExternalBuffer\n  ): AccessorFunction<any, GeometryT> | null {\n    const value = (geometryBuffer as BinaryAttribute).value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      // Cannot read binary geometries\n      return null;\n    }\n\n    // @ts-ignore (2322) NumericArray not assignable to GeometryT\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: (geometryBuffer as BinaryAttribute).offset,\n      stride: (geometryBuffer as BinaryAttribute).stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  private _allocate(instanceCount: number, copy: boolean): void {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  private _forEachGeometry(\n    visitor: (geometry: GeometryT | null, index: number) => void,\n    startRow: number,\n    endRow: number\n  ): void {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  private _rebuildGeometry(dataRange?: {startRow: number; endRow?: number}): void {\n    if (!this.data) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData: Record<number, NormalizedGeometryT | null> = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry: GeometryT | null, dataIndex: number) => {\n          const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = normalizedGeometry;\n          vertexStarts[dataIndex + 1] =\n            vertexStarts[dataIndex] +\n            (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        // @ts-expect-error (2339) accessor is not typed\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride =\n          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    // @ts-ignore (2739) context will be populated in the loop\n    const context: GeometryUpdateContext = {};\n\n    this._forEachGeometry(\n      (geometry: GeometryT | null, dataIndex: number) => {\n        const normalizedGeometry =\n          normalizedData[dataIndex] ||\n          // @ts-expect-error (2352) GeometryT cannot be casted to NormalizedGeometryT. We are assuming the user passed already normalized data if opts.normalize is set to false.\n          (geometry as NormalizedGeometryT);\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(normalizedGeometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}