{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport { createIterable, getAccessorFromBuffer } from '../../utils/iterable-utils';\nimport { fillArray } from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport { normalizeTransitionSettings } from './attribute-transition-utils';\nexport default class Attribute extends DataColumn {\n  constructor(gl, opts) {\n    super(gl, opts, {\n      startIndices: null,\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL\n    });\n\n    _defineProperty(this, \"constant\", false);\n\n    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices() {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({\n    clearChangedFlags = false\n  } = {}) {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers() {\n    const {\n      accessor\n    } = this.settings;\n    return [this.id].concat(typeof accessor !== 'function' && accessor || []);\n  }\n\n  supportsTransition() {\n    return Boolean(this.settings.transition);\n  }\n\n  getTransitionSetting(opts) {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n\n    const {\n      accessor\n    } = this.settings;\n    const layerSettings = this.settings.transition;\n    const userSettings = Array.isArray(accessor) ? opts[accessor.find(a => opts[a])] : opts[accessor];\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason = this.id, dataRange) {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n\n    if (dataRange) {\n      const {\n        startRow = 0,\n        endRow = Infinity\n      } = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate() {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw(reason = this.id) {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  allocate(numInstances) {\n    const {\n      state,\n      settings\n    } = this;\n\n    if (settings.noAlloc) {\n      return false;\n    }\n\n    if (settings.update) {\n      super.allocate(numInstances, state.updateRanges !== range.FULL);\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({\n    numInstances,\n    data,\n    props,\n    context\n  }) {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {\n        updateRanges\n      },\n      settings: {\n        update,\n        noAlloc\n      }\n    } = this;\n    let updated = true;\n\n    if (update) {\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {\n          data,\n          startRow,\n          endRow,\n          props,\n          numInstances\n        });\n      }\n\n      if (!this.value) {} else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;\n          super.updateSubBuffer({\n            startOffset,\n            endOffset\n          });\n        }\n      }\n\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n    return updated;\n  }\n\n  setConstantValue(value) {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({\n      constant: true,\n      value\n    });\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  setExternalBuffer(buffer) {\n    const {\n      state\n    } = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  setBinaryValue(buffer, startIndices = null) {\n    const {\n      state,\n      settings\n    } = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {\n          value: buffer\n        };\n      }\n\n      const binaryValue = buffer;\n      assert(ArrayBuffer.isView(binaryValue.value), \"invalid \".concat(settings.accessor));\n      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;\n      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {\n        size: binaryValue.size || this.size,\n        stride: binaryValue.stride,\n        offset: binaryValue.offset,\n        startIndices: startIndices,\n        nested: needsNormalize\n      });\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row) {\n    const {\n      startIndices\n    } = this;\n    const vertexIndex = startIndices ? startIndices[row] : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes() {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {\n      [this.id]: null\n    };\n    const shaderAttributes = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));\n    }\n\n    return shaderAttributes;\n  }\n\n  _autoUpdater(attribute, {\n    data,\n    startRow,\n    endRow,\n    props,\n    numInstances\n  }) {\n    if (attribute.constant) {\n      return;\n    }\n\n    const {\n      settings,\n      state,\n      value,\n      size,\n      startIndices\n    } = attribute;\n    const {\n      accessor,\n      transform\n    } = settings;\n    const accessorFunc = state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n    assert(typeof accessorFunc === 'function', \"accessor \\\"\".concat(accessor, \"\\\" is not a function\"));\n    let i = attribute.getVertexOffset(startRow);\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      let objectValue = accessorFunc(object, objectInfo);\n\n      if (transform) {\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];\n\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value, startIndex);\n\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          value.set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value, i);\n\n        i += size;\n      }\n    }\n  }\n\n  _validateAttributeUpdaters() {\n    const {\n      settings\n    } = this;\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n\n    if (!hasUpdater) {\n      throw new Error(\"Attribute \".concat(this.id, \" missing update or accessor\"));\n    }\n  }\n\n  _checkAttributeArray() {\n    const {\n      value\n    } = this;\n    const limit = Math.min(4, this.size);\n\n    if (value && value.length >= limit) {\n      let valid = true;\n\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(\"Illegal attribute generated for \".concat(this.id));\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../../src/lib/attribute/attribute.ts"],"names":["constructor","startIndices","lastExternalBuffer","binaryValue","binaryAccessor","needsUpdate","needsRedraw","updateRanges","range","FULL","opts","Object","clearChangedFlags","getUpdateTriggers","accessor","supportsTransition","Boolean","getTransitionSetting","layerSettings","userSettings","Array","a","normalizeTransitionSettings","setNeedsUpdate","reason","startRow","endRow","Infinity","clearNeedsUpdate","setNeedsRedraw","allocate","settings","state","updateBuffer","context","noAlloc","updated","update","numInstances","value","constant","startOffset","Number","endOffset","setConstantValue","hasChanged","setExternalBuffer","setBinaryValue","ArrayBuffer","buffer","assert","needsNormalize","getAccessorFromBuffer","size","stride","offset","nested","getVertexOffset","vertexIndex","getShaderAttributes","shaderAttributeDefs","shaderAttributes","_autoUpdater","attribute","transform","accessorFunc","props","i","objectInfo","createIterable","objectValue","numVertices","startIndex","fillArray","target","source","start","count","_validateAttributeUpdaters","hasUpdater","_checkAttributeArray","limit","Math","valid"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport DataColumn, {DataColumnOptions, ShaderAttributeOptions, BufferAccessor} from './data-column';\nimport {IShaderAttribute} from './shader-attribute';\nimport assert from '../../utils/assert';\nimport {createIterable, getAccessorFromBuffer} from '../../utils/iterable-utils';\nimport {fillArray} from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport {normalizeTransitionSettings, TransitionSettings} from './attribute-transition-utils';\nimport type {Buffer} from '@luma.gl/webgl';\n\nimport type {NumericArray, TypedArray} from '../../types/types';\n\nexport type Accessor<DataType, ReturnType> = (\n  object: DataType,\n  context: {\n    data: any;\n    index: number;\n    target: number[];\n  }\n) => ReturnType;\n\nexport type Updater = (\n  attribute: Attribute,\n  {\n    data,\n    startRow,\n    endRow,\n    props,\n    numInstances\n  }: {\n    data: any;\n    startRow: number;\n    endRow: number;\n    props: any;\n    numInstances: number;\n  }\n) => void;\n\nexport type AttributeOptions = DataColumnOptions<{\n  transition?: boolean | Partial<TransitionSettings>;\n  noAlloc?: boolean;\n  update?: Updater;\n  accessor?: Accessor<any, any> | string | string[];\n  transform?: (value: any) => any;\n  shaderAttributes?: Record<string, Partial<ShaderAttributeOptions>>;\n}>;\n\nexport type BinaryAttribute = Partial<BufferAccessor> & {value?: TypedArray; buffer?: Buffer};\n\ntype AttributeInternalState = {\n  startIndices: NumericArray | null;\n  /** Legacy: external binary supplied via attribute name */\n  lastExternalBuffer: TypedArray | Buffer | BinaryAttribute | null;\n  /** External binary supplied via accessor name */\n  binaryValue: TypedArray | Buffer | BinaryAttribute | null;\n  binaryAccessor: Accessor<any, any> | null;\n  needsUpdate: string | boolean;\n  needsRedraw: string | boolean;\n  updateRanges: number[][];\n};\n\nexport default class Attribute extends DataColumn<AttributeOptions, AttributeInternalState> {\n  /** Legacy approach to set attribute value - read `isConstant` instead for attribute state */\n  constant: boolean = false;\n\n  constructor(gl: WebGLRenderingContext, opts: AttributeOptions) {\n    super(gl, opts, {\n      startIndices: null,\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL\n    });\n\n    // eslint-disable-next-line\n    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);\n\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices(): NumericArray | null {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout: NumericArray | null) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate(): string | boolean {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({clearChangedFlags = false}: {clearChangedFlags?: boolean} = {}): string | boolean {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers(): string[] {\n    const {accessor} = this.settings;\n\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat((typeof accessor !== 'function' && accessor) || []);\n  }\n\n  supportsTransition(): boolean {\n    return Boolean(this.settings.transition);\n  }\n\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts: Record<string, any>): TransitionSettings | null {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n    const {accessor} = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor)\n      ? // @ts-ignore\n        opts[accessor.find(a => opts[a])]\n      : // @ts-ignore\n        opts[accessor];\n\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason: string = this.id, dataRange?: {startRow?: number; endRow?: number}): void {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {startRow = 0, endRow = Infinity} = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate(): void {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw(reason: string = this.id): void {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  allocate(numInstances: number): boolean {\n    const {state, settings} = this;\n\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n\n    if (settings.update) {\n      super.allocate(numInstances, state.updateRanges !== range.FULL);\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({\n    numInstances,\n    data,\n    props,\n    context\n  }: {\n    numInstances: number;\n    data: any;\n    props: any;\n    context: any;\n  }): boolean {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {updateRanges},\n      settings: {update, noAlloc}\n    } = this;\n\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {data, startRow, endRow, props, numInstances});\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (\n        this.constant ||\n        this.buffer.byteLength < (this.value as TypedArray).byteLength + this.byteOffset\n      ) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        // Setting attribute.constant in updater is a legacy approach that interferes with allocation in the next cycle\n        // Respect it here but reset after use\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow)\n            ? this.getVertexOffset(endRow)\n            : noAlloc || !Number.isFinite(numInstances)\n            ? this.value.length\n            : numInstances * this.size;\n\n          super.updateSubBuffer({startOffset, endOffset});\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n\n    return updated;\n  }\n\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value?: NumericArray): boolean {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({constant: true, value});\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer?: TypedArray | Buffer | BinaryAttribute): boolean {\n    const {state} = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(\n    buffer?: TypedArray | Buffer | BinaryAttribute,\n    startIndices: NumericArray | null = null\n  ): boolean {\n    const {state, settings} = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {value: buffer};\n      }\n      const binaryValue = buffer as BinaryAttribute;\n      assert(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);\n      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;\n\n      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {\n        size: binaryValue.size || this.size,\n        stride: binaryValue.stride,\n        offset: binaryValue.offset,\n        startIndices: startIndices as NumericArray,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row: number): number {\n    const {startIndices} = this;\n    const vertexIndex = startIndices ? startIndices[row] : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes(): Record<string, IShaderAttribute> {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {[this.id]: null};\n    const shaderAttributes: Record<string, IShaderAttribute> = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(\n        shaderAttributes,\n        super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])\n      );\n    }\n\n    return shaderAttributes;\n  }\n\n  /* eslint-disable max-depth, max-statements */\n  private _autoUpdater(\n    attribute: Attribute,\n    {\n      data,\n      startRow,\n      endRow,\n      props,\n      numInstances\n    }: {\n      data: any;\n      startRow: number;\n      endRow: number;\n      props: any;\n      numInstances: number;\n    }\n  ): void {\n    if (attribute.constant) {\n      return;\n    }\n    const {settings, state, value, size, startIndices} = attribute;\n\n    const {accessor, transform} = settings;\n    const accessorFunc: Accessor<any, any> =\n      state.binaryAccessor ||\n      // @ts-ignore\n      (typeof accessor === 'function' ? accessor : props[accessor]);\n\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let i = attribute.getVertexOffset(startRow);\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices =\n          (objectInfo.index < startIndices.length - 1\n            ? startIndices[objectInfo.index + 1]\n            : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value as TypedArray, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          (value as TypedArray).set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value as TypedArray, i);\n        i += size;\n      }\n    }\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  // Validate deck.gl level fields\n  private _validateAttributeUpdaters() {\n    const {settings} = this;\n\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  private _checkAttributeArray() {\n    const {value} = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n  /* eslint-enable no-fallthrough */\n}\n"]},"metadata":{},"sourceType":"module"}