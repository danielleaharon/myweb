{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Framebuffer, Texture2D, isWebGL2, readPixelsToArray, cssToDeviceRatio, cssToDevicePixels } from '@luma.gl/core';\nimport PickLayersPass from '../passes/pick-layers-pass';\nimport { getClosestObject, getUniqueObjects } from './picking/query-object';\nimport { processPickInfo, getLayerPickingInfo, getEmptyPickingInfo } from './picking/pick-info';\nexport default class DeckPicker {\n  constructor(gl) {\n    _defineProperty(this, \"gl\", void 0);\n\n    _defineProperty(this, \"pickingFBO\", void 0);\n\n    _defineProperty(this, \"depthFBO\", void 0);\n\n    _defineProperty(this, \"pickLayersPass\", void 0);\n\n    _defineProperty(this, \"layerFilter\", void 0);\n\n    _defineProperty(this, \"lastPickedInfo\", void 0);\n\n    _defineProperty(this, \"_pickable\", true);\n\n    this.gl = gl;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n\n  setProps(props) {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n\n    if ('_pickable' in props) {\n      this._pickable = props._pickable;\n    }\n  }\n\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.delete();\n    }\n\n    if (this.depthFBO) {\n      this.depthFBO.color.delete();\n      this.depthFBO.delete();\n    }\n  }\n\n  pickObject(opts) {\n    return this._pickClosestObject(opts);\n  }\n\n  pickObjects(opts) {\n    return this._pickVisibleObjects(opts);\n  }\n\n  getLastPickedObject({\n    x,\n    y,\n    layers,\n    viewports\n  }, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const viewport = lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId) || viewports[0];\n    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n    const info = {\n      x,\n      y,\n      viewport,\n      coordinate,\n      layer\n    };\n    return { ...lastPickedInfo,\n      ...info\n    };\n  }\n\n  _resizeBuffer() {\n    var _this$pickingFBO, _this$depthFBO;\n\n    const {\n      gl\n    } = this;\n\n    if (!this.pickingFBO) {\n      this.pickingFBO = new Framebuffer(gl);\n\n      if (Framebuffer.isSupported(gl, {\n        colorBufferFloat: true\n      })) {\n        const depthFBO = new Framebuffer(gl);\n        depthFBO.attach({\n          [36064]: new Texture2D(gl, {\n            format: isWebGL2(gl) ? 34836 : 6408,\n            type: 5126\n          })\n        });\n        this.depthFBO = depthFBO;\n      }\n    }\n\n    (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 ? void 0 : _this$pickingFBO.resize({\n      width: gl.canvas.width,\n      height: gl.canvas.height\n    });\n    (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 ? void 0 : _this$depthFBO.resize({\n      width: gl.canvas.width,\n      height: gl.canvas.height\n    });\n  }\n\n  _getPickable(layers) {\n    if (this._pickable === false) {\n      return null;\n    }\n\n    const pickableLayers = layers.filter(layer => layer.isPickable() && !layer.isComposite);\n    return pickableLayers.length ? pickableLayers : null;\n  }\n\n  _pickClosestObject({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = 'query',\n    unproject3D,\n    onViewportActive,\n    effects\n  }) {\n    const pickableLayers = this._getPickable(layers);\n\n    const pixelRatio = cssToDeviceRatio(this.gl);\n\n    if (!pickableLayers) {\n      return {\n        result: [],\n        emptyInfo: getEmptyPickingInfo({\n          viewports,\n          x,\n          y,\n          pixelRatio\n        })\n      };\n    }\n\n    this._resizeBuffer();\n\n    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n    const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {\n      width,\n      height\n    } = this.pickingFBO;\n\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n\n    const cullRect = {\n      x: x - radius,\n      y: y - radius,\n      width: radius * 2 + 1,\n      height: radius * 2 + 1\n    };\n    let infos;\n    const result = [];\n    const affectedLayers = new Set();\n\n    for (let i = 0; i < depth; i++) {\n      let pickInfo;\n\n      if (deviceRect) {\n        const pickedResult = this._drawAndSample({\n          layers: pickableLayers,\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          cullRect,\n          effects,\n          pass: \"picking:\".concat(mode)\n        });\n\n        pickInfo = getClosestObject({ ...pickedResult,\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius,\n          deviceRect\n        });\n      } else {\n        pickInfo = {\n          pickedColor: null,\n          pickedObjectIndex: -1\n        };\n      }\n\n      let z;\n\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const pickedResultPass2 = this._drawAndSample({\n          layers: [pickInfo.pickedLayer],\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect: {\n            x: pickInfo.pickedX,\n            y: pickInfo.pickedY,\n            width: 1,\n            height: 1\n          },\n          cullRect,\n          effects,\n          pass: \"picking:\".concat(mode, \":z\")\n        }, true);\n\n        z = pickedResultPass2.pickedColors[0];\n      }\n\n      if (pickInfo.pickedLayer && i + 1 < depth) {\n        affectedLayers.add(pickInfo.pickedLayer);\n        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n      }\n\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers: pickableLayers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n\n    for (const layer of affectedLayers) {\n      layer.restorePickingColors();\n    }\n\n    return {\n      result,\n      emptyInfo: infos.get(null)\n    };\n  }\n\n  _pickVisibleObjects({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = 'query',\n    maxObjects = null,\n    onViewportActive,\n    effects\n  }) {\n    const pickableLayers = this._getPickable(layers);\n\n    if (!pickableLayers) {\n      return [];\n    }\n\n    this._resizeBuffer();\n\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const leftTop = cssToDevicePixels(this.gl, [x, y], true);\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n\n    const pickedResult = this._drawAndSample({\n      layers: pickableLayers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect: {\n        x,\n        y,\n        width,\n        height\n      },\n      effects,\n      pass: \"picking:\".concat(mode)\n    });\n\n    const pickInfos = getUniqueObjects(pickedResult);\n    const uniqueInfos = new Map();\n    const isMaxObjects = Number.isFinite(maxObjects);\n\n    for (let i = 0; i < pickInfos.length; i++) {\n      if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {\n        break;\n      }\n\n      const pickInfo = pickInfos[i];\n      let info = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        pixelRatio\n      };\n      info = getLayerPickingInfo({\n        layer: pickInfo.pickedLayer,\n        info,\n        mode\n      });\n\n      if (!uniqueInfos.has(info.object)) {\n        uniqueInfos.set(info.object, info);\n      }\n    }\n\n    return Array.from(uniqueInfos.values());\n  }\n\n  _drawAndSample({\n    layers,\n    views,\n    viewports,\n    onViewportActive,\n    deviceRect,\n    cullRect,\n    effects,\n    pass\n  }, pickZ = false) {\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n    const {\n      decodePickingColor\n    } = this.pickLayersPass.render({\n      layers,\n      layerFilter: this.layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      cullRect,\n      effects,\n      pass,\n      pickZ\n    });\n    const {\n      x,\n      y,\n      width,\n      height\n    } = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    readPixelsToArray(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n    return {\n      pickedColors,\n      decodePickingColor\n    };\n  }\n\n  _getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth,\n    deviceHeight\n  }) {\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n\n    return {\n      x,\n      y,\n      width,\n      height\n    };\n  }\n\n}","map":{"version":3,"sources":["../../../src/lib/deck-picker.ts"],"names":["constructor","index","layerId","info","setProps","props","finalize","pickObject","pickObjects","getLastPickedObject","viewports","lastPickedInfo","lastPickedLayerId","lastPickedViewportId","layer","layers","l","viewport","v","coordinate","x","y","_resizeBuffer","gl","colorBufferFloat","depthFBO","format","isWebGL2","type","width","height","_getPickable","pickableLayers","_pickClosestObject","radius","depth","mode","effects","pixelRatio","cssToDeviceRatio","result","emptyInfo","getEmptyPickingInfo","devicePixelRange","cssToDevicePixels","devicePixel","Math","deviceRadius","deviceRect","deviceX","deviceY","deviceWidth","deviceHeight","cullRect","affectedLayers","i","pickedResult","pass","pickInfo","getClosestObject","pickedColor","pickedObjectIndex","pickedResultPass2","z","infos","processPickInfo","_pickVisibleObjects","maxObjects","leftTop","deviceLeft","deviceTop","rightBottom","deviceRight","deviceBottom","pickInfos","getUniqueObjects","uniqueInfos","isMaxObjects","Number","color","picked","getLayerPickingInfo","Array","_drawAndSample","pickZ","pickingFBO","decodePickingColor","layerFilter","pickedColors","readPixelsToArray","sourceX","sourceY","sourceWidth","sourceHeight","target","_getPickingRect"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Framebuffer,\n  Texture2D,\n  isWebGL2,\n  readPixelsToArray,\n  cssToDeviceRatio,\n  cssToDevicePixels\n} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport PickLayersPass, {PickingColorDecoder} from '../passes/pick-layers-pass';\nimport {getClosestObject, getUniqueObjects, PickedPixel} from './picking/query-object';\nimport {\n  processPickInfo,\n  getLayerPickingInfo,\n  getEmptyPickingInfo,\n  PickingInfo\n} from './picking/pick-info';\n\nimport type {Framebuffer as LumaFramebuffer} from '@luma.gl/webgl';\nimport type {FilterContext, Rect} from '../passes/layers-pass';\nimport type Layer from './layer';\nimport type {Effect} from './effect';\nimport type View from '../views/view';\nimport type Viewport from '../viewports/viewport';\n\nexport type PickByPointOptions = {\n  x: number;\n  y: number;\n  radius?: number;\n  depth?: number;\n  mode?: string;\n  unproject3D?: boolean;\n};\n\nexport type PickByRectOptions = {\n  x: number;\n  y: number;\n  width?: number;\n  height?: number;\n  mode?: string;\n  maxObjects?: number | null;\n};\n\ntype PickOperationContext = {\n  layers: Layer[];\n  views: Record<string, View>;\n  viewports: Viewport[];\n  onViewportActive: (viewport: Viewport) => void;\n  effects: Effect[];\n};\n\n/** Manages picking in a Deck context */\nexport default class DeckPicker {\n  gl: WebGLRenderingContext;\n  pickingFBO?: LumaFramebuffer;\n  depthFBO?: LumaFramebuffer;\n  pickLayersPass: PickLayersPass;\n  layerFilter?: (context: FilterContext) => boolean;\n\n  /** Identifiers of the previously picked object, for callback tracking and auto highlight */\n  lastPickedInfo: {\n    index: number;\n    layerId: string | null;\n    info: PickingInfo | null;\n  };\n\n  _pickable: boolean = true;\n\n  constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n\n  setProps(props: any): void {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n\n    if ('_pickable' in props) {\n      this._pickable = props._pickable;\n    }\n  }\n\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.delete();\n    }\n    if (this.depthFBO) {\n      this.depthFBO.color.delete();\n      this.depthFBO.delete();\n    }\n  }\n\n  /** Pick the closest info at given coordinate */\n  pickObject(opts: PickByPointOptions & PickOperationContext) {\n    return this._pickClosestObject(opts);\n  }\n\n  /** Get all unique infos within a bounding box */\n  pickObjects(opts: PickByRectOptions & PickOperationContext) {\n    return this._pickVisibleObjects(opts);\n  }\n\n  // Returns a new picking info object by assuming the last picked object is still picked\n  getLastPickedObject({x, y, layers, viewports}, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const lastPickedViewportId =\n      lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const viewport =\n      (lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId)) || viewports[0];\n    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n\n    const info = {\n      x,\n      y,\n      viewport,\n      coordinate,\n      layer\n    };\n\n    return {...lastPickedInfo, ...info};\n  }\n\n  // Private\n\n  /** Ensures that picking framebuffer exists and matches the canvas size */\n  _resizeBuffer() {\n    const {gl} = this;\n\n    // Create a frame buffer if not already available\n    if (!this.pickingFBO) {\n      this.pickingFBO = new Framebuffer(gl);\n\n      if (Framebuffer.isSupported(gl, {colorBufferFloat: true})) {\n        const depthFBO = new Framebuffer(gl);\n        depthFBO.attach({\n          [GL.COLOR_ATTACHMENT0]: new Texture2D(gl, {\n            format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n            type: GL.FLOAT\n          })\n        });\n        this.depthFBO = depthFBO;\n      }\n    }\n    // Resize it to current canvas size (this is a noop if size hasn't changed)\n    this.pickingFBO?.resize({width: gl.canvas.width, height: gl.canvas.height});\n    this.depthFBO?.resize({width: gl.canvas.width, height: gl.canvas.height});\n  }\n\n  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */\n  _getPickable(layers: Layer[]): Layer[] | null {\n    if (this._pickable === false) {\n      return null;\n    }\n    const pickableLayers = layers.filter(layer => layer.isPickable() && !layer.isComposite);\n    return pickableLayers.length ? pickableLayers : null;\n  }\n\n  // eslint-disable-next-line max-statements,complexity\n  /** Pick the closest object at the given coordinate */\n  _pickClosestObject({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = 'query',\n    unproject3D,\n    onViewportActive,\n    effects\n  }: PickByPointOptions & PickOperationContext): {\n    result: PickingInfo[];\n    emptyInfo: PickingInfo;\n  } {\n    const pickableLayers = this._getPickable(layers);\n    const pixelRatio = cssToDeviceRatio(this.gl);\n\n    if (!pickableLayers) {\n      return {\n        result: [],\n        emptyInfo: getEmptyPickingInfo({viewports, x, y, pixelRatio})\n      };\n    }\n\n    this._resizeBuffer();\n\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n    // And compensate for pixelRatio\n    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n    const devicePixel = [\n      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),\n      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)\n    ];\n\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {width, height} = this.pickingFBO as LumaFramebuffer;\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n\n    const cullRect: Rect = {\n      x: x - radius,\n      y: y - radius,\n      width: radius * 2 + 1,\n      height: radius * 2 + 1\n    };\n\n    let infos: Map<string | null, PickingInfo>;\n    const result: PickingInfo[] = [];\n    const affectedLayers = new Set<Layer>();\n\n    for (let i = 0; i < depth; i++) {\n      let pickInfo: PickedPixel;\n\n      if (deviceRect) {\n        const pickedResult = this._drawAndSample({\n          layers: pickableLayers,\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          cullRect,\n          effects,\n          pass: `picking:${mode}`\n        });\n\n        pickInfo = getClosestObject({\n          ...pickedResult,\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius,\n          deviceRect\n        });\n      } else {\n        pickInfo = {\n          pickedColor: null,\n          pickedObjectIndex: -1\n        };\n      }\n\n      let z;\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const pickedResultPass2 = this._drawAndSample(\n          {\n            layers: [pickInfo.pickedLayer],\n            views,\n            viewports,\n            onViewportActive,\n            deviceRect: {\n              x: pickInfo.pickedX as number,\n              y: pickInfo.pickedY as number,\n              width: 1,\n              height: 1\n            },\n            cullRect,\n            effects,\n            pass: `picking:${mode}:z`\n          },\n          true\n        );\n        // picked value is in common space (pixels) from the camera target (viewport.position)\n        // convert it to meters from the ground\n        z = pickedResultPass2.pickedColors[0];\n      }\n\n      // Only exclude if we need to run picking again.\n      // We need to run picking again if an object is detected AND\n      // we have not exhausted the requested depth.\n      if (pickInfo.pickedLayer && i + 1 < depth) {\n        affectedLayers.add(pickInfo.pickedLayer);\n        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n      }\n\n      // This logic needs to run even if no object is picked.\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers: pickableLayers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n\n      // If no object is picked stop.\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n\n    // reset only affected buffers\n    for (const layer of affectedLayers) {\n      layer.restorePickingColors();\n    }\n\n    return {result, emptyInfo: infos!.get(null) as PickingInfo};\n  }\n\n  /** Pick all objects within the given bounding box */\n  _pickVisibleObjects({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = 'query',\n    maxObjects = null,\n    onViewportActive,\n    effects\n  }: PickByRectOptions & PickOperationContext): PickingInfo[] {\n    const pickableLayers = this._getPickable(layers);\n\n    if (!pickableLayers) {\n      return [];\n    }\n\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const leftTop = cssToDevicePixels(this.gl, [x, y], true);\n\n    // take left and top (y inverted in device pixels) from start location\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n\n    // take right and bottom (y inverted in device pixels) from end location\n    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      // deviceTop and deviceRight represent the first pixel outside the desired rect\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n\n    const pickedResult = this._drawAndSample({\n      layers: pickableLayers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect: {x, y, width, height},\n      effects,\n      pass: `picking:${mode}`\n    });\n\n    const pickInfos = getUniqueObjects(pickedResult);\n\n    // Only return unique infos, identified by info.object\n    const uniqueInfos = new Map();\n\n    const isMaxObjects = Number.isFinite(maxObjects);\n\n    for (let i = 0; i < pickInfos.length; i++) {\n      if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {\n        break;\n      }\n      const pickInfo = pickInfos[i];\n      let info: PickingInfo = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        pixelRatio\n      };\n\n      info = getLayerPickingInfo({layer: pickInfo.pickedLayer as Layer, info, mode});\n      if (!uniqueInfos.has(info.object)) {\n        uniqueInfos.set(info.object, info);\n      }\n    }\n\n    return Array.from(uniqueInfos.values());\n  }\n\n  /** Renders layers into the picking buffer with picking colors and read the pixels. */\n  _drawAndSample(params: {\n    deviceRect: Rect;\n    pass: string;\n    layers: Layer[];\n    views: Record<string, View>;\n    viewports: Viewport[];\n    onViewportActive: (viewport: Viewport) => void;\n    cullRect?: Rect;\n    effects: Effect[];\n  }): {\n    pickedColors: Uint8Array;\n    decodePickingColor: PickingColorDecoder;\n  };\n\n  /** Renders layers into the picking buffer with encoded z values and read the pixels. */\n  _drawAndSample(\n    params: {\n      deviceRect: Rect;\n      pass: string;\n      layers: Layer[];\n      views: Record<string, View>;\n      viewports: Viewport[];\n      onViewportActive: (viewport: Viewport) => void;\n      cullRect?: Rect;\n      effects: Effect[];\n    },\n    pickZ: true\n  ): {\n    pickedColors: Float32Array;\n    decodePickingColor: null;\n  };\n\n  _drawAndSample(\n    {\n      layers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect,\n      effects,\n      pass\n    }: {\n      deviceRect: Rect;\n      pass: string;\n      layers: Layer[];\n      views: Record<string, View>;\n      viewports: Viewport[];\n      onViewportActive: (viewport: Viewport) => void;\n      cullRect?: Rect;\n      effects: Effect[];\n    },\n    pickZ: boolean = false\n  ): {\n    pickedColors: Uint8Array | Float32Array;\n    decodePickingColor: PickingColorDecoder | null;\n  } {\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n\n    const {decodePickingColor} = this.pickLayersPass.render({\n      layers,\n      layerFilter: this.layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      cullRect,\n      effects,\n      pass,\n      pickZ\n    });\n\n    // Read from an already rendered picking buffer\n    // Returns an Uint8ClampedArray of picked pixels\n    const {x, y, width, height} = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    readPixelsToArray(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n\n    return {pickedColors, decodePickingColor};\n  }\n\n  // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n  // Returns null if pixel is outside of device\n  _getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth,\n    deviceHeight\n  }: {\n    deviceX: number;\n    deviceY: number;\n    deviceRadius: number;\n    deviceWidth: number;\n    deviceHeight: number;\n  }): Rect | null {\n    // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n    // x, y out of bounds.\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n\n    return {x, y, width, height};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}