{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer } from '@deck.gl/core';\nimport { replaceInRange } from '../utils';\nimport { binaryToFeatureForAccesor } from './geojson-binary';\nimport { POINT_LAYER, LINE_LAYER, POLYGON_LAYER, getDefaultProps, forwardProps } from './sub-layer-map';\nimport { getGeojsonFeatures, separateGeojsonFeatures } from './geojson';\nimport { createLayerPropsFromFeatures, createLayerPropsFromBinary } from './geojson-layer-props';\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\nconst defaultProps = { ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  iconAtlas: {\n    type: 'object',\n    value: null\n  },\n  iconMapping: {\n    type: 'object',\n    value: {}\n  },\n  getIcon: {\n    type: 'accessor',\n    value: f => f.properties.icon\n  },\n  getText: {\n    type: 'accessor',\n    value: f => f.properties.text\n  },\n  pointType: 'circle',\n  getRadius: {\n    deprecatedFor: 'getPointRadius'\n  }\n};\nexport default class GeoJsonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      layerProps: {},\n      features: {}\n    };\n  }\n\n  updateState({\n    props,\n    changeFlags\n  }) {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n\n    const {\n      data\n    } = this.props;\n    const binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n    this.setState({\n      binary\n    });\n\n    if (binary) {\n      this._updateStateBinary({\n        props,\n        changeFlags\n      });\n    } else {\n      this._updateStateJSON({\n        props,\n        changeFlags\n      });\n    }\n  }\n\n  _updateStateBinary({\n    props,\n    changeFlags\n  }) {\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({\n      layerProps\n    });\n  }\n\n  _updateStateJSON({\n    props,\n    changeFlags\n  }) {\n    const features = getGeojsonFeatures(props.data);\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures = {};\n    const featuresDiff = {};\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(replaceInRange({\n            data: newFeatures[key],\n            getIndex: f => f.__source.index,\n            dataRange,\n            replace: partialFeatures[key]\n          }));\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index,\n      sourceLayer\n    } = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer.id.startsWith(\"\".concat(this.id, \"-\").concat(ft, \"-\")));\n\n    if (index >= 0 && sourceLayer.id.startsWith(\"\".concat(this.id, \"-points-text\")) && this.state.binary) {\n      info.index = this.props.data.points.globalFeatureIds.value[index];\n    }\n\n    return info;\n  }\n\n  _updateAutoHighlight(info) {\n    const pointLayerIdPrefix = \"\".concat(this.id, \"-points-\");\n    const sourceIsPoints = info.featureType === 'points';\n\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  _renderPolygonLayer() {\n    const {\n      extruded,\n      wireframe\n    } = this.props;\n    const {\n      layerProps\n    } = this.state;\n    const id = 'polygons-fill';\n    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      const useLineColor = extruded && wireframe;\n\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({\n        id,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.polygons);\n    }\n\n    return null;\n  }\n\n  _renderLineLayers() {\n    const {\n      extruded,\n      stroked\n    } = this.props;\n    const {\n      layerProps\n    } = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n      return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({\n        id: polygonStrokeLayerId,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({\n        id: lineStringsLayerId,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.lines)];\n    }\n\n    return null;\n  }\n\n  _renderPointLayers() {\n    const {\n      pointType\n    } = this.props;\n    const {\n      layerProps,\n      binary\n    } = this.state;\n    let {\n      highlightedObjectIndex\n    } = this.props;\n\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      highlightedObjectIndex = layerProps.points.data.findIndex(d => d.__source.index === highlightedObjectIndex);\n    }\n\n    const types = new Set(pointType.split('+'));\n    const pointLayers = [];\n\n    for (const type of types) {\n      const id = \"points-\".concat(type);\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);\n\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n        let pointsLayerProps = layerProps.points;\n\n        if (type === 'text' && binary) {\n          const {\n            instancePickingColors,\n            ...rest\n          } = pointsLayerProps.data.attributes;\n          pointsLayerProps = { ...pointsLayerProps,\n            data: { ...pointsLayerProps.data,\n              attributes: rest\n            }\n          };\n        }\n\n        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers,\n          highlightedObjectIndex\n        }), pointsLayerProps));\n      }\n    }\n\n    return pointLayers;\n  }\n\n  renderLayers() {\n    const {\n      extruded\n    } = this.props;\n\n    const polygonFillLayer = this._renderPolygonLayer();\n\n    const lineLayers = this._renderLineLayers();\n\n    const pointLayers = this._renderPointLayers();\n\n    return [!extruded && polygonFillLayer, lineLayers, pointLayers, extruded && polygonFillLayer];\n  }\n\n  getSubLayerAccessor(accessor) {\n    const {\n      binary\n    } = this.state;\n\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    return (object, info) => {\n      const {\n        data,\n        index\n      } = info;\n      const feature = binaryToFeatureForAccesor(data, index);\n      return accessor(feature, info);\n    };\n  }\n\n}\n\n_defineProperty(GeoJsonLayer, \"layerName\", 'GeoJsonLayer');\n\n_defineProperty(GeoJsonLayer, \"defaultProps\", defaultProps);","map":{"version":3,"sources":["../../../src/geojson-layer/geojson-layer.ts"],"names":["FEATURE_TYPES","defaultProps","getDefaultProps","POINT_LAYER","stroked","filled","extruded","wireframe","iconAtlas","type","value","iconMapping","getIcon","f","icon","getText","text","pointType","getRadius","deprecatedFor","GeoJsonLayer","initializeState","layerProps","features","updateState","changeFlags","data","binary","_updateStateBinary","createLayerPropsFromBinary","props","_updateStateJSON","getGeojsonFeatures","wrapFeature","newFeatures","featuresDiff","Array","oldFeatures","partialFeatures","separateGeojsonFeatures","replaceInRange","getIndex","replace","createLayerPropsFromFeatures","getPickingInfo","info","sourceLayer","ft","index","_updateAutoHighlight","pointLayerIdPrefix","sourceIsPoints","layer","_renderPolygonLayer","id","PolygonFillLayer","POLYGON_LAYER","forwardedProps","forwardProps","useLineColor","updateTriggers","_renderLineLayers","polygonStrokeLayerId","lineStringsLayerId","PolygonStrokeLayer","LINE_LAYER","LineStringsLayer","_renderPointLayers","highlightedObjectIndex","Number","d","types","pointLayers","PointLayerMapping","PointsLayer","pointsLayerProps","rest","attributes","renderLayers","polygonFillLayer","lineLayers","getSubLayerAccessor","feature","binaryToFeatureForAccesor","accessor"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Accessor,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  Layer,\n  PickingInfo,\n  Unit,\n  Material,\n  UpdateParameters,\n  _ConstructorOf,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport type {BinaryFeatures} from '@loaders.gl/schema';\nimport type {Feature} from 'geojson';\n\nimport {replaceInRange} from '../utils';\nimport {BinaryFeatureTypes, binaryToFeatureForAccesor} from './geojson-binary';\nimport {\n  POINT_LAYER,\n  LINE_LAYER,\n  POLYGON_LAYER,\n  getDefaultProps,\n  forwardProps\n} from './sub-layer-map';\n\nimport {getGeojsonFeatures, SeparatedGeometries, separateGeojsonFeatures} from './geojson';\nimport {createLayerPropsFromFeatures, createLayerPropsFromBinary} from './geojson-layer-props';\n\n/** All properties supported by GeoJsonLayer */\nexport type GeoJsonLayerProps<DataT extends Feature = Feature> = _GeoJsonLayerProps<DataT> &\n  CompositeLayerProps<DataT>;\n\n/** Properties added by GeoJsonLayer */\nexport type _GeoJsonLayerProps<DataT extends Feature = Feature> = {\n  /**\n   * How to render Point and MultiPoint features in the data.\n   *\n   * Supported types are:\n   *  * `'circle'`\n   *  * `'icon'`\n   *  * `'text'`\n   *\n   * @default 'circle'\n   */\n  pointType?: string;\n} & _GeoJsonLayerFillProps<DataT> &\n  _GeoJsonLayerStrokeProps<DataT> &\n  _GeoJsonLayer3DProps<DataT> &\n  _GeoJsonLayerPointCircleProps<DataT> &\n  _GeojsonLayerIconPointProps<DataT> &\n  _GeojsonLayerTextPointProps<DataT>;\n\n/** GeoJsonLayer fill options. */\ntype _GeoJsonLayerFillProps<DataT> = {\n  /**\n   * Whether to draw a filled polygon (solid fill).\n   *\n   * Note that only the area between the outer polygon and any holes will be filled.\n   *\n   * @default true\n   */\n  filled?: boolean;\n\n  /**\n   * Fill collor value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getFillColor?: Accessor<DataT, Color>;\n};\n\n/** GeoJsonLayer stroke options. */\ntype _GeoJsonLayerStrokeProps<DataT> = {\n  /**\n   * Whether to draw an outline around the polygon (solid fill).\n   *\n   * Note that both the outer polygon as well the outlines of any holes will be drawn.\n   *\n   * @default true\n   */\n  stroked?: boolean;\n\n  /**\n   * Line color value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getLineColor?: Accessor<DataT, Color>;\n\n  /**\n   * Line width value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getLineWidth?: Accessor<DataT, number>;\n\n  /**\n   * The units of the line width, one of `meters`, `common`, and `pixels`.\n   *\n   * @default 'meters'\n   * @see Unit.\n   */\n  lineWidthUnits?: Unit;\n\n  /**\n   * A multiplier that is applied to all line widths\n   *\n   * @default 1\n   */\n  lineWidthScale?: number;\n\n  /**\n   * The minimum line width in pixels.\n   *\n   * @default 0\n   */\n  lineWidthMinPixels?: number;\n\n  /**\n   * The maximum line width in pixels\n   *\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  lineWidthMaxPixels?: number;\n\n  /**\n   * Type of joint. If `true`, draw round joints. Otherwise draw miter joints.\n   *\n   * @default false\n   */\n  lineJointRounded?: boolean;\n\n  /**\n   * The maximum extent of a joint in ratio to the stroke width.\n   *\n   * Only works if `lineJointRounded` is false.\n   *\n   * @default 4\n   */\n  lineMiterLimit?: number;\n\n  /**\n   * Type of line caps.\n   *\n   * If `true`, draw round caps. Otherwise draw square caps.\n   *\n   * @default false\n   */\n  lineCapRounded?: boolean;\n\n  /**\n   * If `true`, extrude the line in screen space (width always faces the camera).\n   * If `false`, the width always faces up.\n   *\n   * @default false\n   */\n  lineBillboard?: boolean;\n};\n\n/** GeoJsonLayer 3D options. */\ntype _GeoJsonLayer3DProps<DataT> = {\n  /**\n   * Extrude Polygon and MultiPolygon features along the z-axis if set to true\n   *\n   * Based on the elevations provided by the `getElevation` accessor.\n   *\n   * @default false\n   */\n  extruded?: boolean;\n\n  /**\n   * Whether to generate a line wireframe of the hexagon.\n   *\n   * @default false\n   */\n  wireframe?: boolean;\n\n  /**\n   * Elevation valur or accessor.\n   *\n   * Only used if `extruded: true`.\n   *\n   * @default 1000\n   */\n  getElevation?: Accessor<DataT, number>;\n\n  /**\n   * Elevation multiplier.\n   *\n   * The final elevation is calculated by `elevationScale * getElevation(d)`.\n   * `elevationScale` is a handy property to scale all elevation without updating the data.\n   *\n   * @default 1\n   */\n  elevationScale?: boolean;\n\n  /**\n   * Material settings for lighting effect. Applies to extruded polgons.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n};\n\n/** GeoJsonLayer Properties forwarded to `ScatterPlotLayer` if `pointType` is `'circle'` */\nexport type _GeoJsonLayerPointCircleProps<DataT> = {\n  getPointRadius?: Accessor<DataT, number>;\n  pointRadiusUnits?: Unit;\n  pointRadiusScale?: number;\n  pointRadiusMinPixels?: number;\n  pointRadiusMaxPixels?: number;\n  pointAntialiasing?: boolean;\n  pointBillboard?: boolean;\n\n  /** @deprecated use getPointRadius */\n  getRadius?: Accessor<DataT, number>;\n};\n\n/** GeoJsonLayer properties forwarded to `IconLayer` if `pointType` is `'icon'` */\ntype _GeojsonLayerIconPointProps<DataT> = {\n  iconAtlas?: any;\n  iconMapping?: any;\n  getIcon?: Accessor<DataT, any>;\n  getIconSize?: Accessor<DataT, number>;\n  getIconColor?: Accessor<DataT, Color>;\n  getIconAngle?: Accessor<DataT, number>;\n  getIconPixelOffset?: Accessor<DataT, number[]>;\n  iconSizeUnits?: Unit;\n  iconSizeScale?: number;\n  iconSizeMinPixels?: number;\n  iconSizeMaxPixels?: number;\n  iconBillboard?: boolean;\n  iconAlphaCutoff?: number;\n};\n\n/** GeoJsonLayer properties forwarded to `TextLayer` if `pointType` is `'text'` */\ntype _GeojsonLayerTextPointProps<DataT> = {\n  getText?: Accessor<DataT, any>;\n  getTextColor?: Accessor<DataT, Color>;\n  getTextAngle?: Accessor<DataT, number>;\n  getTextSize?: Accessor<DataT, number>;\n  getTextAnchor?: Accessor<DataT, string>;\n  getTextAlignmentBaseline?: Accessor<DataT, string>;\n  getTextPixelOffset?: Accessor<DataT, number[]>;\n  getTextBackgroundColor?: Accessor<DataT, Color>;\n  getTextBorderColor?: Accessor<DataT, Color>;\n  getTextBorderWidth?: Accessor<DataT, number>;\n  textSizeUnits?: Unit;\n  textSizeScale?: number;\n  textSizeMinPixels?: number;\n  textSizeMaxPixels?: number;\n  textCharacterSet?: any;\n  textFontFamily?: string;\n  textFontWeight?: number;\n  textLineHeight?: number;\n  textMaxWidth?: number;\n  textWordBreak?: string; // TODO\n  textBackground?: boolean;\n  textBackgroundPadding?: number[];\n  textOutlineColor?: Color;\n  textOutlineWidth?: number;\n  textBillboard?: boolean;\n  textFontSettings?: any;\n};\n\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\n\nconst defaultProps: DefaultProps<GeoJsonLayerProps> = {\n  ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n\n  // Overwrite sub layer defaults\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  iconAtlas: {type: 'object', value: null},\n  iconMapping: {type: 'object', value: {}},\n  getIcon: {type: 'accessor', value: f => f.properties.icon},\n  getText: {type: 'accessor', value: f => f.properties.text},\n\n  // Self props\n  pointType: 'circle',\n\n  // TODO: deprecated, remove in v9\n  getRadius: {deprecatedFor: 'getPointRadius'}\n};\n\ntype GeoJsonPickingInfo = PickingInfo & {\n  featureType?: string | null;\n  info?: any;\n};\n\n/** Render GeoJSON formatted data as polygons, lines and points (circles, icons and/or texts). */\nexport default class GeoJsonLayer<\n  DataT extends Feature = Feature,\n  ExtraProps = {}\n> extends CompositeLayer<Required<GeoJsonLayerProps<DataT>> & ExtraProps> {\n  static layerName = 'GeoJsonLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    this.state = {\n      layerProps: {},\n      features: {}\n    };\n  }\n\n  updateState({props, changeFlags}: UpdateParameters<this>): void {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n    const {data} = this.props;\n    const binary =\n      data && 'points' in (data as {}) && 'polygons' in (data as {}) && 'lines' in (data as {});\n\n    this.setState({binary});\n\n    if (binary) {\n      this._updateStateBinary({props, changeFlags});\n    } else {\n      this._updateStateJSON({props, changeFlags});\n    }\n  }\n\n  private _updateStateBinary({props, changeFlags}): void {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({layerProps});\n  }\n\n  private _updateStateJSON({props, changeFlags}): void {\n    const features: Feature[] = getGeojsonFeatures(props.data) as any;\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures: SeparatedGeometries = {} as SeparatedGeometries;\n    const featuresDiff = {};\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(\n            replaceInRange({\n              data: newFeatures[key],\n              getIndex: f => f.__source.index,\n              dataRange,\n              replace: partialFeatures[key]\n            })\n          );\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n\n  getPickingInfo(params): GeoJsonPickingInfo {\n    const info = super.getPickingInfo(params) as GeoJsonPickingInfo;\n    const {index, sourceLayer} = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer!.id.startsWith(`${this.id}-${ft}-`));\n    if (index >= 0 && sourceLayer!.id.startsWith(`${this.id}-points-text`) && this.state.binary) {\n      info.index = (this.props.data as BinaryFeatures).points!.globalFeatureIds.value[index];\n    }\n    return info;\n  }\n\n  _updateAutoHighlight(info: GeoJsonPickingInfo): void {\n    // All sub layers except the points layer use source feature index to encode the picking color\n    // The points layer uses indices from the points data array.\n    const pointLayerIdPrefix = `${this.id}-points-`;\n    const sourceIsPoints = info.featureType === 'points';\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  private _renderPolygonLayer(): Layer | null {\n    const {extruded, wireframe} = this.props;\n    const {layerProps} = this.state;\n    const id = 'polygons-fill';\n\n    const PolygonFillLayer =\n      this.shouldRenderSubLayer(id, layerProps.polygons.data) &&\n      this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      // Avoid building the lineColors attribute if wireframe is off\n      const useLineColor = extruded && wireframe;\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n      // using a legacy API to invalid lineColor attributes\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n\n      return new PolygonFillLayer(\n        forwardedProps,\n        this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers\n        }),\n        layerProps.polygons\n      );\n    }\n    return null;\n  }\n\n  private _renderLineLayers(): (Layer | false)[] | null {\n    const {extruded, stroked} = this.props;\n    const {layerProps} = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n\n    const PolygonStrokeLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) &&\n      this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer =\n      this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) &&\n      this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n\n      return [\n        PolygonStrokeLayer &&\n          new PolygonStrokeLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: polygonStrokeLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.polygonsOutline\n          ),\n\n        LineStringsLayer &&\n          new LineStringsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: lineStringsLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.lines\n          )\n      ];\n    }\n    return null;\n  }\n\n  private _renderPointLayers(): Layer[] | null {\n    const {pointType} = this.props;\n    const {layerProps, binary} = this.state;\n    let {highlightedObjectIndex} = this.props;\n\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      highlightedObjectIndex = layerProps.points.data.findIndex(\n        d => d.__source.index === highlightedObjectIndex\n      );\n    }\n\n    // Avoid duplicate sub layer ids\n    const types = new Set(pointType.split('+'));\n    const pointLayers: Layer[] = [];\n    for (const type of types) {\n      const id = `points-${type}`;\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer: _ConstructorOf<Layer> =\n        PointLayerMapping &&\n        this.shouldRenderSubLayer(id, layerProps.points.data) &&\n        this.getSubLayerClass(id, PointLayerMapping.type);\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n        let pointsLayerProps = layerProps.points;\n\n        if (type === 'text' && binary) {\n          // Picking colors are per-point but for text per-character are required\n          // getPickingInfo() maps back to the correct index\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const {instancePickingColors, ...rest} = pointsLayerProps.data.attributes;\n          pointsLayerProps = {\n            ...pointsLayerProps,\n            data: {...pointsLayerProps.data, attributes: rest}\n          };\n        }\n\n        pointLayers.push(\n          new PointsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id,\n              updateTriggers: forwardedProps.updateTriggers,\n              highlightedObjectIndex\n            }),\n            pointsLayerProps\n          )\n        );\n      }\n    }\n    return pointLayers;\n  }\n\n  renderLayers() {\n    const {extruded} = this.props;\n\n    const polygonFillLayer = this._renderPolygonLayer();\n    const lineLayers = this._renderLineLayers();\n    const pointLayers = this._renderPointLayers();\n\n    return [\n      // If not extruded: flat fill layer is drawn below outlines\n      !extruded && polygonFillLayer,\n      lineLayers,\n      pointLayers,\n      // If extruded: draw fill layer last for correct blending behavior\n      extruded && polygonFillLayer\n    ];\n  }\n\n  protected getSubLayerAccessor<In, Out>(accessor: Accessor<In, Out>): Accessor<In, Out> {\n    const {binary} = this.state;\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    return (object, info) => {\n      const {data, index} = info;\n      const feature = binaryToFeatureForAccesor(data as unknown as BinaryFeatureTypes, index);\n      // @ts-ignore (TS2349) accessor is always function\n      return accessor(feature, info);\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}