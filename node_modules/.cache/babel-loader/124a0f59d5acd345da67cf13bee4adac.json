{"ast":null,"code":"import log from '../../utils/log';\nconst NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedObjectIndex: -1\n};\nexport function getClosestObject({\n  pickedColors,\n  decodePickingColor,\n  deviceX,\n  deviceY,\n  deviceRadius,\n  deviceRect\n}) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = deviceRect;\n  let minSquareDistanceToCenter = deviceRadius * deviceRadius;\n  let closestPixelIndex = -1;\n  let i = 0;\n\n  for (let row = 0; row < height; row++) {\n    const dy = row + y - deviceY;\n    const dy2 = dy * dy;\n\n    if (dy2 > minSquareDistanceToCenter) {\n      i += 4 * width;\n    } else {\n      for (let col = 0; col < width; col++) {\n        const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n        if (pickedLayerIndex >= 0) {\n          const dx = col + x - deviceX;\n          const d2 = dx * dx + dy2;\n\n          if (d2 <= minSquareDistanceToCenter) {\n            minSquareDistanceToCenter = d2;\n            closestPixelIndex = i;\n          }\n        }\n\n        i += 4;\n      }\n    }\n  }\n\n  if (closestPixelIndex >= 0) {\n    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n    const pickedObject = decodePickingColor(pickedColor);\n\n    if (pickedObject) {\n      const dy = Math.floor(closestPixelIndex / 4 / width);\n      const dx = closestPixelIndex / 4 - dy * width;\n      return { ...pickedObject,\n        pickedColor,\n        pickedX: x + dx,\n        pickedY: y + dy\n      };\n    }\n\n    log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n  }\n\n  return NO_PICKED_OBJECT;\n}\nexport function getUniqueObjects({\n  pickedColors,\n  decodePickingColor\n}) {\n  const uniqueColors = new Map();\n\n  if (pickedColors) {\n    for (let i = 0; i < pickedColors.length; i += 4) {\n      const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        const pickedColor = pickedColors.slice(i, i + 4);\n        const colorKey = pickedColor.join(',');\n\n        if (!uniqueColors.has(colorKey)) {\n          const pickedObject = decodePickingColor(pickedColor);\n\n          if (pickedObject) {\n            uniqueColors.set(colorKey, { ...pickedObject,\n              color: pickedColor\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}","map":{"version":3,"sources":["../../../../src/lib/picking/query-object.ts"],"names":["NO_PICKED_OBJECT","pickedColor","pickedObjectIndex","deviceRect","height","minSquareDistanceToCenter","deviceRadius","closestPixelIndex","i","row","dy","dy2","col","pickedLayerIndex","pickedColors","dx","d2","pickedObject","decodePickingColor","Math","pickedX","x","pickedY","y","log","uniqueColors","colorKey","color","Array"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../../utils/log';\nimport type Layer from '../layer';\nimport type Viewport from '../../viewports/viewport';\nimport type {PickingColorDecoder} from '../../passes/pick-layers-pass';\n\nexport type PickedPixel = {\n  pickedColor: Uint8Array | null;\n  pickedLayer?: Layer;\n  pickedViewports?: Viewport[];\n  pickedX?: number;\n  pickedY?: number;\n  pickedObjectIndex: number;\n};\n\nconst NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedObjectIndex: -1\n};\n\n/* eslint-disable max-depth, max-statements */\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getClosestObject({\n  pickedColors,\n  decodePickingColor,\n  deviceX,\n  deviceY,\n  deviceRadius,\n  deviceRect\n}: {\n  pickedColors: Uint8Array;\n  decodePickingColor: PickingColorDecoder;\n  deviceX: number;\n  deviceY: number;\n  deviceRadius: number;\n  deviceRect: {x: number; y: number; width: number; height: number};\n}): PickedPixel {\n  // Traverse all pixels in picking results and find the one closest to the supplied\n  // [deviceX, deviceY]\n  const {x, y, width, height} = deviceRect;\n  let minSquareDistanceToCenter = deviceRadius * deviceRadius;\n  let closestPixelIndex = -1;\n  let i = 0;\n\n  for (let row = 0; row < height; row++) {\n    const dy = row + y - deviceY;\n    const dy2 = dy * dy;\n\n    if (dy2 > minSquareDistanceToCenter) {\n      // skip this row\n      i += 4 * width;\n    } else {\n      for (let col = 0; col < width; col++) {\n        // Decode picked layer from color\n        const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n        if (pickedLayerIndex >= 0) {\n          const dx = col + x - deviceX;\n          const d2 = dx * dx + dy2;\n\n          if (d2 <= minSquareDistanceToCenter) {\n            minSquareDistanceToCenter = d2;\n            closestPixelIndex = i;\n          }\n        }\n        i += 4;\n      }\n    }\n  }\n\n  if (closestPixelIndex >= 0) {\n    // Decode picked object index from color\n    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n    const pickedObject = decodePickingColor(pickedColor);\n    if (pickedObject) {\n      const dy = Math.floor(closestPixelIndex / 4 / width);\n      const dx = closestPixelIndex / 4 - dy * width;\n      return {\n        ...pickedObject,\n        pickedColor,\n        pickedX: x + dx,\n        pickedY: y + dy\n      };\n    }\n    log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n  }\n  return NO_PICKED_OBJECT;\n}\n\n/**\n * Examines a picking buffer for unique colors\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getUniqueObjects({\n  pickedColors,\n  decodePickingColor\n}: {\n  pickedColors: Uint8Array;\n  decodePickingColor: PickingColorDecoder;\n}): PickedPixel[] {\n  const uniqueColors = new Map();\n\n  // Traverse all pixels in picking results and get unique colors\n  if (pickedColors) {\n    for (let i = 0; i < pickedColors.length; i += 4) {\n      // Decode picked layer from color\n      const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        const pickedColor = pickedColors.slice(i, i + 4);\n        const colorKey = pickedColor.join(',');\n        // eslint-disable-next-line\n        if (!uniqueColors.has(colorKey)) {\n          const pickedObject = decodePickingColor(pickedColor);\n          // eslint-disable-next-line\n          if (pickedObject) {\n            uniqueColors.set(colorKey, {\n              ...pickedObject,\n              color: pickedColor\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}\n"]},"metadata":{},"sourceType":"module"}