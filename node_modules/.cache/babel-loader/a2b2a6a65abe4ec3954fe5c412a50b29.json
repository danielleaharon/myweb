{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Matrix4 } from '@math.gl/core';\nimport Viewport from './viewport';\nimport { PROJECTION_MODE } from '../lib/constants';\nimport * as vec3 from 'gl-matrix/vec3';\nimport * as vec4 from 'gl-matrix/vec4';\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst RADIANS_TO_DEGREES = 180 / Math.PI;\nconst EARTH_RADIUS = 6370972;\nconst GLOBE_RADIUS = 256;\n\nfunction getDistanceScales() {\n  const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;\n  const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;\n  return {\n    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],\n    unitsPerMeter2: [0, 0, 0],\n    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],\n    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],\n    unitsPerDegree2: [0, 0, 0],\n    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]\n  };\n}\n\nexport default class GlobeViewport extends Viewport {\n  constructor(opts = {}) {\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      nearZMultiplier = 0.1,\n      farZMultiplier = 2,\n      resolution = 10\n    } = opts;\n    let {\n      height,\n      altitude = 1.5\n    } = opts;\n    height = height || 1;\n    altitude = Math.max(0.75, altitude);\n    const viewMatrix = new Matrix4().lookAt({\n      eye: [0, -altitude, 0],\n      up: [0, 0, 1]\n    });\n    const scale = Math.pow(2, zoom);\n    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);\n    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);\n    viewMatrix.scale(scale / height);\n    const halfFov = Math.atan(0.5 / altitude);\n    const relativeScale = GLOBE_RADIUS * 2 * scale / height;\n    super({ ...opts,\n      height,\n      viewMatrix,\n      longitude,\n      latitude,\n      zoom,\n      distanceScales: getDistanceScales(),\n      fovyRadians: halfFov * 2,\n      focalDistance: altitude,\n      near: nearZMultiplier,\n      far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier\n    });\n\n    _defineProperty(this, \"longitude\", void 0);\n\n    _defineProperty(this, \"latitude\", void 0);\n\n    _defineProperty(this, \"resolution\", void 0);\n\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.resolution = resolution;\n  }\n\n  get projectionMode() {\n    return PROJECTION_MODE.GLOBE;\n  }\n\n  getDistanceScales() {\n    return this.distanceScales;\n  }\n\n  getBounds(options = {}) {\n    const unprojectOption = {\n      targetZ: options.z || 0\n    };\n    const left = this.unproject([0, this.height / 2], unprojectOption);\n    const top = this.unproject([this.width / 2, 0], unprojectOption);\n    const right = this.unproject([this.width, this.height / 2], unprojectOption);\n    const bottom = this.unproject([this.width / 2, this.height], unprojectOption);\n    if (right[0] < this.longitude) right[0] += 360;\n    if (left[0] > this.longitude) left[0] -= 360;\n    return [Math.min(left[0], right[0], top[0], bottom[0]), Math.min(left[1], right[1], top[1], bottom[1]), Math.max(left[0], right[0], top[0], bottom[0]), Math.max(left[1], right[1], top[1], bottom[1])];\n  }\n\n  unproject(xyz, {\n    topLeft = true,\n    targetZ\n  } = {}) {\n    const [x, y, z] = xyz;\n    const y2 = topLeft ? y : this.height - y;\n    const {\n      pixelUnprojectionMatrix\n    } = this;\n    let coord;\n\n    if (Number.isFinite(z)) {\n      coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);\n    } else {\n      const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);\n      const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);\n      const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n      const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));\n      const l0Sqr = vec3.sqrLen(coord0);\n      const l1Sqr = vec3.sqrLen(coord1);\n      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;\n      const dSqr = 4 * sSqr / lSqr;\n      const r0 = Math.sqrt(l0Sqr - dSqr);\n      const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));\n      const t = (r0 - dr) / Math.sqrt(lSqr);\n      coord = vec3.lerp([], coord0, coord1, t);\n    }\n\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  projectPosition(xyz) {\n    const [lng, lat, Z = 0] = xyz;\n    const lambda = lng * DEGREES_TO_RADIANS;\n    const phi = lat * DEGREES_TO_RADIANS;\n    const cosPhi = Math.cos(phi);\n    const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n    return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];\n  }\n\n  unprojectPosition(xyz) {\n    const [x, y, z] = xyz;\n    const D = vec3.len(xyz);\n    const phi = Math.asin(z / D);\n    const lambda = Math.atan2(x, -y);\n    const lng = lambda * RADIANS_TO_DEGREES;\n    const lat = phi * RADIANS_TO_DEGREES;\n    const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;\n    return [lng, lat, Z];\n  }\n\n  projectFlat(xyz) {\n    return xyz;\n  }\n\n  unprojectFlat(xyz) {\n    return xyz;\n  }\n\n  panByPosition(coords, pixel) {\n    const fromPosition = this.unproject(pixel);\n    return {\n      longitude: coords[0] - fromPosition[0] + this.longitude,\n      latitude: coords[1] - fromPosition[1] + this.latitude\n    };\n  }\n\n}\n\nfunction transformVector(matrix, vector) {\n  const result = vec4.transformMat4([], vector, matrix);\n  vec4.scale(result, result, 1 / result[3]);\n  return result;\n}","map":{"version":3,"sources":["../../../src/viewports/globe-viewport.ts"],"names":["DEGREES_TO_RADIANS","Math","RADIANS_TO_DEGREES","EARTH_RADIUS","GLOBE_RADIUS","unitsPerMeter","unitsPerDegree","unitsPerMeter2","metersPerUnit","unitsPerDegree2","degreesPerUnit","constructor","opts","latitude","longitude","zoom","nearZMultiplier","farZMultiplier","resolution","altitude","height","viewMatrix","eye","up","scale","halfFov","relativeScale","distanceScales","getDistanceScales","fovyRadians","focalDistance","near","far","projectionMode","PROJECTION_MODE","getBounds","options","unprojectOption","targetZ","left","top","right","bottom","unproject","topLeft","y2","pixelUnprojectionMatrix","Number","coord","transformVector","coord0","coord1","lt","lSqr","vec3","l0Sqr","l1Sqr","sSqr","dSqr","r0","dr","t","projectPosition","Z","lambda","lng","phi","lat","cosPhi","D","unprojectPosition","z","projectFlat","unprojectFlat","panByPosition","fromPosition","coords","result","vec4"],"mappings":"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","sourcesContent":["import {Matrix4} from '@math.gl/core';\nimport Viewport from './viewport';\nimport {PROJECTION_MODE} from '../lib/constants';\n\nimport * as vec3 from 'gl-matrix/vec3';\nimport * as vec4 from 'gl-matrix/vec4';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst RADIANS_TO_DEGREES = 180 / Math.PI;\nconst EARTH_RADIUS = 6370972;\nconst GLOBE_RADIUS = 256;\n\nfunction getDistanceScales() {\n  const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;\n  const unitsPerDegree = (Math.PI / 180) * GLOBE_RADIUS;\n\n  return {\n    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],\n    unitsPerMeter2: [0, 0, 0],\n    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],\n    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],\n    unitsPerDegree2: [0, 0, 0],\n    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]\n  };\n}\n\nexport type GlobeViewportOptions = {\n  /** Name of the viewport */\n  id?: string;\n  /** Left offset from the canvas edge, in pixels */\n  x?: number;\n  /** Top offset from the canvas edge, in pixels */\n  y?: number;\n  /** Viewport width in pixels */\n  width?: number;\n  /** Viewport height in pixels */\n  height?: number;\n  /** Longitude in degrees */\n  longitude?: number;\n  /** Latitude in degrees */\n  latitude?: number;\n  /** Camera altitude relative to the viewport height, used to control the FOV. Default `1.5` */\n  altitude?: number;\n  /* Meter offsets of the viewport center from lng, lat */\n  position?: number[];\n  /** Zoom level */\n  zoom?: number;\n  /** Use orthographic projection */\n  orthographic?: boolean;\n  /** Scaler for the near plane, 1 unit equals to the height of the viewport. Default `0.1` */\n  nearZMultiplier?: number;\n  /** Scaler for the far plane, 1 unit equals to the distance from the camera to the edge of the screen. Default `2` */\n  farZMultiplier?: number;\n  /** The resolution at which to turn flat features into 3D meshes, in degrees. Smaller numbers will generate more detailed mesh. Default `10` */\n  resolution?: number;\n};\n\nexport default class GlobeViewport extends Viewport {\n  // @ts-ignore\n  longitude: number;\n  // @ts-ignore\n  latitude: number;\n  resolution: number;\n\n  constructor(opts: GlobeViewportOptions = {}) {\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      nearZMultiplier = 0.1,\n      farZMultiplier = 2,\n      resolution = 10\n    } = opts;\n\n    let {height, altitude = 1.5} = opts;\n\n    height = height || 1;\n    altitude = Math.max(0.75, altitude);\n\n    // Calculate view matrix\n    const viewMatrix = new Matrix4().lookAt({eye: [0, -altitude, 0], up: [0, 0, 1]});\n    const scale = Math.pow(2, zoom);\n    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);\n    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);\n    viewMatrix.scale(scale / height);\n\n    const halfFov = Math.atan(0.5 / altitude);\n    const relativeScale = (GLOBE_RADIUS * 2 * scale) / height;\n\n    super({\n      ...opts,\n      // x, y, width,\n      height,\n\n      // view matrix\n      viewMatrix,\n      longitude,\n      latitude,\n      zoom,\n\n      // projection matrix parameters\n      distanceScales: getDistanceScales(),\n      fovyRadians: halfFov * 2,\n      focalDistance: altitude,\n      near: nearZMultiplier,\n      far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier\n    });\n\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.resolution = resolution;\n  }\n\n  get projectionMode() {\n    return PROJECTION_MODE.GLOBE;\n  }\n\n  getDistanceScales() {\n    return this.distanceScales;\n  }\n\n  getBounds(options: {z?: number} = {}): [number, number, number, number] {\n    const unprojectOption = {targetZ: options.z || 0};\n\n    const left = this.unproject([0, this.height / 2], unprojectOption);\n    const top = this.unproject([this.width / 2, 0], unprojectOption);\n    const right = this.unproject([this.width, this.height / 2], unprojectOption);\n    const bottom = this.unproject([this.width / 2, this.height], unprojectOption);\n\n    if (right[0] < this.longitude) right[0] += 360;\n    if (left[0] > this.longitude) left[0] -= 360;\n\n    return [\n      Math.min(left[0], right[0], top[0], bottom[0]),\n      Math.min(left[1], right[1], top[1], bottom[1]),\n      Math.max(left[0], right[0], top[0], bottom[0]),\n      Math.max(left[1], right[1], top[1], bottom[1])\n    ];\n  }\n\n  unproject(\n    xyz: number[],\n    {topLeft = true, targetZ}: {topLeft?: boolean; targetZ?: number} = {}\n  ): number[] {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const {pixelUnprojectionMatrix} = this;\n\n    let coord;\n    if (Number.isFinite(z)) {\n      // Has depth component\n      coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);\n    } else {\n      // since we don't know the correct projected z value for the point,\n      // unproject two points to get a line and then find the point on that line that intersects with the sphere\n      const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);\n      const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);\n\n      const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n      const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));\n      const l0Sqr = vec3.sqrLen(coord0);\n      const l1Sqr = vec3.sqrLen(coord1);\n      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;\n      const dSqr = (4 * sSqr) / lSqr;\n      const r0 = Math.sqrt(l0Sqr - dSqr);\n      const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));\n      const t = (r0 - dr) / Math.sqrt(lSqr);\n\n      coord = vec3.lerp([], coord0, coord1, t);\n    }\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ as number] : [X, Y];\n  }\n\n  projectPosition(xyz: number[]): [number, number, number] {\n    const [lng, lat, Z = 0] = xyz;\n    const lambda = lng * DEGREES_TO_RADIANS;\n    const phi = lat * DEGREES_TO_RADIANS;\n    const cosPhi = Math.cos(phi);\n    const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n\n    return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];\n  }\n\n  unprojectPosition(xyz: number[]): [number, number, number] {\n    const [x, y, z] = xyz;\n    const D = vec3.len(xyz);\n    const phi = Math.asin(z / D);\n    const lambda = Math.atan2(x, -y);\n\n    const lng = lambda * RADIANS_TO_DEGREES;\n    const lat = phi * RADIANS_TO_DEGREES;\n    const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;\n    return [lng, lat, Z];\n  }\n\n  projectFlat(xyz: number[]): [number, number] {\n    return xyz as [number, number];\n  }\n\n  unprojectFlat(xyz: number[]): [number, number] {\n    return xyz as [number, number];\n  }\n\n  panByPosition(coords: number[], pixel: number[]): GlobeViewportOptions {\n    const fromPosition = this.unproject(pixel);\n    return {\n      longitude: coords[0] - fromPosition[0] + this.longitude,\n      latitude: coords[1] - fromPosition[1] + this.latitude\n    };\n  }\n}\n\nfunction transformVector(matrix: number[], vector: number[]): number[] {\n  const result = vec4.transformMat4([], vector, matrix);\n  vec4.scale(result, result, 1 / result[3]);\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}