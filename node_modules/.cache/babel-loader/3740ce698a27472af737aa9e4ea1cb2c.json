{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport TinySDF from '@mapbox/tiny-sdf';\nimport { log } from '@deck.gl/core';\nimport { buildMapping } from './utils';\nimport LRUCache from './lru-cache';\n\nfunction getDefaultCharacterSet() {\n  const charSet = [];\n\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n\n  return charSet;\n}\n\nexport const DEFAULT_FONT_SETTINGS = {\n  fontFamily: 'Monaco, monospace',\n  fontWeight: 'normal',\n  characterSet: getDefaultCharacterSet(),\n  fontSize: 64,\n  buffer: 4,\n  sdf: false,\n  cutoff: 0.25,\n  radius: 12,\n  smoothing: 0.1\n};\nconst MAX_CANVAS_WIDTH = 1024;\nconst BASELINE_SCALE = 0.9;\nconst HEIGHT_SCALE = 1.2;\nconst CACHE_LIMIT = 3;\nlet cache = new LRUCache(CACHE_LIMIT);\n\nfunction getNewChars(cacheKey, characterSet) {\n  let newCharSet;\n\n  if (typeof characterSet === 'string') {\n    newCharSet = new Set(Array.from(characterSet));\n  } else {\n    newCharSet = new Set(characterSet);\n  }\n\n  const cachedFontAtlas = cache.get(cacheKey);\n\n  if (!cachedFontAtlas) {\n    return newCharSet;\n  }\n\n  for (const char in cachedFontAtlas.mapping) {\n    if (newCharSet.has(char)) {\n      newCharSet.delete(char);\n    }\n  }\n\n  return newCharSet;\n}\n\nfunction populateAlphaChannel(alphaChannel, imageData) {\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(ctx, fontFamily, fontSize, fontWeight) {\n  ctx.font = \"\".concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'alphabetic';\n  ctx.textAlign = 'left';\n}\n\nexport function setFontAtlasCacheLimit(limit) {\n  log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');\n  cache = new LRUCache(limit);\n}\nexport default class FontAtlasManager {\n  constructor() {\n    _defineProperty(this, \"props\", { ...DEFAULT_FONT_SETTINGS\n    });\n\n    _defineProperty(this, \"_key\", void 0);\n\n    _defineProperty(this, \"_atlas\", void 0);\n  }\n\n  get texture() {\n    return this._atlas;\n  }\n\n  get mapping() {\n    return this._atlas && this._atlas.mapping;\n  }\n\n  get scale() {\n    return HEIGHT_SCALE;\n  }\n\n  setProps(props = {}) {\n    Object.assign(this.props, props);\n    const oldKey = this._key;\n    this._key = this._getKey();\n    const charSet = getNewChars(this._key, this.props.characterSet);\n    const cachedFontAtlas = cache.get(this._key);\n\n    if (cachedFontAtlas && charSet.size === 0) {\n      if (this._key !== oldKey) {\n        this._atlas = cachedFontAtlas;\n      }\n\n      return;\n    }\n\n    const fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);\n\n    this._atlas = fontAtlas;\n    cache.set(this._key, fontAtlas);\n  }\n\n  _generateFontAtlas(key, characterSet, cachedFontAtlas) {\n    const {\n      fontFamily,\n      fontWeight,\n      fontSize,\n      buffer,\n      sdf,\n      radius,\n      cutoff\n    } = this.props;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n\n    const ctx = canvas.getContext('2d');\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n    const {\n      mapping,\n      canvasHeight,\n      xOffset,\n      yOffset\n    } = buildMapping({\n      getFontWidth: char => ctx.measureText(char).width,\n      fontHeight: fontSize * HEIGHT_SCALE,\n      buffer,\n      characterSet,\n      maxCanvasWidth: MAX_CANVAS_WIDTH,\n      ...(cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })\n    });\n\n    if (canvas.height !== canvasHeight) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(imageData, 0, 0);\n    }\n\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    if (sdf) {\n      const tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);\n      const imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);\n\n      for (const char of characterSet) {\n        populateAlphaChannel(tinySDF.draw(char), imageData);\n        ctx.putImageData(imageData, mapping[char].x - buffer, mapping[char].y + buffer);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(char, mapping[char].x, mapping[char].y + fontSize * BASELINE_SCALE);\n      }\n    }\n\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n\n  _getKey() {\n    const {\n      fontFamily,\n      fontWeight,\n      fontSize,\n      buffer,\n      sdf,\n      radius,\n      cutoff\n    } = this.props;\n\n    if (sdf) {\n      return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer, \" \").concat(radius, \" \").concat(cutoff);\n    }\n\n    return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer);\n  }\n\n}","map":{"version":3,"sources":["../../../src/text-layer/font-atlas-manager.ts"],"names":["charSet","i","String","DEFAULT_FONT_SETTINGS","fontFamily","fontWeight","characterSet","getDefaultCharacterSet","fontSize","buffer","sdf","cutoff","radius","smoothing","MAX_CANVAS_WIDTH","BASELINE_SCALE","HEIGHT_SCALE","CACHE_LIMIT","cache","newCharSet","Array","cachedFontAtlas","alphaChannel","imageData","ctx","log","Number","limit","texture","mapping","scale","setProps","props","Object","oldKey","getNewChars","fontAtlas","_generateFontAtlas","canvas","document","setTextStyle","yOffset","buildMapping","getFontWidth","char","fontHeight","maxCanvasWidth","xOffset","tinySDF","populateAlphaChannel","data","width","height","_getKey"],"mappings":"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","sourcesContent":["/* global document */\nimport TinySDF from '@mapbox/tiny-sdf';\n\nimport {log} from '@deck.gl/core';\n\nimport {buildMapping, CharacterMapping} from './utils';\nimport LRUCache from './lru-cache';\n\nimport type {Texture} from '@deck.gl/core';\n\nfunction getDefaultCharacterSet() {\n  const charSet: string[] = [];\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n  return charSet;\n}\n\nexport type FontSettings = {\n  /** CSS font family\n   * @default 'Monaco, monospace'\n   */\n  fontFamily?: string;\n  /** CSS font weight\n   * @default 'normal'\n   */\n  fontWeight?: string | number;\n  /** Specifies a list of characters to include in the font.\n   * @default (ASCII characters 32-128)\n   */\n  characterSet?: Set<string> | string[] | string;\n  /** Font size in pixels. This option is only applied for generating `fontAtlas`, it does not impact the size of displayed text labels. Larger `fontSize` will give you a sharper look when rendering text labels with very large font sizes. But larger `fontSize` requires more time and space to generate the `fontAtlas`.\n   * @default 64\n   */\n  fontSize?: number;\n  /** Whitespace buffer around each side of the character. In general, bigger `fontSize` requires bigger `buffer`. Increase `buffer` will add more space between each character when layout `characterSet` in `fontAtlas`. This option could be tuned to provide sufficient space for drawing each character and avoiding overlapping of neighboring characters.\n   * @default 4\n   */\n  buffer?: number;\n  /** Flag to enable / disable `sdf`. [`sdf` (Signed Distance Fields)](http://cs.brown.edu/people/pfelzens/papers/dt-final.pdf) will provide a sharper look when rendering with very large or small font sizes. `TextLayer` integrates with [`TinySDF`](https://github.com/mapbox/tiny-sdf) which implements the `sdf` algorithm.\n   * @default false\n   */\n  sdf?: boolean;\n  /** How much of the radius (relative) is used for the inside part the glyph. Bigger `cutoff` makes character thinner. Smaller `cutoff` makes character look thicker. Only applies when `sdf: true`.\n   * @default 0.25\n   */\n  cutoff?: number;\n  /** How many pixels around the glyph shape to use for encoding distance. Bigger radius yields higher quality outcome. Only applies when `sdf: true`.\n   * @default 12\n   */\n  radius?: number;\n  /** How much smoothing to apply to the text edges. Only applies when `sdf: true`.\n   * @default 0.1\n   */\n  smoothing?: number;\n};\n\nexport const DEFAULT_FONT_SETTINGS: Required<FontSettings> = {\n  fontFamily: 'Monaco, monospace',\n  fontWeight: 'normal',\n  characterSet: getDefaultCharacterSet(),\n  fontSize: 64,\n  buffer: 4,\n  sdf: false,\n  cutoff: 0.25,\n  radius: 12,\n  smoothing: 0.1\n};\n\nconst MAX_CANVAS_WIDTH = 1024;\n\nconst BASELINE_SCALE = 0.9;\nconst HEIGHT_SCALE = 1.2;\n\n// only preserve latest three fontAtlas\nconst CACHE_LIMIT = 3;\n\ntype FontAtlas = {\n  /** x position of last character in mapping */\n  xOffset: number;\n  /** y position of last character in mapping */\n  yOffset: number;\n  /** bounding box of each character in the texture */\n  mapping: CharacterMapping;\n  /** packed texture */\n  data: HTMLCanvasElement;\n  /** texture width */\n  width: number;\n  /** texture height */\n  height: number;\n};\n\nlet cache = new LRUCache<FontAtlas>(CACHE_LIMIT);\n\n/**\n * get all the chars not in cache\n * @returns chars not in cache\n */\nfunction getNewChars(cacheKey: string, characterSet: Set<string> | string[] | string): Set<string> {\n  let newCharSet: Set<string>;\n  if (typeof characterSet === 'string') {\n    newCharSet = new Set(Array.from(characterSet));\n  } else {\n    newCharSet = new Set(characterSet);\n  }\n\n  const cachedFontAtlas = cache.get(cacheKey);\n  if (!cachedFontAtlas) {\n    return newCharSet;\n  }\n\n  for (const char in cachedFontAtlas.mapping) {\n    if (newCharSet.has(char)) {\n      newCharSet.delete(char);\n    }\n  }\n  return newCharSet;\n}\n\nfunction populateAlphaChannel(alphaChannel: number[], imageData: ImageData): void {\n  // populate distance value from tinySDF to image alpha channel\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(\n  ctx: CanvasRenderingContext2D,\n  fontFamily: string,\n  fontSize: number,\n  fontWeight: string | number\n): void {\n  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'alphabetic';\n  ctx.textAlign = 'left';\n}\n\n/**\n * Sets the Font Atlas LRU Cache Limit\n * @param {number} limit LRU Cache limit\n */\nexport function setFontAtlasCacheLimit(limit: number): void {\n  log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');\n\n  cache = new LRUCache(limit);\n}\n\nexport default class FontAtlasManager {\n  /** Font settings */\n  props: Required<FontSettings> = {...DEFAULT_FONT_SETTINGS};\n\n  /** Cache key of the current font atlas */\n  private _key?: string;\n  /** The current font atlas */\n  private _atlas?: FontAtlas;\n\n  get texture(): Texture | undefined {\n    return this._atlas;\n  }\n\n  get mapping(): CharacterMapping | undefined {\n    return this._atlas && this._atlas.mapping;\n  }\n\n  get scale(): number {\n    return HEIGHT_SCALE;\n  }\n\n  setProps(props: FontSettings = {}) {\n    Object.assign(this.props, props);\n\n    // update cache key\n    const oldKey = this._key;\n    this._key = this._getKey();\n\n    const charSet = getNewChars(this._key, this.props.characterSet);\n    const cachedFontAtlas = cache.get(this._key);\n\n    // if a fontAtlas associated with the new settings is cached and\n    // there are no new chars\n    if (cachedFontAtlas && charSet.size === 0) {\n      // update texture with cached fontAtlas\n      if (this._key !== oldKey) {\n        this._atlas = cachedFontAtlas;\n      }\n      return;\n    }\n\n    // update fontAtlas with new settings\n    const fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);\n    this._atlas = fontAtlas;\n\n    // update cache\n    cache.set(this._key, fontAtlas);\n  }\n\n  private _generateFontAtlas(\n    key: string,\n    characterSet: Set<string>,\n    cachedFontAtlas?: FontAtlas\n  ): FontAtlas {\n    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n    const ctx = canvas.getContext('2d')!;\n\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 1. build mapping\n    const {mapping, canvasHeight, xOffset, yOffset} = buildMapping({\n      getFontWidth: char => ctx.measureText(char).width,\n      fontHeight: fontSize * HEIGHT_SCALE,\n      buffer,\n      characterSet,\n      maxCanvasWidth: MAX_CANVAS_WIDTH,\n      ...(cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })\n    });\n\n    // 2. update canvas\n    // copy old canvas data to new canvas only when height changed\n    if (canvas.height !== canvasHeight) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(imageData, 0, 0);\n    }\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 3. layout characters\n    if (sdf) {\n      const tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);\n      // used to store distance values from tinySDF\n      // tinySDF.size equals `fontSize + buffer * 2`\n      const imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);\n\n      for (const char of characterSet) {\n        populateAlphaChannel(tinySDF.draw(char), imageData);\n        ctx.putImageData(imageData, mapping[char].x - buffer, mapping[char].y + buffer);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(char, mapping[char].x, mapping[char].y + fontSize * BASELINE_SCALE);\n      }\n    }\n\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n\n  private _getKey(): string {\n    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    if (sdf) {\n      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;\n    }\n    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}