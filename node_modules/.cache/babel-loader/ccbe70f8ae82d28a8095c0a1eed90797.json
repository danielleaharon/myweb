{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Timeline } from '@luma.gl/core';\nimport { LIFECYCLE } from '../lifecycle/constants';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport { flatten } from '../utils/flatten';\nimport { Stats } from '@probe.gl/stats';\nimport ResourceManager from './resource/resource-manager';\nimport Viewport from '../viewports/viewport';\nimport { createProgramManager } from '../shaderlib';\nconst TRACE_SET_LAYERS = 'layerManager.setLayers';\nconst TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\nexport default class LayerManager {\n  constructor(gl, {\n    deck,\n    stats,\n    viewport: _viewport,\n    timeline\n  } = {}) {\n    _defineProperty(this, \"layers\", void 0);\n\n    _defineProperty(this, \"context\", void 0);\n\n    _defineProperty(this, \"resourceManager\", void 0);\n\n    _defineProperty(this, \"_lastRenderedLayers\", []);\n\n    _defineProperty(this, \"_needsRedraw\", false);\n\n    _defineProperty(this, \"_needsUpdate\", false);\n\n    _defineProperty(this, \"_nextLayers\", null);\n\n    _defineProperty(this, \"_debug\", false);\n\n    _defineProperty(this, \"activateViewport\", viewport => {\n      debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n\n      if (viewport) {\n        this.context.viewport = viewport;\n      }\n    });\n\n    this.layers = [];\n    this.resourceManager = new ResourceManager({\n      gl,\n      protocol: 'deck://'\n    });\n    this.context = {\n      mousePosition: null,\n      userData: {},\n      layerManager: this,\n      gl,\n      deck,\n      programManager: gl && createProgramManager(gl),\n      stats: stats || new Stats({\n        id: 'deck.gl'\n      }),\n      viewport: _viewport || new Viewport({\n        id: 'DEFAULT-INITIAL-VIEWPORT'\n      }),\n      timeline: timeline || new Timeline(),\n      resourceManager: this.resourceManager,\n      onError: undefined\n    };\n    Object.seal(this);\n  }\n\n  finalize() {\n    this.resourceManager.finalize();\n\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n  }\n\n  needsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    let redraw = this._needsRedraw;\n\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    for (const layer of this.layers) {\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n\n    return redraw;\n  }\n\n  needsUpdate() {\n    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {\n      return 'layers changed';\n    }\n\n    return this._needsUpdate;\n  }\n\n  setNeedsRedraw(reason) {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n\n  setNeedsUpdate(reason) {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n\n  getLayers({\n    layerIds\n  } = {}) {\n    return layerIds ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0)) : this.layers;\n  }\n\n  setProps(props) {\n    if ('debug' in props) {\n      this._debug = props.debug;\n    }\n\n    if ('userData' in props) {\n      this.context.userData = props.userData;\n    }\n\n    if ('layers' in props) {\n      this._nextLayers = props.layers;\n    }\n\n    if ('onError' in props) {\n      this.context.onError = props.onError;\n    }\n  }\n\n  setLayers(newLayers, reason) {\n    debug(TRACE_SET_LAYERS, this, reason, newLayers);\n    this._lastRenderedLayers = newLayers;\n    const flatLayers = flatten(newLayers, Boolean);\n\n    for (const layer of flatLayers) {\n      layer.context = this.context;\n    }\n\n    this._updateLayers(this.layers, flatLayers);\n  }\n\n  updateLayers() {\n    const reason = this.needsUpdate();\n\n    if (reason) {\n      this.setNeedsRedraw(\"updating layers: \".concat(reason));\n      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);\n    }\n\n    this._nextLayers = null;\n  }\n\n  _handleError(stage, error, layer) {\n    layer.raiseError(error, \"\".concat(stage, \" of \").concat(layer));\n  }\n\n  _updateLayers(oldLayers, newLayers) {\n    const oldLayerMap = {};\n\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log.warn(\"Multiple old layers with same id \".concat(oldLayer.id))();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n\n    const generatedLayers = [];\n\n    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n\n    this._finalizeOldLayers(oldLayerMap);\n\n    let needsUpdate = false;\n\n    for (const layer of generatedLayers) {\n      if (layer.hasUniformTransition()) {\n        needsUpdate = \"Uniform transition in \".concat(layer);\n        break;\n      }\n    }\n\n    this._needsUpdate = needsUpdate;\n    this.layers = generatedLayers;\n  }\n\n  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n      const oldLayer = oldLayerMap[newLayer.id];\n\n      if (oldLayer === null) {\n        log.warn(\"Multiple new layers with same id \".concat(newLayer.id))();\n      }\n\n      oldLayerMap[newLayer.id] = null;\n      let sublayers = null;\n\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n\n        if (!oldLayer) {\n          this._initializeLayer(newLayer);\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n\n          this._updateLayer(newLayer);\n        }\n\n        generatedLayers.push(newLayer);\n        sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;\n      } catch (err) {\n        this._handleError('matching', err, newLayer);\n      }\n\n      if (sublayers) {\n        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n      }\n    }\n  }\n\n  _finalizeOldLayers(oldLayerMap) {\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n\n      if (layer) {\n        this._finalizeLayer(layer);\n      }\n    }\n  }\n\n  _initializeLayer(layer) {\n    try {\n      layer._initialize();\n\n      layer.lifecycle = LIFECYCLE.INITIALIZED;\n    } catch (err) {\n      this._handleError('initialization', err, layer);\n    }\n  }\n\n  _transferLayerState(oldLayer, newLayer) {\n    newLayer._transferState(oldLayer);\n\n    newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n    if (newLayer !== oldLayer) {\n      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n    }\n  }\n\n  _updateLayer(layer) {\n    try {\n      layer._update();\n    } catch (err) {\n      this._handleError('update', err, layer);\n    }\n  }\n\n  _finalizeLayer(layer) {\n    this._needsRedraw = this._needsRedraw || \"finalized \".concat(layer);\n    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n\n    try {\n      layer._finalize();\n\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n    } catch (err) {\n      this._handleError('finalization', err, layer);\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/lib/layer-manager.ts"],"names":["TRACE_SET_LAYERS","TRACE_ACTIVATE_VIEWPORT","constructor","viewport","timeline","protocol","mousePosition","userData","layerManager","programManager","gl","createProgramManager","stats","id","resourceManager","onError","undefined","Object","finalize","needsRedraw","opts","clearRedrawFlags","redraw","layerNeedsRedraw","layer","needsUpdate","setNeedsRedraw","setNeedsUpdate","getLayers","layerIds","layerId","setProps","props","setLayers","debug","flatLayers","flatten","updateLayers","reason","_handleError","_updateLayers","oldLayerMap","oldLayer","log","generatedLayers","_updateSublayersRecursively","newLayer","sublayers","_finalizeOldLayers","_initializeLayer","LIFECYCLE","_transferLayerState","_updateLayer","_finalizeLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Timeline} from '@luma.gl/core';\nimport {LIFECYCLE} from '../lifecycle/constants';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport {flatten} from '../utils/flatten';\nimport {Stats} from '@probe.gl/stats';\nimport ResourceManager from './resource/resource-manager';\n\nimport Viewport from '../viewports/viewport';\nimport {createProgramManager} from '../shaderlib';\n\nimport type Layer from './layer';\nimport type CompositeLayer from './composite-layer';\nimport type Deck from './deck';\nimport type {ProgramManager} from '@luma.gl/engine';\n\nconst TRACE_SET_LAYERS = 'layerManager.setLayers';\nconst TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\n\nexport type LayerContext = {\n  layerManager: LayerManager;\n  resourceManager: ResourceManager;\n  deck?: Deck;\n  gl: WebGLRenderingContext;\n  programManager: ProgramManager;\n  stats: Stats;\n  viewport: Viewport;\n  timeline: Timeline;\n  mousePosition: {x: number; y: number} | null;\n  userData: any;\n  onError?: <PropsT>(error: Error, source: Layer<PropsT>) => void;\n};\n\nexport type LayersList = (Layer | undefined | false | null | LayersList)[];\n\nexport default class LayerManager {\n  layers: Layer[];\n  context: LayerContext;\n  resourceManager: ResourceManager;\n\n  private _lastRenderedLayers: LayersList = [];\n  private _needsRedraw: string | false = false;\n  private _needsUpdate: string | false = false;\n  private _nextLayers: LayersList | null = null;\n  private _debug: boolean = false;\n\n  // eslint-disable-next-line\n  constructor(\n    gl,\n    {\n      deck,\n      stats,\n      viewport,\n      timeline\n    }: {\n      deck?: Deck;\n      stats?: Stats;\n      viewport?: Viewport;\n      timeline?: Timeline;\n    } = {}\n  ) {\n    // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n\n    // `this._lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n    this.layers = [];\n    this.resourceManager = new ResourceManager({gl, protocol: 'deck://'});\n\n    this.context = {\n      mousePosition: null,\n      userData: {},\n      layerManager: this,\n      gl,\n      deck,\n      // Enabling luma.gl Program caching using private API (_cachePrograms)\n      programManager: gl && createProgramManager(gl),\n      stats: stats || new Stats({id: 'deck.gl'}),\n      // Make sure context.viewport is not empty on the first layer initialization\n      viewport: viewport || new Viewport({id: 'DEFAULT-INITIAL-VIEWPORT'}), // Current viewport, exposed to layers for project* function\n      timeline: timeline || new Timeline(),\n      resourceManager: this.resourceManager,\n      onError: undefined\n    };\n\n    Object.seal(this);\n  }\n\n  /** Method to call when the layer manager is not needed anymore. */\n  finalize() {\n    this.resourceManager.finalize();\n    // Finalize all layers\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n  }\n\n  /** Check if a redraw is needed */\n  needsRedraw(\n    opts: {\n      /** Reset redraw flags to false after the call */\n      clearRedrawFlags: boolean;\n    } = {clearRedrawFlags: false}\n  ): string | false {\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    // This layers list doesn't include sublayers, relying on composite layers\n    for (const layer of this.layers) {\n      // Call every layer to clear their flags\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n\n    return redraw;\n  }\n\n  /** Check if a deep update of all layers is needed */\n  needsUpdate(): string | false {\n    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {\n      // New layers array may be the same as the old one if `setProps` is called by React\n      return 'layers changed';\n    }\n    return this._needsUpdate;\n  }\n\n  /** Layers will be redrawn (in next animation frame) */\n  setNeedsRedraw(reason: string): void {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n\n  /** Layers will be updated deeply (in next animation frame)\n    Potentially regenerating attributes and sub layers */\n  setNeedsUpdate(reason: string): void {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n\n  /** Gets a list of currently rendered layers. Optionally filter by id. */\n  getLayers({layerIds}: {layerIds?: string[]} = {}): Layer[] {\n    // Filtering by layerId compares beginning of strings, so that sublayers will be included\n    // Dependes on the convention of adding suffixes to the parent's layer name\n    return layerIds\n      ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0))\n      : this.layers;\n  }\n\n  /** Set props needed for layer rendering and picking. */\n  setProps(props: any): void {\n    if ('debug' in props) {\n      this._debug = props.debug;\n    }\n\n    // A way for apps to add data to context that can be accessed in layers\n    if ('userData' in props) {\n      this.context.userData = props.userData;\n    }\n\n    // New layers will be processed in `updateLayers` in the next update cycle\n    if ('layers' in props) {\n      this._nextLayers = props.layers;\n    }\n\n    if ('onError' in props) {\n      this.context.onError = props.onError;\n    }\n  }\n\n  /** Supply a new layer list, initiating sublayer generation and layer matching */\n  setLayers(newLayers: LayersList, reason?: string): void {\n    debug(TRACE_SET_LAYERS, this, reason, newLayers);\n\n    this._lastRenderedLayers = newLayers;\n\n    const flatLayers = flatten(newLayers, Boolean) as Layer[];\n\n    for (const layer of flatLayers) {\n      layer.context = this.context;\n    }\n\n    this._updateLayers(this.layers, flatLayers);\n  }\n\n  /** Update layers from last cycle if `setNeedsUpdate()` has been called */\n  updateLayers(): void {\n    // NOTE: For now, even if only some layer has changed, we update all layers\n    // to ensure that layer id maps etc remain consistent even if different\n    // sublayers are rendered\n    const reason = this.needsUpdate();\n    if (reason) {\n      this.setNeedsRedraw(`updating layers: ${reason}`);\n      // Force a full update\n      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);\n    }\n    // Updated, clear the backlog\n    this._nextLayers = null;\n  }\n\n  //\n  // INTERNAL METHODS\n  //\n\n  /** Make a viewport \"current\" in layer context, updating viewportChanged flags */\n  activateViewport = (viewport: Viewport) => {\n    debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n    if (viewport) {\n      this.context.viewport = viewport;\n    }\n  };\n\n  private _handleError(stage: string, error: Error, layer: Layer) {\n    layer.raiseError(error, `${stage} of ${layer}`);\n  }\n\n  // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n  /** Match all layers, checking for caught errors\n    to avoid having an exception in one layer disrupt other layers */\n  private _updateLayers(oldLayers: Layer[], newLayers: Layer[]): void {\n    // Create old layer map\n    const oldLayerMap: {[layerId: string]: Layer | null} = {};\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log.warn(`Multiple old layers with same id ${oldLayer.id}`)();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n\n    // Allocate array for generated layers\n    const generatedLayers: Layer[] = [];\n\n    // Match sublayers\n    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n\n    // Finalize unmatched layers\n    this._finalizeOldLayers(oldLayerMap);\n\n    let needsUpdate: string | false = false;\n    for (const layer of generatedLayers) {\n      if (layer.hasUniformTransition()) {\n        needsUpdate = `Uniform transition in ${layer}`;\n        break;\n      }\n    }\n\n    this._needsUpdate = needsUpdate;\n    this.layers = generatedLayers;\n  }\n\n  /* eslint-disable complexity,max-statements */\n  // Note: adds generated layers to `generatedLayers` array parameter\n  private _updateSublayersRecursively(\n    newLayers: Layer[],\n    oldLayerMap: {[layerId: string]: Layer | null},\n    generatedLayers: Layer[]\n  ) {\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n\n      // Given a new coming layer, find its matching old layer (if any)\n      const oldLayer = oldLayerMap[newLayer.id];\n      if (oldLayer === null) {\n        // null, rather than undefined, means this id was originally there\n        log.warn(`Multiple new layers with same id ${newLayer.id}`)();\n      }\n      // Remove the old layer from candidates, as it has been matched with this layer\n      oldLayerMap[newLayer.id] = null;\n\n      let sublayers: Layer[] | null = null;\n\n      // We must not generate exceptions until after layer matching is complete\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n\n        if (!oldLayer) {\n          this._initializeLayer(newLayer);\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n          this._updateLayer(newLayer);\n        }\n        generatedLayers.push(newLayer);\n\n        // Call layer lifecycle method: render sublayers\n        sublayers = newLayer.isComposite ? (newLayer as CompositeLayer).getSubLayers() : null;\n        // End layer lifecycle method: render sublayers\n      } catch (err) {\n        this._handleError('matching', err as Error, newLayer); // Record first exception\n      }\n\n      if (sublayers) {\n        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n      }\n    }\n  }\n  /* eslint-enable complexity,max-statements */\n\n  // Finalize any old layers that were not matched\n  private _finalizeOldLayers(oldLayerMap: {[layerId: string]: Layer | null}): void {\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n      if (layer) {\n        this._finalizeLayer(layer);\n      }\n    }\n  }\n\n  // / EXCEPTION SAFE LAYER ACCESS\n\n  /** Safely initializes a single layer, calling layer methods */\n  private _initializeLayer(layer: Layer): void {\n    try {\n      layer._initialize();\n      layer.lifecycle = LIFECYCLE.INITIALIZED;\n    } catch (err) {\n      this._handleError('initialization', err as Error, layer);\n      // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n    }\n  }\n\n  /** Transfer state from one layer to a newer version */\n  private _transferLayerState(oldLayer: Layer, newLayer: Layer): void {\n    newLayer._transferState(oldLayer);\n    newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n    if (newLayer !== oldLayer) {\n      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n    }\n  }\n\n  /** Safely updates a single layer, cleaning all flags */\n  private _updateLayer(layer: Layer): void {\n    try {\n      layer._update();\n    } catch (err) {\n      this._handleError('update', err as Error, layer);\n    }\n  }\n\n  /** Safely finalizes a single layer, removing all resources */\n  private _finalizeLayer(layer: Layer): void {\n    this._needsRedraw = this._needsRedraw || `finalized ${layer}`;\n\n    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n\n    try {\n      layer._finalize();\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n    } catch (err) {\n      this._handleError('finalization', err as Error, layer);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}