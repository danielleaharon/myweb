{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { hasFeature, FEATURES, Buffer } from '@luma.gl/core';\nimport ShaderAttribute from './shader-attribute';\nimport { glArrayFromType } from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport { toDoublePrecisionArray } from '../../utils/math-utils';\nimport log from '../../utils/log';\n\nfunction getStride(accessor) {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\n\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n\n  const stride = getStride(baseAccessor);\n  const vertexOffset = shaderAttributeOptions.vertexOffset !== undefined ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);\n  return { ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\n\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n  return {\n    high: resolvedOptions,\n    low: { ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\n\nexport default class DataColumn {\n  constructor(gl, opts, state) {\n    _defineProperty(this, \"gl\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"size\", void 0);\n\n    _defineProperty(this, \"settings\", void 0);\n\n    _defineProperty(this, \"value\", void 0);\n\n    _defineProperty(this, \"doublePrecision\", void 0);\n\n    _defineProperty(this, \"_buffer\", void 0);\n\n    _defineProperty(this, \"state\", void 0);\n\n    this.gl = gl;\n    this.id = opts.id || '';\n    this.size = opts.size || 1;\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === 5130;\n    let {\n      defaultValue\n    } = opts;\n    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);\n    let bufferType;\n\n    if (doublePrecision) {\n      bufferType = 5126;\n    } else if (!logicalType && opts.isIndexed) {\n      bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;\n    } else {\n      bufferType = logicalType || 5126;\n    }\n\n    let defaultType = glArrayFromType(logicalType || bufferType || 5126);\n    this.doublePrecision = doublePrecision;\n\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n\n    this.value = null;\n    this.settings = { ...opts,\n      defaultType,\n      defaultValue: defaultValue,\n      logicalType,\n      type: bufferType,\n      size: this.size,\n      bytesPerElement: defaultType.BYTES_PER_ELEMENT\n    };\n    this.state = { ...state,\n      externalBuffer: null,\n      bufferAccessor: this.settings,\n      allocatedValue: null,\n      numInstances: 0,\n      bounds: null,\n      constant: false\n    };\n    this._buffer = null;\n  }\n\n  get isConstant() {\n    return this.state.constant;\n  }\n\n  get buffer() {\n    if (!this._buffer) {\n      const {\n        isIndexed,\n        type\n      } = this.settings;\n      this._buffer = new Buffer(this.gl, {\n        id: this.id,\n        target: isIndexed ? 34963 : 34962,\n        accessor: {\n          type\n        }\n      });\n    }\n\n    return this._buffer;\n  }\n\n  get byteOffset() {\n    const accessor = this.getAccessor();\n\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n\n    return 0;\n  }\n\n  get numInstances() {\n    return this.state.numInstances;\n  }\n\n  set numInstances(n) {\n    this.state.numInstances = n;\n  }\n\n  delete() {\n    if (this._buffer) {\n      this._buffer.delete();\n\n      this._buffer = null;\n    }\n\n    typedArrayManager.release(this.state.allocatedValue);\n  }\n\n  getShaderAttributes(id, options) {\n    if (this.doublePrecision) {\n      const shaderAttributes = {};\n      const isBuffer64Bit = this.value instanceof Float64Array;\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});\n      shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n      shaderAttributes[\"\".concat(id, \"64Low\")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);\n      return shaderAttributes;\n    }\n\n    if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n      return {\n        [id]: new ShaderAttribute(this, shaderAttributeDef)\n      };\n    }\n\n    return {\n      [id]: this\n    };\n  }\n\n  getBuffer() {\n    if (this.state.constant) {\n      return null;\n    }\n\n    return this.state.externalBuffer || this._buffer;\n  }\n\n  getValue() {\n    if (this.state.constant) {\n      return this.value;\n    }\n\n    return [this.getBuffer(), this.getAccessor()];\n  }\n\n  getAccessor() {\n    return this.state.bufferAccessor;\n  }\n\n  getBounds() {\n    if (this.state.bounds) {\n      return this.state.bounds;\n    }\n\n    let result = null;\n\n    if (this.state.constant && this.value) {\n      const min = Array.from(this.value);\n      result = [min, min];\n    } else {\n      const {\n        value,\n        numInstances,\n        size\n      } = this;\n      const len = numInstances * size;\n\n      if (value && len && value.length >= len) {\n        const min = new Array(size).fill(Infinity);\n        const max = new Array(size).fill(-Infinity);\n\n        for (let i = 0; i < len;) {\n          for (let j = 0; j < size; j++) {\n            const v = value[i++];\n            if (v < min[j]) min[j] = v;\n            if (v > max[j]) max[j] = v;\n          }\n        }\n\n        result = [min, max];\n      }\n    }\n\n    this.state.bounds = result;\n    return result;\n  }\n\n  setData(data) {\n    const {\n      state\n    } = this;\n    let opts;\n\n    if (ArrayBuffer.isView(data)) {\n      opts = {\n        value: data\n      };\n    } else if (data instanceof Buffer) {\n      opts = {\n        buffer: data\n      };\n    } else {\n      opts = data;\n    }\n\n    const accessor = { ...this.settings,\n      ...opts\n    };\n    state.bufferAccessor = accessor;\n    state.bounds = null;\n\n    if (opts.constant) {\n      let value = opts.value;\n      value = this._normalizeValue(value, [], 0);\n\n      if (this.settings.normalized) {\n        value = this.normalizeConstant(value);\n      }\n\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n\n      if (!hasChanged) {\n        return false;\n      }\n\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = value;\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value || null;\n      const isBuffer64Bit = opts.value instanceof Float64Array;\n      accessor.type = opts.type || buffer.accessor.type;\n      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n      accessor.stride = getStride(accessor);\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n\n      let value = opts.value;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n      const {\n        buffer,\n        byteOffset\n      } = this;\n\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = toDoublePrecisionArray(value, accessor);\n      }\n\n      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;\n\n      if (buffer.byteLength < requiredBufferSize) {\n        buffer.reallocate(requiredBufferSize);\n      }\n\n      buffer.setAccessor(null);\n      buffer.subData({\n        data: value,\n        offset: byteOffset\n      });\n      accessor.type = opts.type || buffer.accessor.type;\n    }\n\n    return true;\n  }\n\n  updateSubBuffer(opts = {}) {\n    this.state.bounds = null;\n    const value = this.value;\n    const {\n      startOffset = 0,\n      endOffset\n    } = opts;\n    this.buffer.subData({\n      data: this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {\n        size: this.size,\n        startIndex: startOffset,\n        endIndex: endOffset\n      }) : value.subarray(startOffset, endOffset),\n      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n    });\n  }\n\n  allocate(numInstances, copy = false) {\n    const {\n      state\n    } = this;\n    const oldValue = state.allocatedValue;\n    const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.settings.defaultType,\n      copy\n    });\n    this.value = value;\n    const {\n      buffer,\n      byteOffset\n    } = this;\n\n    if (buffer.byteLength < value.byteLength + byteOffset) {\n      buffer.reallocate(value.byteLength + byteOffset);\n\n      if (copy && oldValue) {\n        buffer.subData({\n          data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n          offset: byteOffset\n        });\n      }\n    }\n\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    state.bufferAccessor = this.settings;\n    return true;\n  }\n\n  _checkExternalBuffer(opts) {\n    const {\n      value\n    } = opts;\n\n    if (!ArrayBuffer.isView(value)) {\n      throw new Error(\"Attribute \".concat(this.id, \" value is not TypedArray\"));\n    }\n\n    const ArrayType = this.settings.defaultType;\n    let illegalArrayType = false;\n\n    if (this.doublePrecision) {\n      illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n    }\n\n    if (illegalArrayType) {\n      throw new Error(\"Attribute \".concat(this.id, \" does not support \").concat(value.constructor.name));\n    }\n\n    if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n      log.warn(\"Attribute \".concat(this.id, \" is normalized\"))();\n    }\n  }\n\n  normalizeConstant(value) {\n    switch (this.settings.type) {\n      case 5120:\n        return new Float32Array(value).map(x => (x + 128) / 255 * 2 - 1);\n\n      case 5122:\n        return new Float32Array(value).map(x => (x + 32768) / 65535 * 2 - 1);\n\n      case 5121:\n        return new Float32Array(value).map(x => x / 255);\n\n      case 5123:\n        return new Float32Array(value).map(x => x / 65535);\n\n      default:\n        return value;\n    }\n  }\n\n  _normalizeValue(value, out, start) {\n    const {\n      defaultValue,\n      size\n    } = this.settings;\n\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n\n    if (!value) {\n      out[start] = defaultValue[0];\n      return out;\n    }\n\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n\n      default:\n        let i = size;\n\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n\n    }\n\n    return out;\n  }\n\n  _areValuesEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n\n    const {\n      size\n    } = this;\n\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/lib/attribute/data-column.ts"],"names":["accessor","shaderAttributeOptions","log","stride","getStride","vertexOffset","baseAccessor","elementOffset","offset","resolvedOptions","resolveShaderAttribute","high","low","constructor","opts","logicalType","doublePrecision","defaultValue","Number","bufferType","gl","hasFeature","FEATURES","defaultType","glArrayFromType","type","size","bytesPerElement","BYTES_PER_ELEMENT","externalBuffer","bufferAccessor","allocatedValue","numInstances","bounds","constant","isConstant","buffer","id","target","isIndexed","byteOffset","delete","typedArrayManager","getShaderAttributes","shaderAttributes","isBuffer64Bit","doubleShaderAttributeDefs","resolveDoublePrecisionShaderAttributes","options","shaderAttributeDef","getBuffer","getValue","getAccessor","getBounds","result","min","Array","len","value","max","i","j","v","setData","state","ArrayBuffer","data","hasChanged","toDoublePrecisionArray","requiredBufferSize","updateSubBuffer","startOffset","endOffset","startIndex","endIndex","allocate","copy","oldValue","_checkExternalBuffer","ArrayType","illegalArrayType","normalizeConstant","x","_normalizeValue","out","start","_areValuesEqual","value1","value2"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport GL from '@luma.gl/constants';\nimport {hasFeature, FEATURES, Buffer} from '@luma.gl/core';\nimport ShaderAttribute, {IShaderAttribute} from './shader-attribute';\nimport {glArrayFromType} from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport {toDoublePrecisionArray} from '../../utils/math-utils';\nimport log from '../../utils/log';\n\nimport type {Buffer as LumaBuffer} from '@luma.gl/webgl';\nimport type {TypedArray, NumericArray, TypedArrayConstructor} from '../../types/types';\n\nexport type BufferAccessor = {\n  /** A WebGL data type, see [vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer#parameters). */\n  type?: number;\n  /** The number of elements per vertex attribute. */\n  size?: number;\n  /** 1 if instanced. */\n  divisor?: number;\n  /** Offset of the first vertex attribute into the buffer, in bytes. */\n  offset?: number;\n  /** The offset between the beginning of consecutive vertex attributes, in bytes. */\n  stride?: number;\n  /** Whether data values should be normalized. Note that all color attributes in deck.gl layers are normalized by default. */\n  normalized?: boolean;\n  integer?: boolean;\n};\n\nexport type ShaderAttributeOptions = Partial<BufferAccessor> & {\n  offset: number;\n  stride: number;\n  vertexOffset?: number;\n  elementOffset?: number;\n};\n\nfunction getStride(accessor: DataColumnSettings<any>): number {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\n\nfunction resolveShaderAttribute(\n  baseAccessor: DataColumnSettings<any>,\n  shaderAttributeOptions: Partial<ShaderAttributeOptions>\n): ShaderAttributeOptions {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n\n  // All shader attributes share the parent's stride\n  const stride = getStride(baseAccessor);\n  // `vertexOffset` is used to access the neighboring vertex's value\n  // e.g. `nextPositions` in polygon\n  const vertexOffset =\n    shaderAttributeOptions.vertexOffset !== undefined\n      ? shaderAttributeOptions.vertexOffset\n      : baseAccessor.vertexOffset || 0;\n  // `elementOffset` is defined when shader attribute's size is smaller than the parent's\n  // e.g. `translations` in transform matrix\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset =\n    // offsets defined by the attribute\n    vertexOffset * stride +\n    elementOffset * baseAccessor.bytesPerElement +\n    // offsets defined by external buffers if any\n    (baseAccessor.offset || 0);\n\n  return {\n    ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\n\nfunction resolveDoublePrecisionShaderAttributes(\n  baseAccessor: DataColumnSettings<any>,\n  shaderAttributeOptions: Partial<ShaderAttributeOptions>\n): {\n  high: ShaderAttributeOptions;\n  low: ShaderAttributeOptions;\n} {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n\n  return {\n    high: resolvedOptions,\n    low: {\n      ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\n\nexport type DataColumnOptions<Options> = Options &\n  BufferAccessor & {\n    id?: string;\n    vertexOffset?: number;\n    fp64?: boolean;\n    logicalType?: number;\n    isIndexed?: boolean;\n    defaultValue?: number | number[];\n  };\n\ntype DataColumnSettings<Options> = DataColumnOptions<Options> & {\n  type: number;\n  size: number;\n  logicalType?: number;\n  bytesPerElement: number;\n  defaultValue: number[];\n  defaultType: TypedArrayConstructor;\n};\n\ntype DataColumnInternalState<Options, State> = State & {\n  externalBuffer: LumaBuffer | null;\n  bufferAccessor: DataColumnSettings<Options>;\n  allocatedValue: TypedArray | null;\n  numInstances: number;\n  bounds: [number[], number[]] | null;\n  constant: boolean;\n};\n\nexport default class DataColumn<Options, State> implements IShaderAttribute {\n  gl: WebGLRenderingContext;\n  id: string;\n  size: number;\n  settings: DataColumnSettings<Options>;\n  value: NumericArray | null;\n  doublePrecision: boolean;\n\n  protected _buffer: LumaBuffer | null;\n  protected state: DataColumnInternalState<Options, State>;\n\n  /* eslint-disable max-statements */\n  constructor(gl: WebGLRenderingContext, opts: DataColumnOptions<Options>, state: State) {\n    this.gl = gl;\n    this.id = opts.id || '';\n    this.size = opts.size || 1;\n\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === GL.DOUBLE;\n\n    let {defaultValue} = opts;\n    defaultValue = Number.isFinite(defaultValue)\n      ? [defaultValue]\n      : defaultValue || new Array(this.size).fill(0);\n\n    let bufferType: number;\n    if (doublePrecision) {\n      bufferType = GL.FLOAT;\n    } else if (!logicalType && opts.isIndexed) {\n      bufferType =\n        gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? GL.UNSIGNED_INT : GL.UNSIGNED_SHORT;\n    } else {\n      bufferType = logicalType || GL.FLOAT;\n    }\n\n    // This is the attribute type defined by the layer\n    // If an external buffer is provided, this.type may be overwritten\n    // But we always want to use defaultType for allocation\n    let defaultType = glArrayFromType(logicalType || bufferType || GL.FLOAT);\n    this.doublePrecision = doublePrecision;\n\n    // `fp64: false` tells a double-precision attribute to allocate Float32Arrays\n    // by default when using auto-packing. This is more efficient in use cases where\n    // high precision is unnecessary, but the `64Low` attribute is still required\n    // by the shader.\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n\n    this.value = null;\n    this.settings = {\n      ...opts,\n      defaultType,\n      defaultValue: defaultValue as number[],\n      logicalType,\n      type: bufferType,\n      size: this.size,\n      bytesPerElement: defaultType.BYTES_PER_ELEMENT\n    };\n    this.state = {\n      ...state,\n      externalBuffer: null,\n      bufferAccessor: this.settings,\n      allocatedValue: null,\n      numInstances: 0,\n      bounds: null,\n      constant: false\n    };\n    this._buffer = null;\n  }\n  /* eslint-enable max-statements */\n\n  get isConstant(): boolean {\n    return this.state.constant;\n  }\n\n  get buffer(): LumaBuffer {\n    if (!this._buffer) {\n      const {isIndexed, type} = this.settings;\n      this._buffer = new Buffer(this.gl, {\n        id: this.id,\n        target: isIndexed ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER,\n        accessor: {type}\n      }) as LumaBuffer;\n    }\n    return this._buffer;\n  }\n\n  get byteOffset(): number {\n    const accessor = this.getAccessor();\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n    return 0;\n  }\n\n  get numInstances(): number {\n    return this.state.numInstances;\n  }\n\n  set numInstances(n: number) {\n    this.state.numInstances = n;\n  }\n\n  delete(): void {\n    if (this._buffer) {\n      this._buffer.delete();\n      this._buffer = null;\n    }\n    typedArrayManager.release(this.state.allocatedValue);\n  }\n\n  getShaderAttributes(\n    id: string,\n    options: Partial<ShaderAttributeOptions> | null\n  ): Record<string, IShaderAttribute> {\n    if (this.doublePrecision) {\n      const shaderAttributes = {};\n      const isBuffer64Bit = this.value instanceof Float64Array;\n\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(\n        this.getAccessor(),\n        options || {}\n      );\n\n      shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n      shaderAttributes[`${id}64Low`] = isBuffer64Bit\n        ? new ShaderAttribute(this, doubleShaderAttributeDefs.low)\n        : new Float32Array(this.size); // use constant for low part if buffer is 32-bit\n      return shaderAttributes;\n    }\n    if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n      return {[id]: new ShaderAttribute(this, shaderAttributeDef)};\n    }\n    return {[id]: this};\n  }\n\n  getBuffer(): LumaBuffer | null {\n    if (this.state.constant) {\n      return null;\n    }\n    return this.state.externalBuffer || this._buffer;\n  }\n\n  getValue(): [LumaBuffer, BufferAccessor] | NumericArray | null {\n    if (this.state.constant) {\n      return this.value;\n    }\n    return [this.getBuffer() as LumaBuffer, this.getAccessor() as BufferAccessor];\n  }\n\n  getAccessor(): DataColumnSettings<Options> {\n    return this.state.bufferAccessor;\n  }\n\n  // Returns [min: Array(size), max: Array(size)]\n  /* eslint-disable max-depth */\n  getBounds(): [number[], number[]] | null {\n    if (this.state.bounds) {\n      return this.state.bounds;\n    }\n    let result: [number[], number[]] | null = null;\n    if (this.state.constant && this.value) {\n      const min = Array.from(this.value);\n      result = [min, min];\n    } else {\n      const {value, numInstances, size} = this;\n      const len = numInstances * size;\n      if (value && len && value.length >= len) {\n        const min = new Array(size).fill(Infinity);\n        const max = new Array(size).fill(-Infinity);\n        for (let i = 0; i < len; ) {\n          for (let j = 0; j < size; j++) {\n            const v = value[i++];\n            if (v < min[j]) min[j] = v;\n            if (v > max[j]) max[j] = v;\n          }\n        }\n        result = [min, max];\n      }\n    }\n    this.state.bounds = result;\n    return result;\n  }\n\n  // returns true if success\n  // eslint-disable-next-line max-statements\n  setData(\n    data:\n      | TypedArray\n      | LumaBuffer\n      | ({\n          constant?: boolean;\n          value?: NumericArray;\n          buffer?: LumaBuffer;\n        } & Partial<BufferAccessor>)\n  ): boolean {\n    const {state} = this;\n\n    let opts: {\n      constant?: boolean;\n      value?: NumericArray;\n      buffer?: LumaBuffer;\n    } & Partial<BufferAccessor>;\n    if (ArrayBuffer.isView(data)) {\n      opts = {value: data};\n    } else if (data instanceof Buffer) {\n      opts = {buffer: data as LumaBuffer};\n    } else {\n      opts = data;\n    }\n\n    const accessor: DataColumnSettings<Options> = {...this.settings, ...opts};\n    state.bufferAccessor = accessor;\n    state.bounds = null; // clear cached bounds\n\n    if (opts.constant) {\n      // set constant\n      let value = opts.value as NumericArray;\n      value = this._normalizeValue(value, [], 0);\n      if (this.settings.normalized) {\n        value = this.normalizeConstant(value);\n      }\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n\n      if (!hasChanged) {\n        return false;\n      }\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = value;\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value || null;\n      const isBuffer64Bit = opts.value instanceof Float64Array;\n\n      // Copy the type of the buffer into the accessor\n      // @ts-ignore\n      accessor.type = opts.type || buffer.accessor.type;\n      // @ts-ignore\n      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n      accessor.stride = getStride(accessor);\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n\n      let value = opts.value as TypedArray;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n\n      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n\n      const {buffer, byteOffset} = this;\n\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = toDoublePrecisionArray(value, accessor);\n      }\n\n      // A small over allocation is used as safety margin\n      // Shader attributes may try to access this buffer with bigger offsets\n      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;\n      if (buffer.byteLength < requiredBufferSize) {\n        buffer.reallocate(requiredBufferSize);\n      }\n      // Hack: force Buffer to infer data type\n      buffer.setAccessor(null);\n      buffer.subData({data: value, offset: byteOffset});\n      // @ts-ignore\n      accessor.type = opts.type || buffer.accessor.type;\n    }\n\n    return true;\n  }\n\n  updateSubBuffer(\n    opts: {\n      startOffset?: number;\n      endOffset?: number;\n    } = {}\n  ): void {\n    this.state.bounds = null; // clear cached bounds\n\n    const value = this.value as TypedArray;\n    const {startOffset = 0, endOffset} = opts;\n    this.buffer.subData({\n      data:\n        this.doublePrecision && value instanceof Float64Array\n          ? toDoublePrecisionArray(value, {\n              size: this.size,\n              startIndex: startOffset,\n              endIndex: endOffset\n            })\n          : value.subarray(startOffset, endOffset),\n      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n    });\n  }\n\n  allocate(numInstances: number, copy: boolean = false): boolean {\n    const {state} = this;\n    const oldValue = state.allocatedValue;\n\n    // Allocate at least one element to ensure a valid buffer\n    const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.settings.defaultType,\n      copy\n    });\n\n    this.value = value;\n\n    const {buffer, byteOffset} = this;\n\n    if (buffer.byteLength < value.byteLength + byteOffset) {\n      buffer.reallocate(value.byteLength + byteOffset);\n\n      if (copy && oldValue) {\n        // Upload the full existing attribute value to the GPU, so that updateBuffer\n        // can choose to only update a partial range.\n        // TODO - copy old buffer to new buffer on the GPU\n        buffer.subData({\n          data:\n            oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n          offset: byteOffset\n        });\n      }\n    }\n\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    state.bufferAccessor = this.settings;\n    return true;\n  }\n\n  // PRIVATE HELPER METHODS\n  protected _checkExternalBuffer(opts: {value?: NumericArray; normalized?: boolean}): void {\n    const {value} = opts;\n    if (!ArrayBuffer.isView(value)) {\n      throw new Error(`Attribute ${this.id} value is not TypedArray`);\n    }\n    const ArrayType = this.settings.defaultType;\n\n    let illegalArrayType = false;\n    if (this.doublePrecision) {\n      // not 32bit or 64bit\n      illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n    }\n    if (illegalArrayType) {\n      throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);\n    }\n    if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n      log.warn(`Attribute ${this.id} is normalized`)();\n    }\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n  normalizeConstant(value: NumericArray): NumericArray {\n    switch (this.settings.type) {\n      case GL.BYTE:\n        // normalize [-128, 127] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 128) / 255) * 2 - 1);\n\n      case GL.SHORT:\n        // normalize [-32768, 32767] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 32768) / 65535) * 2 - 1);\n\n      case GL.UNSIGNED_BYTE:\n        // normalize [0, 255] to [0, 1]\n        return new Float32Array(value).map(x => x / 255);\n\n      case GL.UNSIGNED_SHORT:\n        // normalize [0, 65535] to [0, 1]\n        return new Float32Array(value).map(x => x / 65535);\n\n      default:\n        // No normalization for gl.FLOAT and gl.HALF_FLOAT\n        return value;\n    }\n  }\n\n  /* check user supplied values and apply fallback */\n  protected _normalizeValue(value: any, out: NumericArray, start: number): NumericArray {\n    const {defaultValue, size} = this.settings;\n\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n    if (!value) {\n      out[start] = defaultValue[0];\n      return out;\n    }\n\n    // Important - switch cases are 5x more performant than a for loop!\n    /* eslint-disable no-fallthrough, default-case */\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n\n      default:\n        // In the rare case where the attribute size > 4, do it the slow way\n        // This is used for e.g. transform matrices\n        let i = size;\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n    }\n\n    return out;\n  }\n\n  protected _areValuesEqual(value1: any, value2: any): boolean {\n    if (!value1 || !value2) {\n      return false;\n    }\n    const {size} = this;\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}