{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Vector3 from './vector3';\nimport { formatValue, equals, config } from '../lib/common';\nimport { degrees, radians, clamp } from '../lib/common';\nimport * as vec3 from 'gl-matrix/vec3';\nconst EPSILON = 0.000001;\nconst EARTH_RADIUS_METERS = 6371000;\nexport default class SphericalCoordinates {\n  constructor({\n    phi = 0,\n    theta = 0,\n    radius = 1,\n    bearing,\n    pitch,\n    altitude,\n    radiusScale = EARTH_RADIUS_METERS\n  } = {}) {\n    _defineProperty(this, \"phi\", void 0);\n\n    _defineProperty(this, \"theta\", void 0);\n\n    _defineProperty(this, \"radius\", void 0);\n\n    _defineProperty(this, \"radiusScale\", void 0);\n\n    this.phi = phi;\n    this.theta = theta;\n    this.radius = radius || altitude || 1;\n    this.radiusScale = radiusScale || 1;\n\n    if (bearing !== undefined) {\n      this.bearing = bearing;\n    }\n\n    if (pitch !== undefined) {\n      this.pitch = pitch;\n    }\n\n    this.check();\n  }\n\n  toString() {\n    return this.formatString(config);\n  }\n\n  formatString({\n    printTypes = false\n  }) {\n    const f = formatValue;\n    return \"\".concat(printTypes ? 'Spherical' : '', \"[rho:\").concat(f(this.radius), \",theta:\").concat(f(this.theta), \",phi:\").concat(f(this.phi), \"]\");\n  }\n\n  equals(other) {\n    return equals(this.radius, other.radius) && equals(this.theta, other.theta) && equals(this.phi, other.phi);\n  }\n\n  exactEquals(other) {\n    return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;\n  }\n\n  get bearing() {\n    return 180 - degrees(this.phi);\n  }\n\n  set bearing(v) {\n    this.phi = Math.PI - radians(v);\n  }\n\n  get pitch() {\n    return degrees(this.theta);\n  }\n\n  set pitch(v) {\n    this.theta = radians(v);\n  }\n\n  get longitude() {\n    return degrees(this.phi);\n  }\n\n  get latitude() {\n    return degrees(this.theta);\n  }\n\n  get lng() {\n    return degrees(this.phi);\n  }\n\n  get lat() {\n    return degrees(this.theta);\n  }\n\n  get z() {\n    return (this.radius - 1) * this.radiusScale;\n  }\n\n  set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this.check();\n  }\n\n  clone() {\n    return new SphericalCoordinates().copy(this);\n  }\n\n  copy(other) {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n    return this.check();\n  }\n\n  fromLngLatZ([lng, lat, z]) {\n    this.radius = 1 + z / this.radiusScale;\n    this.phi = radians(lat);\n    this.theta = radians(lng);\n    return this.check();\n  }\n\n  fromVector3(v) {\n    this.radius = vec3.length(v);\n\n    if (this.radius > 0) {\n      this.theta = Math.atan2(v[0], v[1]);\n      this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1));\n    }\n\n    return this.check();\n  }\n\n  toVector3() {\n    return new Vector3(0, 0, this.radius).rotateX({\n      radians: this.theta\n    }).rotateZ({\n      radians: this.phi\n    });\n  }\n\n  makeSafe() {\n    this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));\n    return this;\n  }\n\n  check() {\n    if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {\n      throw new Error('SphericalCoordinates: some fields set to invalid numbers');\n    }\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../src/classes/spherical-coordinates.ts"],"names":["EPSILON","EARTH_RADIUS_METERS","constructor","phi","theta","radius","radiusScale","bearing","pitch","toString","formatString","printTypes","f","equals","other","exactEquals","degrees","Math","radians","longitude","latitude","lng","lat","z","set","clone","copy","fromLngLatZ","fromVector3","vec3","v","clamp","toVector3","makeSafe","check","Number"],"mappings":"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","sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n// MIT License\n// Adaptation of THREE.js Spherical class, under MIT license\nimport Vector3 from './vector3';\nimport {formatValue, equals, config} from '../lib/common';\nimport {degrees, radians, clamp} from '../lib/common';\nimport * as vec3 from 'gl-matrix/vec3';\nimport {NumericArray} from '@math.gl/types';\n\ntype SphericalCoordinatesOptions = {\n  phi?: number;\n  theta?: number;\n  radius?: number;\n  bearing?: number;\n  pitch?: number;\n  altitude?: number;\n  radiusScale?: number;\n};\n\ntype FormatOptions = {\n  printTypes?: boolean;\n};\n\n// TODO - import epsilon\nconst EPSILON = 0.000001;\nconst EARTH_RADIUS_METERS = 6371000;\n\n/**\n * The poles (phi) are at the positive and negative y axis.\n * The equator starts at positive z.\n * @link https://en.wikipedia.org/wiki/Spherical_coordinate_system\n */\nexport default class SphericalCoordinates {\n  phi: number;\n  theta: number;\n  radius: number;\n  radiusScale: number;\n  // bearing: number;\n  // pitch: number;\n  // altitude: number;\n\n  // lnglatZ coordinates\n  // longitude: number;\n  // latitude: number;\n  // lng: number;\n  // lat: number;\n  // z: number;\n\n  /**\n   * Creates a new SphericalCoordinates object\n   * @param options\n   * @param [options.phi] =0 - rotation around X (latitude)\n   * @param [options.theta] =0 - rotation around Y (longitude)\n   * @param [options.radius] =1 - Distance from center\n   * @param [options.bearing]\n   * @param [options.pitch]\n   * @param [options.altitude]\n   * @param [options.radiusScale] =1\n   */\n  // eslint-disable-next-line complexity\n  constructor({\n    phi = 0,\n    theta = 0,\n    radius = 1,\n    bearing,\n    pitch,\n    altitude,\n    radiusScale = EARTH_RADIUS_METERS\n  }: SphericalCoordinatesOptions = {}) {\n    this.phi = phi;\n    this.theta = theta;\n    // TODO - silently accepts illegal 0\n    this.radius = radius || altitude || 1; // radial distance from center\n    this.radiusScale = radiusScale || 1; // Used by lngLatZ\n    if (bearing !== undefined) {\n      this.bearing = bearing; // up / down towards top and bottom pole\n    }\n    if (pitch !== undefined) {\n      this.pitch = pitch; // around the equator of the sphere\n    }\n    this.check();\n  }\n\n  toString(): string {\n    return this.formatString(config);\n  }\n\n  formatString({printTypes = false}: FormatOptions): string {\n    const f = formatValue;\n    return `${printTypes ? 'Spherical' : ''}\\\n[rho:${f(this.radius)},theta:${f(this.theta)},phi:${f(this.phi)}]`;\n  }\n\n  equals(other: SphericalCoordinates): boolean {\n    return (\n      equals(this.radius, other.radius) &&\n      equals(this.theta, other.theta) &&\n      equals(this.phi, other.phi)\n    );\n  }\n\n  exactEquals(other: SphericalCoordinates): boolean {\n    return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;\n  }\n\n  /* eslint-disable brace-style */\n  // Cartographic (bearing 0 north, pitch 0 look from above)\n  get bearing(): number {\n    return 180 - degrees(this.phi);\n  }\n\n  set bearing(v: number) {\n    this.phi = Math.PI - radians(v);\n  }\n\n  get pitch(): number {\n    return degrees(this.theta);\n  }\n\n  set pitch(v: number) {\n    this.theta = radians(v);\n  }\n\n  // get pitch() { return 90 - degrees(this.phi); }\n  // set pitch(v) { this.phi = radians(v) + Math.PI / 2; }\n  // get altitude() { return this.radius - 1; } // relative altitude\n  // lnglatZ coordinates\n  get longitude(): number {\n    return degrees(this.phi);\n  }\n\n  get latitude(): number {\n    return degrees(this.theta);\n  }\n\n  get lng(): number {\n    return degrees(this.phi);\n  }\n\n  get lat(): number {\n    return degrees(this.theta);\n  }\n\n  get z(): number {\n    return (this.radius - 1) * this.radiusScale;\n  }\n\n  /* eslint-enable brace-style */\n  set(radius: number, phi: number, theta: number): this {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this.check();\n  }\n\n  clone(): SphericalCoordinates {\n    return new SphericalCoordinates().copy(this);\n  }\n\n  copy(other: SphericalCoordinates): this {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n    return this.check();\n  }\n\n  fromLngLatZ([lng, lat, z]: [number, number, number]): this {\n    this.radius = 1 + z / this.radiusScale;\n    this.phi = radians(lat);\n    this.theta = radians(lng);\n    return this.check();\n  }\n\n  fromVector3(v: Readonly<NumericArray>): this {\n    this.radius = vec3.length(v);\n    if (this.radius > 0) {\n      this.theta = Math.atan2(v[0], v[1]); // equator angle around y-up axis\n      this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1)); // polar angle\n    }\n    return this.check();\n  }\n\n  toVector3(): Vector3 {\n    return new Vector3(0, 0, this.radius)\n      .rotateX({radians: this.theta})\n      .rotateZ({radians: this.phi});\n  }\n\n  // restrict phi to be betwee EPS and PI-EPS\n  makeSafe(): this {\n    this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));\n    return this;\n  }\n\n  check(): this {\n    // this.makeSafe();\n    if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {\n      throw new Error('SphericalCoordinates: some fields set to invalid numbers');\n    }\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}