{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { buildMatrix, addPieceToBoard, isEmptyPosition, flipClockwise, flipCounterclockwise, moveDown, moveLeft, moveRight, setPiece, hardDrop } from './Matrix';\nimport Constants from '../constants';\nimport * as PieceQueue from '../modules/piece-queue';\nexport var getLevel = function (game) {\n  return Math.floor(game.lines / 10) + 1;\n};\nexport var update = function (game, action) {\n  var _a, _b;\n\n  switch (action) {\n    case 'RESTART':\n      {\n        return init();\n      }\n\n    case 'PAUSE':\n      {\n        return game.state === 'PLAYING' ? __assign(__assign({}, game), {\n          state: 'PAUSED'\n        }) : game;\n      }\n\n    case 'RESUME':\n      {\n        return game.state === 'PAUSED' ? __assign(__assign({}, game), {\n          state: 'PLAYING'\n        }) : game;\n      }\n\n    case 'TOGGLE_PAUSE':\n      {\n        if (game.state === 'PLAYING') return __assign(__assign({}, game), {\n          state: 'PAUSED'\n        });\n        if (game.state === 'PAUSED') return __assign(__assign({}, game), {\n          state: 'PLAYING'\n        });\n        return game;\n      }\n\n    case 'HARD_DROP':\n      {\n        if (game.state !== 'PLAYING') return game;\n        var piece = hardDrop(game.matrix, game.piece);\n        return lockInPiece(__assign(__assign({}, game), {\n          piece: piece\n        }));\n      }\n\n    case 'TICK':\n    case 'MOVE_DOWN':\n      {\n        if (game.state !== 'PLAYING') return game;\n        var updated = applyMove(moveDown, game);\n\n        if (game.piece === updated.piece) {\n          return lockInPiece(updated);\n        } else {\n          return updated;\n        }\n      }\n\n    case 'MOVE_LEFT':\n      {\n        return applyMove(moveLeft, game);\n      }\n\n    case 'MOVE_RIGHT':\n      {\n        return applyMove(moveRight, game);\n      }\n\n    case 'FLIP_CLOCKWISE':\n      {\n        return applyMove(flipClockwise, game);\n      }\n\n    case 'FLIP_COUNTERCLOCKWISE':\n      {\n        return applyMove(flipCounterclockwise, game);\n      }\n\n    case 'HOLD':\n      {\n        if (game.state !== 'PLAYING') return game;\n        if (game.heldPiece && !game.heldPiece.available) return game; // Ensure the held piece will fit on the matrix\n\n        if (game.heldPiece && !isEmptyPosition(game.matrix, __assign(__assign({}, game.piece), {\n          piece: game.heldPiece.piece\n        }))) {\n          return game;\n        }\n\n        var next = PieceQueue.getNext(game.queue);\n        var newPiece = (_b = (_a = game.heldPiece) === null || _a === void 0 ? void 0 : _a.piece) !== null && _b !== void 0 ? _b : next.piece;\n        return __assign(__assign({}, game), {\n          heldPiece: {\n            piece: game.piece.piece,\n            available: false\n          },\n          piece: initializePiece(newPiece),\n          queue: newPiece === next.piece ? next.queue : game.queue\n        });\n      }\n  }\n};\n\nvar lockInPiece = function (game) {\n  var _a = setPiece(game.matrix, game.piece),\n      matrix = _a[0],\n      linesCleared = _a[1];\n\n  var next = PieceQueue.getNext(game.queue);\n  var piece = initializePiece(next.piece);\n  return __assign(__assign({}, game), {\n    state: isEmptyPosition(matrix, piece) ? game.state : 'LOST',\n    matrix: matrix,\n    piece: piece,\n    heldPiece: game.heldPiece ? __assign(__assign({}, game.heldPiece), {\n      available: true\n    }) : undefined,\n    queue: next.queue,\n    lines: game.lines + linesCleared,\n    points: game.points + addScore(linesCleared)\n  });\n};\n\nvar pointsPerLine = 100;\n\nvar addScore = function (additionalLines) {\n  // what's this called?\n  if (additionalLines === 4) {\n    return pointsPerLine * 10;\n  } else {\n    return additionalLines * pointsPerLine;\n  }\n};\n\nvar initialPosition = {\n  x: Constants.GAME_WIDTH / 2 - Constants.BLOCK_WIDTH / 2,\n  y: 0\n};\n\nvar initializePiece = function (piece) {\n  return {\n    position: initialPosition,\n    piece: piece,\n    rotation: 0\n  };\n};\n\nvar applyMove = function (move, game) {\n  if (game.state !== 'PLAYING') return game;\n  var afterFlip = move(game.matrix, game.piece);\n  return afterFlip ? __assign(__assign({}, game), {\n    piece: afterFlip\n  }) : game;\n};\n\nexport var init = function () {\n  var queue = PieceQueue.create(5);\n  var next = PieceQueue.getNext(queue);\n  return {\n    state: 'PLAYING',\n    points: 0,\n    lines: 0,\n    matrix: buildMatrix(),\n    piece: initializePiece(next.piece),\n    heldPiece: undefined,\n    queue: next.queue\n  };\n}; // Good display of merging piece + matrix\n\nexport function viewMatrix(game) {\n  var gameboard = game.matrix; // set the preview\n\n  gameboard = addPieceToBoard(gameboard, hardDrop(gameboard, game.piece), true); // set the actual piece\n\n  return addPieceToBoard(gameboard, game.piece);\n}","map":{"version":3,"sources":["/Users/user/Desktop/עבודות להגשה/myweb/node_modules/react-tetris/lib/models/Game.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","buildMatrix","addPieceToBoard","isEmptyPosition","flipClockwise","flipCounterclockwise","moveDown","moveLeft","moveRight","setPiece","hardDrop","Constants","PieceQueue","getLevel","game","Math","floor","lines","update","action","_a","_b","init","state","piece","matrix","lockInPiece","updated","applyMove","heldPiece","available","next","getNext","queue","newPiece","initializePiece","linesCleared","undefined","points","addScore","pointsPerLine","additionalLines","initialPosition","x","GAME_WIDTH","BLOCK_WIDTH","y","position","rotation","move","afterFlip","create","viewMatrix","gameboard"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { buildMatrix, addPieceToBoard, isEmptyPosition, flipClockwise, flipCounterclockwise, moveDown, moveLeft, moveRight, setPiece, hardDrop } from './Matrix';\nimport Constants from '../constants';\nimport * as PieceQueue from '../modules/piece-queue';\nexport var getLevel = function (game) { return Math.floor(game.lines / 10) + 1; };\nexport var update = function (game, action) {\n    var _a, _b;\n    switch (action) {\n        case 'RESTART': {\n            return init();\n        }\n        case 'PAUSE': {\n            return game.state === 'PLAYING' ? __assign(__assign({}, game), { state: 'PAUSED' }) : game;\n        }\n        case 'RESUME': {\n            return game.state === 'PAUSED' ? __assign(__assign({}, game), { state: 'PLAYING' }) : game;\n        }\n        case 'TOGGLE_PAUSE': {\n            if (game.state === 'PLAYING')\n                return __assign(__assign({}, game), { state: 'PAUSED' });\n            if (game.state === 'PAUSED')\n                return __assign(__assign({}, game), { state: 'PLAYING' });\n            return game;\n        }\n        case 'HARD_DROP': {\n            if (game.state !== 'PLAYING')\n                return game;\n            var piece = hardDrop(game.matrix, game.piece);\n            return lockInPiece(__assign(__assign({}, game), { piece: piece }));\n        }\n        case 'TICK':\n        case 'MOVE_DOWN': {\n            if (game.state !== 'PLAYING')\n                return game;\n            var updated = applyMove(moveDown, game);\n            if (game.piece === updated.piece) {\n                return lockInPiece(updated);\n            }\n            else {\n                return updated;\n            }\n        }\n        case 'MOVE_LEFT': {\n            return applyMove(moveLeft, game);\n        }\n        case 'MOVE_RIGHT': {\n            return applyMove(moveRight, game);\n        }\n        case 'FLIP_CLOCKWISE': {\n            return applyMove(flipClockwise, game);\n        }\n        case 'FLIP_COUNTERCLOCKWISE': {\n            return applyMove(flipCounterclockwise, game);\n        }\n        case 'HOLD': {\n            if (game.state !== 'PLAYING')\n                return game;\n            if (game.heldPiece && !game.heldPiece.available)\n                return game;\n            // Ensure the held piece will fit on the matrix\n            if (game.heldPiece &&\n                !isEmptyPosition(game.matrix, __assign(__assign({}, game.piece), { piece: game.heldPiece.piece }))) {\n                return game;\n            }\n            var next = PieceQueue.getNext(game.queue);\n            var newPiece = (_b = (_a = game.heldPiece) === null || _a === void 0 ? void 0 : _a.piece) !== null && _b !== void 0 ? _b : next.piece;\n            return __assign(__assign({}, game), { heldPiece: { piece: game.piece.piece, available: false }, piece: initializePiece(newPiece), queue: newPiece === next.piece ? next.queue : game.queue });\n        }\n    }\n};\nvar lockInPiece = function (game) {\n    var _a = setPiece(game.matrix, game.piece), matrix = _a[0], linesCleared = _a[1];\n    var next = PieceQueue.getNext(game.queue);\n    var piece = initializePiece(next.piece);\n    return __assign(__assign({}, game), { state: isEmptyPosition(matrix, piece) ? game.state : 'LOST', matrix: matrix, piece: piece, heldPiece: game.heldPiece\n            ? __assign(__assign({}, game.heldPiece), { available: true }) : undefined, queue: next.queue, lines: game.lines + linesCleared, points: game.points + addScore(linesCleared) });\n};\nvar pointsPerLine = 100;\nvar addScore = function (additionalLines) {\n    // what's this called?\n    if (additionalLines === 4) {\n        return pointsPerLine * 10;\n    }\n    else {\n        return additionalLines * pointsPerLine;\n    }\n};\nvar initialPosition = {\n    x: Constants.GAME_WIDTH / 2 - Constants.BLOCK_WIDTH / 2,\n    y: 0\n};\nvar initializePiece = function (piece) {\n    return {\n        position: initialPosition,\n        piece: piece,\n        rotation: 0\n    };\n};\nvar applyMove = function (move, game) {\n    if (game.state !== 'PLAYING')\n        return game;\n    var afterFlip = move(game.matrix, game.piece);\n    return afterFlip ? __assign(__assign({}, game), { piece: afterFlip }) : game;\n};\nexport var init = function () {\n    var queue = PieceQueue.create(5);\n    var next = PieceQueue.getNext(queue);\n    return {\n        state: 'PLAYING',\n        points: 0,\n        lines: 0,\n        matrix: buildMatrix(),\n        piece: initializePiece(next.piece),\n        heldPiece: undefined,\n        queue: next.queue\n    };\n};\n// Good display of merging piece + matrix\nexport function viewMatrix(game) {\n    var gameboard = game.matrix;\n    // set the preview\n    gameboard = addPieceToBoard(gameboard, hardDrop(gameboard, game.piece), true);\n    // set the actual piece\n    return addPieceToBoard(gameboard, game.piece);\n}\n"]},"metadata":{},"sourceType":"module"}