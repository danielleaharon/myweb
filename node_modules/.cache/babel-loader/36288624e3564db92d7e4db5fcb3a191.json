{"ast":null,"code":"import { log } from '@deck.gl/core';\nconst MISSING_CHAR_WIDTH = 32;\nconst SINGLE_LINE = [];\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}) {\n  let row = 0;\n  let x = xOffset;\n\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      const width = getFontWidth(char);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * (fontHeight + buffer * 2) + buffer,\n        width,\n        height: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  const rowHeight = fontHeight + buffer * 2;\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(text, startIndex, endIndex, mapping) {\n  let width = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    var _mapping$character;\n\n    const character = text[i];\n    width += ((_mapping$character = mapping[character]) === null || _mapping$character === void 0 ? void 0 : _mapping$character.width) || 0;\n  }\n\n  return width;\n}\n\nfunction breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const textWidth = getTextWidth(text, i, i + 1, iconMapping);\n\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n\n    rowOffsetLeft += textWidth;\n  }\n\n  return rowOffsetLeft;\n}\n\nfunction breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let groupStartCharIndex = startIndex;\n  let groupEndCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n\n    if (groupEndCharIndex > groupStartCharIndex) {\n      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  return rowOffsetLeft;\n}\n\nexport function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n\n  const result = [];\n\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n\n  return result;\n}\n\nfunction transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {\n  let x = 0;\n  let rowHeight = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = line[i];\n    const frame = iconMapping[character];\n\n    if (frame) {\n      if (!rowHeight) {\n        rowHeight = frame.height;\n      }\n\n      leftOffsets[i] = x + frame.width / 2;\n      x += frame.width;\n    } else {\n      log.warn(\"Missing character: \".concat(character, \" (\").concat(character.codePointAt(0), \")\"))();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\n\nexport function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {\n  const characters = Array.from(paragraph);\n  const numCharacters = characters.length;\n  const x = new Array(numCharacters);\n  const y = new Array(numCharacters);\n  const rowWidth = new Array(numCharacters);\n  const autoWrappingEnabled = (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n  const size = [0, 0];\n  const rowSize = [0, 0];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n  let lineEndIndex = 0;\n\n  for (let i = 0; i <= numCharacters; i++) {\n    const char = characters[i];\n\n    if (char === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n\n    if (lineEndIndex > lineStartIndex) {\n      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;\n\n      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);\n\n        for (let j = rowStart; j < rowEnd; j++) {\n          y[j] = rowOffsetTop + rowSize[1] / 2;\n          rowWidth[j] = rowSize[0];\n        }\n\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = Math.max(size[0], rowSize[0]);\n      }\n\n      lineStartIndex = lineEndIndex;\n    }\n\n    if (char === '\\n') {\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n\n  size[1] = rowOffsetTop;\n  return {\n    x,\n    y,\n    rowWidth,\n    size\n  };\n}\nexport function getTextFromBuffer({\n  value,\n  length,\n  stride,\n  offset,\n  startIndices,\n  characterSet\n}) {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);\n  const autoCharacterSet = characterSet && new Set();\n  const texts = new Array(length);\n  let codes = value;\n\n  if (elementStride > 1 || elementOffset > 0) {\n    const ArrayType = value.constructor;\n    codes = new ArrayType(characterCount);\n\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    const codesAtIndex = codes.subarray(startIndex, endIndex);\n    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);\n\n    if (autoCharacterSet) {\n      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);\n    }\n  }\n\n  if (autoCharacterSet) {\n    for (const charCode of autoCharacterSet) {\n      characterSet.add(String.fromCodePoint(charCode));\n    }\n  }\n\n  return {\n    texts,\n    characterCount\n  };\n}","map":{"version":3,"sources":["../../../src/text-layer/utils.ts"],"names":["MISSING_CHAR_WIDTH","SINGLE_LINE","Math","mapping","xOffset","yOffset","row","x","width","getFontWidth","buffer","y","fontHeight","height","rowHeight","canvasHeight","nextPowOfTwo","i","character","text","rowStartCharIndex","rowOffsetLeft","textWidth","getTextWidth","target","groupStartCharIndex","groupEndCharIndex","groupWidth","breakAll","startIndex","endIndex","result","wordBreak","breakWord","line","frame","iconMapping","leftOffsets","log","rowSize","characters","Array","numCharacters","rowWidth","autoWrappingEnabled","isFinite","maxWidth","size","rowOffsetTop","lineStartIndex","lineEndIndex","char","rows","autoWrapping","rowIndex","rowStart","rowEnd","transformRow","j","characterSet","bytesPerElement","value","elementStride","stride","elementOffset","offset","characterCount","startIndices","autoCharacterSet","texts","codes","ArrayType","index","codesAtIndex","String"],"mappings":"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","sourcesContent":["/* eslint-disable max-statements, max-params, complexity, max-depth */\n// TODO merge with icon-layer/icon-manager\nimport {log} from '@deck.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nconst MISSING_CHAR_WIDTH = 32;\nconst SINGLE_LINE = [];\n\nexport type Character = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\nexport type CharacterMapping = Record<string, Character>;\n\nexport function nextPowOfTwo(number: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n/**\n * Generate character mapping table or update from an existing mapping table\n */\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}: {\n  /** list of characters */\n  characterSet: Set<string>;\n  /** function to get width of each character */\n  getFontWidth: (char: string) => number;\n  /** height of font */\n  fontHeight: number;\n  /** bleeding buffer surround each character */\n  buffer: number;\n  /** max width of font atlas */\n  maxCanvasWidth: number;\n  /** cached mapping table */\n  mapping?: CharacterMapping;\n  /** x position of last character in the existing mapping table */\n  xOffset?: number;\n  /** y position of last character in the existing mapping table */\n  yOffset?: number;\n}): {\n  /** new mapping table */\n  mapping: CharacterMapping;\n  /** x position of last character in the new mapping table */\n  xOffset: number;\n  /** y position of last character in the new mapping table */\n  yOffset: number;\n  /** height of the font atlas canvas, power of 2 */\n  canvasHeight: number;\n} {\n  let row = 0;\n  // continue from x position of last character in the old mapping\n  let x = xOffset;\n\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      // measure texts\n      // TODO - use Advanced text metrics when they are adopted:\n      // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics\n      const width = getFontWidth(char);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * (fontHeight + buffer * 2) + buffer,\n        width,\n        height: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  const rowHeight = fontHeight + buffer * 2;\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(\n  text: string[],\n  startIndex: number,\n  endIndex: number,\n  mapping: CharacterMapping\n): number {\n  let width = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = text[i];\n    width += mapping[character]?.width || 0;\n  }\n\n  return width;\n}\n\nfunction breakAll(\n  text: string[],\n  startIndex: number,\n  endIndex: number,\n  maxWidth: number,\n  iconMapping: CharacterMapping,\n  target: number[]\n): number {\n  let rowStartCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    // 2. figure out where to break lines\n    const textWidth = getTextWidth(text, i, i + 1, iconMapping);\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n    rowOffsetLeft += textWidth;\n  }\n\n  return rowOffsetLeft;\n}\n\nfunction breakWord(\n  text: string[],\n  startIndex: number,\n  endIndex: number,\n  maxWidth: number,\n  iconMapping: CharacterMapping,\n  target: number[]\n): number {\n  let rowStartCharIndex = startIndex;\n  let groupStartCharIndex = startIndex;\n  let groupEndCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    // 1. break text into word groups\n    //  - if current char is white space\n    //  - else if next char is white space\n    //  - else if reach last char\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n\n    if (groupEndCharIndex > groupStartCharIndex) {\n      // 2. break text into next row at maxWidth\n      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n\n        // if a single text group is bigger than maxWidth, then `break-all`\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(\n            text,\n            groupStartCharIndex,\n            groupEndCharIndex,\n            maxWidth,\n            iconMapping,\n            target\n          );\n          // move reference to last row\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  return rowOffsetLeft;\n}\n\n/**\n * Wrap the given text so that each line does not exceed the given max width.\n * Returns a list of indices where line breaks should be inserted.\n */\nexport function autoWrapping(\n  text: string[],\n  wordBreak: 'break-all' | 'break-word',\n  maxWidth: number,\n  iconMapping: CharacterMapping,\n  startIndex: number = 0,\n  endIndex: number\n): number[] {\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n  const result = [];\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n  return result;\n}\n\nfunction transformRow(\n  line: string[],\n  startIndex: number,\n  endIndex: number,\n  iconMapping: CharacterMapping,\n  leftOffsets: number[],\n  rowSize: [number, number]\n) {\n  let x = 0;\n  let rowHeight = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = line[i];\n    const frame = iconMapping[character];\n    if (frame) {\n      if (!rowHeight) {\n        // frame.height should be a constant\n        rowHeight = frame.height;\n      }\n      leftOffsets[i] = x + frame.width / 2;\n      x += frame.width;\n    } else {\n      log.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\n\n/**\n * Transform a text paragraph to an array of characters, each character contains\n */\nexport function transformParagraph(\n  paragraph: string,\n  /** CSS line-height */\n  lineHeight: number,\n  /** CSS word-break option */\n  wordBreak: 'break-word' | 'break-all',\n  /** CSS max-width */\n  maxWidth: number,\n  /** character mapping table for retrieving a character from font atlas */\n  iconMapping: CharacterMapping\n): {\n  /** x position of each character */\n  x: number[];\n  /** y position of each character */\n  y: number[];\n  /** the current row width of each character */\n  rowWidth: number[];\n  /** the width and height of the paragraph */\n  size: [number, number];\n} {\n  // Break into an array of characters\n  // When dealing with double-length unicode characters, `str.length` or `str[i]` do not work\n  const characters = Array.from(paragraph);\n  const numCharacters = characters.length;\n  const x = new Array(numCharacters) as number[];\n  const y = new Array(numCharacters) as number[];\n  const rowWidth = new Array(numCharacters) as number[];\n  const autoWrappingEnabled =\n    (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n\n  // maxWidth and height of the paragraph\n  const size: [number, number] = [0, 0];\n  const rowSize: [number, number] = [0, 0];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n  let lineEndIndex = 0;\n\n  for (let i = 0; i <= numCharacters; i++) {\n    const char = characters[i];\n    if (char === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n\n    if (lineEndIndex > lineStartIndex) {\n      const rows = autoWrappingEnabled\n        ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex)\n        : SINGLE_LINE;\n\n      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);\n        for (let j = rowStart; j < rowEnd; j++) {\n          y[j] = rowOffsetTop + rowSize[1] / 2;\n          rowWidth[j] = rowSize[0];\n        }\n\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = Math.max(size[0], rowSize[0]);\n      }\n      lineStartIndex = lineEndIndex;\n    }\n\n    if (char === '\\n') {\n      // Make sure result.length matches paragraph.length\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n\n  // last row\n  size[1] = rowOffsetTop;\n  return {x, y, rowWidth, size};\n}\n\nexport function getTextFromBuffer({\n  value,\n  length,\n  stride,\n  offset,\n  startIndices,\n  characterSet\n}: {\n  value: Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array;\n  length: number;\n  stride?: number;\n  offset?: number;\n  startIndices: NumericArray;\n  characterSet?: Set<string>;\n}): {\n  texts: string[];\n  characterCount: number;\n} {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount =\n    startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);\n  const autoCharacterSet = characterSet && new Set<number>();\n\n  const texts = new Array(length);\n\n  let codes = value;\n  if (elementStride > 1 || elementOffset > 0) {\n    const ArrayType = value.constructor as\n      | Uint8ArrayConstructor\n      | Uint8ClampedArrayConstructor\n      | Uint16ArrayConstructor\n      | Uint32ArrayConstructor;\n    codes = new ArrayType(characterCount);\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    const codesAtIndex = codes.subarray(startIndex, endIndex);\n    // @ts-ignore TS wants the argument to be number[] but typed array works too\n    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);\n    if (autoCharacterSet) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);\n    }\n  }\n\n  if (autoCharacterSet) {\n    for (const charCode of autoCharacterSet) {\n      characterSet.add(String.fromCodePoint(charCode));\n    }\n  }\n\n  return {texts, characterCount};\n}\n"]},"metadata":{},"sourceType":"module"}