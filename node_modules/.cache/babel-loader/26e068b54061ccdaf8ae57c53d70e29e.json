{"ast":null,"code":"import { createElement, useRef, useState, useMemo, useEffect, useImperativeHandle, forwardRef } from 'react';\nimport { Deck } from '@deck.gl/core';\nimport useIsomorphicLayoutEffect from './utils/use-isomorphic-layout-effect';\nimport extractJSXLayers from './utils/extract-jsx-layers';\nimport positionChildrenUnderViews from './utils/position-children-under-views';\nimport extractStyles from './utils/extract-styles';\n\nfunction getRefHandles(thisRef) {\n  return {\n    get deck() {\n      return thisRef.deck;\n    },\n\n    pickObject: opts => thisRef.deck.pickObject(opts),\n    pickMultipleObjects: opts => thisRef.deck.pickMultipleObjects(opts),\n    pickObjects: opts => thisRef.deck.pickObjects(opts)\n  };\n}\n\nfunction redrawDeck(thisRef) {\n  if (thisRef.redrawReason) {\n    thisRef.deck._drawLayers(thisRef.redrawReason);\n\n    thisRef.redrawReason = null;\n  }\n}\n\nfunction createDeckInstance(thisRef, DeckClass, props) {\n  const deck = new DeckClass({ ...props,\n    _customRender: redrawReason => {\n      thisRef.redrawReason = redrawReason;\n      const viewports = deck.getViewports();\n\n      if (thisRef.lastRenderedViewports !== viewports) {\n        thisRef.forceUpdate();\n      } else {\n        redrawDeck(thisRef);\n      }\n    }\n  });\n  return deck;\n}\n\nconst DeckGL = forwardRef((props, ref) => {\n  const [version, setVersion] = useState(0);\n\n  const _thisRef = useRef({\n    control: null,\n    version,\n    forceUpdate: () => setVersion(v => v + 1)\n  });\n\n  const thisRef = _thisRef.current;\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const jsxProps = useMemo(() => extractJSXLayers(props), [props.layers, props.views, props.children]);\n  let inRender = true;\n\n  const handleViewStateChange = params => {\n    var _props$onViewStateCha;\n\n    if (inRender && props.viewState) {\n      thisRef.viewStateUpdateRequested = params;\n      return null;\n    }\n\n    thisRef.viewStateUpdateRequested = null;\n    return (_props$onViewStateCha = props.onViewStateChange) === null || _props$onViewStateCha === void 0 ? void 0 : _props$onViewStateCha.call(props, params);\n  };\n\n  const handleInteractionStateChange = params => {\n    if (inRender) {\n      thisRef.interactionStateUpdateRequested = params;\n    } else {\n      var _props$onInteractionS;\n\n      thisRef.interactionStateUpdateRequested = null;\n      (_props$onInteractionS = props.onInteractionStateChange) === null || _props$onInteractionS === void 0 ? void 0 : _props$onInteractionS.call(props, params);\n    }\n  };\n\n  const deckProps = useMemo(() => {\n    const forwardProps = { ...props,\n      style: null,\n      width: '100%',\n      height: '100%',\n      parent: containerRef.current,\n      canvas: canvasRef.current,\n      layers: jsxProps.layers,\n      views: jsxProps.views,\n      onViewStateChange: handleViewStateChange,\n      onInteractionStateChange: handleInteractionStateChange\n    };\n    delete forwardProps._customRender;\n\n    if (thisRef.deck) {\n      thisRef.deck.setProps(forwardProps);\n    }\n\n    return forwardProps;\n  }, [props]);\n  useEffect(() => {\n    const DeckClass = props.Deck || Deck;\n    thisRef.deck = createDeckInstance(thisRef, DeckClass, { ...deckProps,\n      parent: containerRef.current,\n      canvas: canvasRef.current\n    });\n    return () => {\n      var _thisRef$deck;\n\n      return (_thisRef$deck = thisRef.deck) === null || _thisRef$deck === void 0 ? void 0 : _thisRef$deck.finalize();\n    };\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    redrawDeck(thisRef);\n    const {\n      viewStateUpdateRequested,\n      interactionStateUpdateRequested\n    } = thisRef;\n\n    if (viewStateUpdateRequested) {\n      handleViewStateChange(viewStateUpdateRequested);\n    }\n\n    if (interactionStateUpdateRequested) {\n      handleInteractionStateChange(interactionStateUpdateRequested);\n    }\n  });\n  useImperativeHandle(ref, () => getRefHandles(thisRef), []);\n  const currentViewports = thisRef.deck && thisRef.deck.isInitialized ? thisRef.deck.getViewports() : undefined;\n  const {\n    ContextProvider,\n    width,\n    height,\n    id,\n    style\n  } = props;\n  const {\n    containerStyle,\n    canvasStyle\n  } = useMemo(() => extractStyles({\n    width,\n    height,\n    style\n  }), [width, height, style]);\n\n  if (!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports || thisRef.version !== version) {\n    thisRef.lastRenderedViewports = currentViewports;\n    thisRef.version = version;\n    const childrenUnderViews = positionChildrenUnderViews({\n      children: jsxProps.children,\n      deck: thisRef.deck,\n      ContextProvider\n    });\n    const canvas = createElement('canvas', {\n      key: 'canvas',\n      id: id || 'deckgl-overlay',\n      ref: canvasRef,\n      style: canvasStyle\n    });\n    thisRef.control = createElement('div', {\n      id: \"\".concat(id || 'deckgl', \"-wrapper\"),\n      ref: containerRef,\n      style: containerStyle\n    }, [canvas, childrenUnderViews]);\n  }\n\n  inRender = false;\n  return thisRef.control;\n});\nDeckGL.defaultProps = Deck.defaultProps;\nexport default DeckGL;","map":{"version":3,"sources":["../../src/deckgl.ts"],"names":["thisRef","pickObject","opts","pickMultipleObjects","pickObjects","deck","_customRender","redrawReason","viewports","redrawDeck","DeckGL","forwardRef","useState","_thisRef","useRef","control","forceUpdate","setVersion","v","containerRef","canvasRef","jsxProps","useMemo","extractJSXLayers","props","inRender","handleViewStateChange","params","handleInteractionStateChange","deckProps","forwardProps","style","width","height","parent","canvas","layers","views","onViewStateChange","onInteractionStateChange","useEffect","DeckClass","createDeckInstance","current","useIsomorphicLayoutEffect","interactionStateUpdateRequested","useImperativeHandle","getRefHandles","currentViewports","canvasStyle","extractStyles","childrenUnderViews","positionChildrenUnderViews","children","ContextProvider","createElement","key","id","ref","containerStyle","Deck"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport * as React from 'react';\nimport {\n  createElement,\n  useRef,\n  useState,\n  useMemo,\n  useEffect,\n  useImperativeHandle,\n  forwardRef\n} from 'react';\nimport {Deck} from '@deck.gl/core';\nimport useIsomorphicLayoutEffect from './utils/use-isomorphic-layout-effect';\n\nimport extractJSXLayers from './utils/extract-jsx-layers';\nimport positionChildrenUnderViews from './utils/position-children-under-views';\nimport extractStyles from './utils/extract-styles';\n\nimport type {DeckGLContextValue} from './utils/position-children-under-views';\nimport type {DeckProps, Viewport} from '@deck.gl/core';\n\n/* eslint-disable max-statements, accessor-pairs */\ntype DeckInstanceRef = {\n  deck?: Deck;\n  redrawReason?: string | null;\n  lastRenderedViewports?: Viewport[];\n  viewStateUpdateRequested?: any;\n  interactionStateUpdateRequested?: any;\n  forceUpdate: () => void;\n  version: number;\n  control: React.ReactHTMLElement<HTMLElement> | null;\n};\n\n// Remove prop types in the base Deck class that support externally supplied canvas/WebGLContext\n/** DeckGL React component props */\nexport type DeckGLProps = Omit<\n  DeckProps,\n  'width' | 'height' | 'gl' | 'parent' | 'canvas' | '_customRender'\n> & {\n  Deck?: typeof Deck;\n  width?: string | number;\n  height?: string | number;\n  children?: React.ReactNode;\n  ContextProvider?: React.Context<DeckGLContextValue>['Provider'];\n};\n\nexport type DeckGLRef = {\n  deck?: Deck;\n  pickObject: Deck['pickObject'];\n  pickObjects: Deck['pickObjects'];\n  pickMultipleObjects: Deck['pickMultipleObjects'];\n};\n\nfunction getRefHandles(thisRef: DeckInstanceRef): DeckGLRef {\n  return {\n    get deck() {\n      return thisRef.deck;\n    },\n    // The following method can only be called after ref is available, by which point deck is defined in useEffect\n    pickObject: opts => thisRef.deck!.pickObject(opts),\n    pickMultipleObjects: opts => thisRef.deck!.pickMultipleObjects(opts),\n    pickObjects: opts => thisRef.deck!.pickObjects(opts)\n  };\n}\n\nfunction redrawDeck(thisRef: DeckInstanceRef) {\n  if (thisRef.redrawReason) {\n    // Only redraw if we have received a dirty flag\n    // @ts-expect-error accessing protected method\n    thisRef.deck._drawLayers(thisRef.redrawReason);\n    thisRef.redrawReason = null;\n  }\n}\n\nfunction createDeckInstance(\n  thisRef: DeckInstanceRef,\n  DeckClass: typeof Deck,\n  props: DeckProps\n): Deck {\n  const deck = new DeckClass({\n    ...props,\n    // The Deck's animation loop is independent from React's render cycle, causing potential\n    // synchronization issues. We provide this custom render function to make sure that React\n    // and Deck update on the same schedule.\n    _customRender: redrawReason => {\n      // Save the dirty flag for later\n      thisRef.redrawReason = redrawReason;\n\n      // Viewport/view state is passed to child components as props.\n      // If they have changed, we need to trigger a React rerender to update children props.\n      const viewports = deck.getViewports();\n      if (thisRef.lastRenderedViewports !== viewports) {\n        // Viewports have changed, update children props first.\n        // This will delay the Deck canvas redraw till after React update (in useLayoutEffect)\n        // so that the canvas does not get rendered before the child components update.\n        thisRef.forceUpdate();\n      } else {\n        redrawDeck(thisRef);\n      }\n    }\n  });\n  return deck;\n}\n\nconst DeckGL = forwardRef<DeckGLRef, DeckGLProps>((props, ref) => {\n  // A mechanism to force redraw\n  const [version, setVersion] = useState(0);\n  // A reference to persistent states\n  const _thisRef = useRef<DeckInstanceRef>({\n    control: null,\n    version,\n    forceUpdate: () => setVersion(v => v + 1)\n  });\n  const thisRef = _thisRef.current;\n  // DOM refs\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n\n  // extract any deck.gl layers masquerading as react elements from props.children\n  const jsxProps = useMemo(\n    () => extractJSXLayers(props),\n    [props.layers, props.views, props.children]\n  );\n\n  // Callbacks\n  let inRender = true;\n\n  const handleViewStateChange: DeckProps['onViewStateChange'] = params => {\n    if (inRender && props.viewState) {\n      // Callback may invoke a state update. Defer callback to after render() to avoid React error\n      // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once\n      // Store deferred parameters in ref so that we can access it in another render\n      thisRef.viewStateUpdateRequested = params;\n      return null;\n    }\n    thisRef.viewStateUpdateRequested = null;\n    return props.onViewStateChange?.(params);\n  };\n\n  const handleInteractionStateChange: DeckProps['onInteractionStateChange'] = params => {\n    if (inRender) {\n      // Callback may invoke a state update. Defer callback to after render() to avoid React error\n      // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once\n      // Store deferred parameters in ref so that we can access it in another render\n      thisRef.interactionStateUpdateRequested = params;\n    } else {\n      thisRef.interactionStateUpdateRequested = null;\n      props.onInteractionStateChange?.(params);\n    }\n  };\n\n  // Update Deck's props. If Deck needs redraw, this will trigger a call to `_customRender` in\n  // the next animation frame.\n  // Needs to be called both from initial mount, and when new props are received\n  const deckProps = useMemo(() => {\n    const forwardProps: DeckProps = {\n      ...props,\n      // Override user styling props. We will set the canvas style in render()\n      style: null,\n      width: '100%',\n      height: '100%',\n      parent: containerRef.current,\n      canvas: canvasRef.current,\n      layers: jsxProps.layers,\n      views: jsxProps.views,\n      onViewStateChange: handleViewStateChange,\n      onInteractionStateChange: handleInteractionStateChange\n    };\n\n    // The defaultValue for _customRender is null, which would overwrite the definition\n    // of _customRender. Remove to avoid frequently redeclaring the method here.\n    delete forwardProps._customRender;\n\n    if (thisRef.deck) {\n      thisRef.deck.setProps(forwardProps);\n    }\n\n    return forwardProps;\n  }, [props]);\n\n  useEffect(() => {\n    const DeckClass = props.Deck || Deck;\n\n    thisRef.deck = createDeckInstance(thisRef, DeckClass, {\n      ...deckProps,\n      parent: containerRef.current,\n      canvas: canvasRef.current\n    });\n\n    return () => thisRef.deck?.finalize();\n  }, []);\n\n  useIsomorphicLayoutEffect(() => {\n    // render has just been called. The children are positioned based on the current view state.\n    // Redraw Deck canvas immediately, if necessary, using the current view state, so that it\n    // matches the child components.\n    redrawDeck(thisRef);\n\n    // Execute deferred callbacks\n    const {viewStateUpdateRequested, interactionStateUpdateRequested} = thisRef;\n    if (viewStateUpdateRequested) {\n      handleViewStateChange(viewStateUpdateRequested);\n    }\n    if (interactionStateUpdateRequested) {\n      handleInteractionStateChange(interactionStateUpdateRequested);\n    }\n  });\n\n  useImperativeHandle(ref, () => getRefHandles(thisRef), []);\n\n  const currentViewports =\n    thisRef.deck && thisRef.deck.isInitialized ? thisRef.deck.getViewports() : undefined;\n\n  const {ContextProvider, width, height, id, style} = props;\n\n  const {containerStyle, canvasStyle} = useMemo(\n    () => extractStyles({width, height, style}),\n    [width, height, style]\n  );\n\n  // Props changes may lead to 3 types of updates:\n  // 1. Only the WebGL canvas - updated in Deck's render cycle (next animation frame)\n  // 2. Only the DOM - updated in React's lifecycle (now)\n  // 3. Both the WebGL canvas and the DOM - defer React rerender to next animation frame just\n  //    before Deck redraw to ensure perfect synchronization & avoid excessive redraw\n  //    This is because multiple changes may happen to Deck between two frames e.g. transition\n  if (\n    (!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports) || // case 2\n    thisRef.version !== version // case 3 just before deck redraws\n  ) {\n    thisRef.lastRenderedViewports = currentViewports;\n    thisRef.version = version;\n\n    // Render the background elements (typically react-map-gl instances)\n    // using the view descriptors\n    const childrenUnderViews = positionChildrenUnderViews({\n      children: jsxProps.children,\n      deck: thisRef.deck,\n      ContextProvider\n    });\n\n    const canvas = createElement('canvas', {\n      key: 'canvas',\n      id: id || 'deckgl-overlay',\n      ref: canvasRef,\n      style: canvasStyle\n    });\n\n    // Render deck.gl as the last child\n    thisRef.control = createElement(\n      'div',\n      {id: `${id || 'deckgl'}-wrapper`, ref: containerRef, style: containerStyle},\n      [canvas, childrenUnderViews]\n    );\n  }\n\n  inRender = false;\n  return thisRef.control;\n});\n\nDeckGL.defaultProps = Deck.defaultProps;\n\nexport default DeckGL;\n"]},"metadata":{},"sourceType":"module"}