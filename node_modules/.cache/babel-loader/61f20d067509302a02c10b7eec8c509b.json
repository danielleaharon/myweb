{"ast":null,"code":"import _slicedToArray from\"/Users/user/Desktop/\\u05E2\\u05D1\\u05D5\\u05D3\\u05D5\\u05EA \\u05DC\\u05D4\\u05D2\\u05E9\\u05D4/myweb/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState,useEffect}from'react';import{createStage}from'../gameHelpers';export var useStage=function useStage(player,resetPlayer){var _useState=useState(createStage()),_useState2=_slicedToArray(_useState,2),stage=_useState2[0],setStage=_useState2[1];var _useState3=useState(0),_useState4=_slicedToArray(_useState3,2),rowsCleared=_useState4[0],setRowsCleared=_useState4[1];useEffect(function(){setRowsCleared(0);var sweepRows=function sweepRows(newStage){return newStage.reduce(function(ack,row){if(row.findIndex(function(cell){return cell[0]===0;})===-1){setRowsCleared(function(prev){return prev+1;});ack.unshift(new Array(newStage[0].length).fill([0,'clear']));return ack;}ack.push(row);return ack;},[]);};var updateStage=function updateStage(prevStage){// First flush the stage\nvar newStage=prevStage.map(function(row){return row.map(function(cell){return cell[1]==='clear'?[0,'clear']:cell;});});// Then draw the tetromino\nplayer.tetromino.forEach(function(row,y){row.forEach(function(value,x){if(value!==0){newStage[y+player.pos.y][x+player.pos.x]=[value,\"\".concat(player.collided?'merged':'clear'),player.texts[y][x]];}});});// Then check if we got some score if collided\nif(player.collided){resetPlayer();return sweepRows(newStage);}return newStage;};// Here are the updates\nsetStage(function(prev){return updateStage(prev);});},[player.collided,player.pos.x,player.pos.y,player.tetromino,player.texts,resetPlayer]);return[stage,setStage,rowsCleared];};","map":{"version":3,"sources":["/Users/user/Desktop/עבודות להגשה/myweb/src/components/tetris/hooks/useStage.js"],"names":["useState","useEffect","createStage","useStage","player","resetPlayer","stage","setStage","rowsCleared","setRowsCleared","sweepRows","newStage","reduce","ack","row","findIndex","cell","prev","unshift","Array","length","fill","push","updateStage","prevStage","map","tetromino","forEach","y","value","x","pos","collided","texts"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react';\nimport { createStage } from '../gameHelpers';\n\nexport const useStage = (player, resetPlayer) => {\n  const [stage, setStage] = useState(createStage());\n  const [rowsCleared, setRowsCleared] = useState(0);\n\n  useEffect(() => {\n    setRowsCleared(0);\n    const sweepRows = newStage =>\n      newStage.reduce((ack, row) => {\n        if (row.findIndex(cell => cell[0] === 0) === -1) {\n          setRowsCleared(prev => prev + 1);\n          ack.unshift(new Array(newStage[0].length).fill([0, 'clear']));\n          return ack;\n        }\n        ack.push(row);\n        return ack;\n      }, []);\n\n    const updateStage = prevStage => {\n      // First flush the stage\n      const newStage = prevStage.map(row =>\n        row.map(cell => (cell[1] === 'clear' ? [0, 'clear'] : cell))\n      );\n\n      // Then draw the tetromino\n      player.tetromino.forEach((row, y) => {\n        row.forEach((value, x) => {\n          if (value !== 0) {\n            newStage[y + player.pos.y][x + player.pos.x] = [\n              value,\n              `${player.collided ? 'merged' : 'clear'}`,\n              player.texts[y][x]\n            ];\n          }\n        });\n      });\n      // Then check if we got some score if collided\n      if (player.collided) {\n        resetPlayer();\n        return sweepRows(newStage);\n      }\n      return newStage;\n    };\n\n    // Here are the updates\n    setStage(prev => updateStage(prev));\n  }, [\n    player.collided,\n    player.pos.x,\n    player.pos.y,\n    player.tetromino,\n    player.texts,\n\n    resetPlayer,\n  ]);\n\n  return [stage, setStage, rowsCleared];\n};"]},"metadata":{},"sourceType":"module"}