{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport MultiIconLayer from './multi-icon-layer/multi-icon-layer';\nimport FontAtlasManager, { DEFAULT_FONT_SETTINGS, setFontAtlasCacheLimit } from './font-atlas-manager';\nimport { transformParagraph, getTextFromBuffer } from './utils';\nimport TextBackgroundLayer from './text-background-layer/text-background-layer';\nconst TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n};\nconst ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n};\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst DEFAULT_LINE_HEIGHT = 1.0;\nconst defaultProps = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n  background: false,\n  getBackgroundColor: {\n    type: 'accessor',\n    value: [255, 255, 255, 255]\n  },\n  getBorderColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getBorderWidth: {\n    type: 'accessor',\n    value: 0\n  },\n  backgroundPadding: {\n    type: 'array',\n    value: [0, 0, 0, 0]\n  },\n  characterSet: {\n    type: 'object',\n    value: DEFAULT_FONT_SETTINGS.characterSet\n  },\n  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,\n  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  outlineWidth: {\n    type: 'number',\n    value: 0,\n    min: 0\n  },\n  outlineColor: {\n    type: 'color',\n    value: DEFAULT_COLOR\n  },\n  fontSettings: {},\n  wordBreak: 'break-word',\n  maxWidth: {\n    type: 'number',\n    value: -1\n  },\n  getText: {\n    type: 'accessor',\n    value: x => x.text\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 32\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getTextAnchor: {\n    type: 'accessor',\n    value: 'middle'\n  },\n  getAlignmentBaseline: {\n    type: 'accessor',\n    value: 'center'\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  backgroundColor: {\n    deprecatedFor: ['background', 'getBackgroundColor']\n  }\n};\nexport default class TextLayer extends CompositeLayer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n\n    _defineProperty(this, \"getBoundingRect\", (object, objectInfo) => {\n      const iconMapping = this.state.fontAtlasManager.mapping;\n      const getText = this.state.getText;\n      const {\n        wordBreak,\n        maxWidth,\n        lineHeight,\n        getTextAnchor,\n        getAlignmentBaseline\n      } = this.props;\n      const paragraph = getText(object, objectInfo) || '';\n      const {\n        size: [width, height]\n      } = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);\n      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];\n      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];\n      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];\n    });\n\n    _defineProperty(this, \"getIconOffsets\", (object, objectInfo) => {\n      const iconMapping = this.state.fontAtlasManager.mapping;\n      const getText = this.state.getText;\n      const {\n        wordBreak,\n        maxWidth,\n        lineHeight,\n        getTextAnchor,\n        getAlignmentBaseline\n      } = this.props;\n      const paragraph = getText(object, objectInfo) || '';\n      const {\n        x,\n        y,\n        rowWidth,\n        size: [width, height]\n      } = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);\n      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];\n      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];\n      const numCharacters = x.length;\n      const offsets = new Array(numCharacters * 2);\n      let index = 0;\n\n      for (let i = 0; i < numCharacters; i++) {\n        const rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;\n        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x[i];\n        offsets[index++] = (anchorY - 1) * height / 2 + y[i];\n      }\n\n      return offsets;\n    });\n  }\n\n  initializeState() {\n    this.state = {\n      styleVersion: 0,\n      fontAtlasManager: new FontAtlasManager()\n    };\n  }\n\n  updateState(params) {\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);\n\n    if (textChanged) {\n      this._updateText();\n    }\n\n    const fontChanged = this._updateFontAtlas();\n\n    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;\n\n    if (styleChanged) {\n      this.setState({\n        styleVersion: this.state.styleVersion + 1\n      });\n    }\n  }\n\n  getPickingInfo({\n    info\n  }) {\n    info.object = info.index >= 0 ? this.props.data[info.index] : null;\n    return info;\n  }\n\n  _updateFontAtlas() {\n    const {\n      fontSettings,\n      fontFamily,\n      fontWeight\n    } = this.props;\n    const {\n      fontAtlasManager,\n      characterSet\n    } = this.state;\n    const fontProps = { ...fontSettings,\n      characterSet,\n      fontFamily,\n      fontWeight\n    };\n\n    if (!fontAtlasManager.mapping) {\n      fontAtlasManager.setProps(fontProps);\n      return true;\n    }\n\n    for (const key in fontProps) {\n      if (fontProps[key] !== fontAtlasManager.props[key]) {\n        fontAtlasManager.setProps(fontProps);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _updateText() {\n    var _attributes;\n\n    const {\n      data,\n      characterSet\n    } = this.props;\n    const textBuffer = (_attributes = data.attributes) === null || _attributes === void 0 ? void 0 : _attributes.getText;\n    let {\n      getText\n    } = this.props;\n    let startIndices = data.startIndices;\n    let numInstances;\n    const autoCharacterSet = characterSet === 'auto' && new Set();\n\n    if (textBuffer && startIndices) {\n      const {\n        texts,\n        characterCount\n      } = getTextFromBuffer({ ...(ArrayBuffer.isView(textBuffer) ? {\n          value: textBuffer\n        } : textBuffer),\n        length: data.length,\n        startIndices,\n        characterSet: autoCharacterSet\n      });\n      numInstances = characterCount;\n\n      getText = (_, {\n        index\n      }) => texts[index];\n    } else {\n      const {\n        iterable,\n        objectInfo\n      } = createIterable(data);\n      startIndices = [0];\n      numInstances = 0;\n\n      for (const object of iterable) {\n        objectInfo.index++;\n        const text = Array.from(getText(object, objectInfo) || '');\n\n        if (autoCharacterSet) {\n          text.forEach(autoCharacterSet.add, autoCharacterSet);\n        }\n\n        numInstances += text.length;\n        startIndices.push(numInstances);\n      }\n    }\n\n    this.setState({\n      getText,\n      startIndices,\n      numInstances,\n      characterSet: autoCharacterSet || characterSet\n    });\n  }\n\n  renderLayers() {\n    const {\n      startIndices,\n      numInstances,\n      getText,\n      fontAtlasManager: {\n        scale,\n        texture,\n        mapping\n      },\n      styleVersion\n    } = this.state;\n    const {\n      data,\n      _dataDiff,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      getBackgroundColor,\n      getBorderColor,\n      getBorderWidth,\n      backgroundPadding,\n      background,\n      billboard,\n      fontSettings,\n      outlineWidth,\n      outlineColor,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions,\n      updateTriggers\n    } = this.props;\n    const CharactersLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n    const BackgroundLayerClass = this.getSubLayerClass('background', TextBackgroundLayer);\n    return [background && new BackgroundLayerClass({\n      getFillColor: getBackgroundColor,\n      getLineColor: getBorderColor,\n      getLineWidth: getBorderWidth,\n      padding: backgroundPadding,\n      getPosition,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      billboard,\n      sizeScale: sizeScale / this.state.fontAtlasManager.props.fontSize,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions: transitions && {\n        getPosition: transitions.getPosition,\n        getAngle: transitions.getAngle,\n        getSize: transitions.getSize,\n        getFillColor: transitions.getBackgroundColor,\n        getLineColor: transitions.getBorderColor,\n        getLineWidth: transitions.getBorderWidth,\n        getPixelOffset: transitions.getPixelOffset\n      }\n    }, this.getSubLayerProps({\n      id: 'background',\n      updateTriggers: {\n        getPosition: updateTriggers.getPosition,\n        getAngle: updateTriggers.getAngle,\n        getSize: updateTriggers.getSize,\n        getFillColor: updateTriggers.getBackgroundColor,\n        getLineColor: updateTriggers.getBorderColor,\n        getLineWidth: updateTriggers.getBorderWidth,\n        getPixelOffset: updateTriggers.getPixelOffset,\n        getBoundingRect: {\n          getText: updateTriggers.getText,\n          getTextAnchor: updateTriggers.getTextAnchor,\n          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n          styleVersion\n        }\n      }\n    }), {\n      data: data.attributes && data.attributes.background ? {\n        length: data.length,\n        attributes: data.attributes.background\n      } : data,\n      _dataDiff,\n      autoHighlight: false,\n      getBoundingRect: this.getBoundingRect\n    }), new CharactersLayerClass({\n      sdf: fontSettings.sdf,\n      smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,\n      outlineWidth,\n      outlineColor,\n      iconAtlas: texture,\n      iconMapping: mapping,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      billboard,\n      sizeScale: sizeScale * scale,\n      sizeUnits,\n      sizeMinPixels: sizeMinPixels * scale,\n      sizeMaxPixels: sizeMaxPixels * scale,\n      transitions: transitions && {\n        getPosition: transitions.getPosition,\n        getAngle: transitions.getAngle,\n        getColor: transitions.getColor,\n        getSize: transitions.getSize,\n        getPixelOffset: transitions.getPixelOffset\n      }\n    }, this.getSubLayerProps({\n      id: 'characters',\n      updateTriggers: {\n        getIcon: updateTriggers.getText,\n        getPosition: updateTriggers.getPosition,\n        getAngle: updateTriggers.getAngle,\n        getColor: updateTriggers.getColor,\n        getSize: updateTriggers.getSize,\n        getPixelOffset: updateTriggers.getPixelOffset,\n        getIconOffsets: {\n          getText: updateTriggers.getText,\n          getTextAnchor: updateTriggers.getTextAnchor,\n          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n          styleVersion\n        }\n      }\n    }), {\n      data,\n      _dataDiff,\n      startIndices,\n      numInstances,\n      getIconOffsets: this.getIconOffsets,\n      getIcon: getText\n    })];\n  }\n\n  static set fontAtlasCacheLimit(limit) {\n    setFontAtlasCacheLimit(limit);\n  }\n\n}\n\n_defineProperty(TextLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(TextLayer, \"layerName\", 'TextLayer');","map":{"version":3,"sources":["../../../src/text-layer/text-layer.ts"],"names":["TEXT_ANCHOR","start","middle","end","ALIGNMENT_BASELINE","top","center","bottom","DEFAULT_COLOR","DEFAULT_LINE_HEIGHT","defaultProps","billboard","sizeScale","sizeUnits","sizeMinPixels","sizeMaxPixels","Number","background","getBackgroundColor","type","value","getBorderColor","getBorderWidth","backgroundPadding","characterSet","DEFAULT_FONT_SETTINGS","fontFamily","fontWeight","lineHeight","outlineWidth","min","outlineColor","fontSettings","wordBreak","maxWidth","getText","x","text","getPosition","position","getColor","getSize","getAngle","getTextAnchor","getAlignmentBaseline","getPixelOffset","backgroundColor","deprecatedFor","TextLayer","initializeState","styleVersion","fontAtlasManager","updateState","changeFlags","textChanged","fontChanged","styleChanged","props","oldProps","getPickingInfo","info","_updateFontAtlas","fontProps","_updateText","textBuffer","data","startIndices","autoCharacterSet","characterCount","getTextFromBuffer","length","numInstances","index","texts","objectInfo","createIterable","Array","iconMapping","paragraph","size","transformParagraph","anchorX","anchorY","numCharacters","offsets","i","rowOffset","width","rowWidth","y","renderLayers","mapping","updateTriggers","CharactersLayerClass","BackgroundLayerClass","getFillColor","getLineColor","getLineWidth","padding","transitions","id","getBoundingRect","attributes","autoHighlight","sdf","smoothing","iconAtlas","getIcon","getIconOffsets","fontAtlasCacheLimit","setFontAtlasCacheLimit"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, createIterable} from '@deck.gl/core';\nimport MultiIconLayer from './multi-icon-layer/multi-icon-layer';\nimport FontAtlasManager, {\n  DEFAULT_FONT_SETTINGS,\n  setFontAtlasCacheLimit\n} from './font-atlas-manager';\nimport {transformParagraph, getTextFromBuffer} from './utils';\n\nimport TextBackgroundLayer from './text-background-layer/text-background-layer';\n\nimport type {FontSettings} from './font-atlas-manager';\nimport type {\n  LayerProps,\n  Accessor,\n  AccessorFunction,\n  Unit,\n  Position,\n  Color,\n  UpdateParameters,\n  GetPickingInfoParams,\n  PickingInfo,\n  DefaultProps\n} from '@deck.gl/core';\n\nconst TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n} as const;\n\nconst ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n} as const;\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\nconst DEFAULT_LINE_HEIGHT = 1.0;\n\ntype _TextLayerProps<DataT> = {\n  /** If `true`, the text always faces camera. Otherwise the text faces up (z).\n   * @default true\n   */\n  billboard?: boolean;\n  /**\n   * Text size multiplier.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * The units of the size, one of `'meters'`, `'common'`, and `'pixels'`.\n   * @default 'pixels'\n   */\n  sizeUnits?: Unit;\n  /**\n   * The minimum size in pixels. When using non-pixel `sizeUnits`, this prop can be used to prevent the icon from getting too small when zoomed out.\n   * @default 0\n   */\n  sizeMinPixels?: number;\n  /**\n   * The maximum size in pixels. When using non-pixel `sizeUnits`, this prop can be used to prevent the icon from getting too big when zoomed in.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  sizeMaxPixels?: number;\n\n  /** Whether to render background for the text blocks.\n   * @default false\n   */\n  background?: boolean;\n  /** Background color accessor.\n   * @default [255, 255, 255, 255]\n   */\n  getBackgroundColor?: Accessor<DataT, Color>;\n  /** Border color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getBorderColor?: Accessor<DataT, Color>;\n  /** Border width accessor.\n   * @default 0\n   */\n  getBorderWidth?: Accessor<DataT, number>;\n  /**\n   * The padding of the background..\n   * If an array of 2 is supplied, it is interpreted as `[padding_x, padding_y]` in pixels.\n   * If an array of 4 is supplied, it is interpreted as `[padding_left, padding_top, padding_right, padding_bottom]` in pixels.\n   * @default [0, 0, 0, 0]\n   */\n  backgroundPadding?: [number, number] | [number, number, number, number];\n  /**\n   * Specifies a list of characters to include in the font. If set to 'auto', will be automatically generated from the data set.\n   * @default (ASCII characters 32-128)\n   */\n  characterSet?: FontSettings['characterSet'] | 'auto';\n  /** CSS font family\n   * @default 'Monaco, monospace'\n   */\n  fontFamily?: FontSettings['fontFamily'];\n  /** CSS font weight\n   * @default 'normal'\n   */\n  fontWeight?: FontSettings['fontWeight'];\n  /** A unitless number that will be multiplied with the current font size to set the line height.\n   * @default 'normal'\n   */\n  lineHeight?: number;\n  /**\n   * Width of outline around the text, relative to the font size. Only effective if `fontSettings.sdf` is `true`.\n   * @default 0\n   */\n  outlineWidth?: number;\n  /**\n   * Color of outline around the text, in `[r, g, b, [a]]`. Each channel is a number between 0-255 and `a` is 255 if not supplied.\n   * @default [0, 0, 0, 255]\n   */\n  outlineColor?: Color;\n  /**\n   * Advance options for fine tuning the appearance and performance of the generated shared `fontAtlas`.\n   */\n  fontSettings?: FontSettings;\n  /**\n   * Available options are `break-all` and `break-word`. A valid `maxWidth` has to be provided to use `wordBreak`.\n   * @default 'break-word'\n   */\n  wordBreak?: 'break-word' | 'break-all';\n  /**\n   * `maxWidth` is used together with `break-word` for wrapping text. The value of `maxWidth` specifies the width limit to break the text into multiple lines.\n   * @default -1\n   */\n  maxWidth?: number;\n  /**\n   * Label text accessor\n   */\n  getText?: AccessorFunction<DataT, string>;\n  /**\n   * Anchor position accessor\n   */\n  getPosition?: Accessor<DataT, Position>;\n  /**\n   * Label color accessor\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Label size accessor\n   * @default 32\n   */\n  getSize?: Accessor<DataT, number>;\n  /**\n   * Label rotation accessor, in degrees\n   * @default 0\n   */\n  getAngle?: Accessor<DataT, number>;\n  /**\n   * Horizontal alignment accessor\n   * @default 'middle'\n   */\n  getTextAnchor?: Accessor<DataT, 'start' | 'middle' | 'end'>;\n  /**\n   * Vertical alignment accessor\n   * @default 'center'\n   */\n  getAlignmentBaseline?: Accessor<DataT, 'top' | 'center' | 'bottom'>;\n  /**\n   * Label offset from the anchor position, [x, y] in pixels\n   * @default [0, 0]\n   */\n  getPixelOffset?: Accessor<DataT, [number, number]>;\n  /**\n   * @deprecated Use `background` and `getBackgroundColor` instead\n   */\n  backgroundColor?: Color;\n};\n\nexport type TextLayerProps<DataT = any> = _TextLayerProps<DataT> & LayerProps<DataT>;\n\nconst defaultProps: DefaultProps<TextLayerProps> = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n\n  background: false,\n  getBackgroundColor: {type: 'accessor', value: [255, 255, 255, 255]},\n  getBorderColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getBorderWidth: {type: 'accessor', value: 0},\n  backgroundPadding: {type: 'array', value: [0, 0, 0, 0]},\n\n  characterSet: {type: 'object', value: DEFAULT_FONT_SETTINGS.characterSet},\n  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,\n  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  outlineWidth: {type: 'number', value: 0, min: 0},\n  outlineColor: {type: 'color', value: DEFAULT_COLOR},\n  fontSettings: {},\n\n  // auto wrapping options\n  wordBreak: 'break-word',\n  maxWidth: {type: 'number', value: -1},\n\n  getText: {type: 'accessor', value: x => x.text},\n  getPosition: {type: 'accessor', value: x => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getSize: {type: 'accessor', value: 32},\n  getAngle: {type: 'accessor', value: 0},\n  getTextAnchor: {type: 'accessor', value: 'middle'},\n  getAlignmentBaseline: {type: 'accessor', value: 'center'},\n  getPixelOffset: {type: 'accessor', value: [0, 0]},\n\n  // deprecated\n  backgroundColor: {deprecatedFor: ['background', 'getBackgroundColor']}\n};\n\n/** Render text labels at given coordinates. */\nexport default class TextLayer<DataT = any, ExtraPropsT = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_TextLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'TextLayer';\n\n  state!: {\n    styleVersion: number;\n    fontAtlasManager: FontAtlasManager;\n    characterSet?: Set<string>;\n    startIndices?: number[];\n    numInstances?: number;\n    getText?: AccessorFunction<DataT, string>;\n  };\n\n  initializeState() {\n    this.state = {\n      styleVersion: 0,\n      fontAtlasManager: new FontAtlasManager()\n    };\n  }\n\n  // eslint-disable-next-line complexity\n  updateState(params: UpdateParameters<this>) {\n    const {props, oldProps, changeFlags} = params;\n    const textChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText));\n\n    if (textChanged) {\n      this._updateText();\n    }\n\n    const fontChanged = this._updateFontAtlas();\n\n    const styleChanged =\n      fontChanged ||\n      props.lineHeight !== oldProps.lineHeight ||\n      props.wordBreak !== oldProps.wordBreak ||\n      props.maxWidth !== oldProps.maxWidth;\n\n    if (styleChanged) {\n      this.setState({\n        styleVersion: this.state.styleVersion + 1\n      });\n    }\n  }\n\n  getPickingInfo({info}: GetPickingInfoParams): PickingInfo {\n    // because `TextLayer` assign the same pickingInfoIndex for one text label,\n    // here info.index refers the index of text label in props.data\n    info.object = info.index >= 0 ? this.props.data[info.index] : null;\n    return info;\n  }\n\n  /** Returns true if font has changed */\n  private _updateFontAtlas(): boolean {\n    const {fontSettings, fontFamily, fontWeight} = this.props;\n    const {fontAtlasManager, characterSet} = this.state;\n\n    const fontProps = {\n      ...fontSettings,\n      characterSet,\n      fontFamily,\n      fontWeight\n    };\n\n    if (!fontAtlasManager.mapping) {\n      // This is the first update\n      fontAtlasManager.setProps(fontProps);\n      return true;\n    }\n\n    for (const key in fontProps) {\n      if (fontProps[key] !== fontAtlasManager.props[key]) {\n        fontAtlasManager.setProps(fontProps);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // Text strings are variable width objects\n  // Count characters and start offsets\n  private _updateText() {\n    const {data, characterSet} = this.props;\n    const textBuffer = (data as any).attributes?.getText;\n    let {getText} = this.props;\n    let startIndices: number[] = (data as any).startIndices;\n    let numInstances: number;\n\n    const autoCharacterSet = characterSet === 'auto' && new Set();\n\n    if (textBuffer && startIndices) {\n      const {texts, characterCount} = getTextFromBuffer({\n        ...(ArrayBuffer.isView(textBuffer) ? {value: textBuffer} : textBuffer),\n        // @ts-ignore if data.attribute is defined then length is expected\n        length: data.length,\n        startIndices,\n        characterSet: autoCharacterSet\n      });\n      numInstances = characterCount;\n      getText = (_, {index}) => texts[index];\n    } else {\n      const {iterable, objectInfo} = createIterable(data);\n      startIndices = [0];\n      numInstances = 0;\n\n      for (const object of iterable) {\n        objectInfo.index++;\n        // Break into an array of characters\n        // When dealing with double-length unicode characters, `str.length` or `str[i]` do not work\n        const text = Array.from(getText(object, objectInfo) || '');\n        if (autoCharacterSet) {\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          text.forEach(autoCharacterSet.add, autoCharacterSet);\n        }\n        numInstances += text.length;\n        startIndices.push(numInstances);\n      }\n    }\n\n    this.setState({\n      getText,\n      startIndices,\n      numInstances,\n      characterSet: autoCharacterSet || characterSet\n    });\n  }\n\n  // Returns the x, y offsets of each character in a text string\n  private getBoundingRect: AccessorFunction<DataT, [number, number, number, number]> = (\n    object,\n    objectInfo\n  ) => {\n    const iconMapping = this.state.fontAtlasManager.mapping!;\n    const getText = this.state.getText!;\n    const {wordBreak, maxWidth, lineHeight, getTextAnchor, getAlignmentBaseline} = this.props;\n\n    const paragraph = getText(object, objectInfo) || '';\n    const {\n      size: [width, height]\n    } = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);\n    const anchorX =\n      TEXT_ANCHOR[\n        typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor\n      ];\n    const anchorY =\n      ALIGNMENT_BASELINE[\n        typeof getAlignmentBaseline === 'function'\n          ? getAlignmentBaseline(object, objectInfo)\n          : getAlignmentBaseline\n      ];\n\n    return [((anchorX - 1) * width) / 2, ((anchorY - 1) * height) / 2, width, height];\n  };\n\n  // Returns the x, y, w, h of each text object\n  private getIconOffsets: AccessorFunction<DataT, number[]> = (object, objectInfo) => {\n    const iconMapping = this.state.fontAtlasManager.mapping!;\n    const getText = this.state.getText!;\n    const {wordBreak, maxWidth, lineHeight, getTextAnchor, getAlignmentBaseline} = this.props;\n\n    const paragraph = getText(object, objectInfo) || '';\n    const {\n      x,\n      y,\n      rowWidth,\n      size: [width, height]\n    } = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);\n    const anchorX =\n      TEXT_ANCHOR[\n        typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor\n      ];\n    const anchorY =\n      ALIGNMENT_BASELINE[\n        typeof getAlignmentBaseline === 'function'\n          ? getAlignmentBaseline(object, objectInfo)\n          : getAlignmentBaseline\n      ];\n\n    const numCharacters = x.length;\n    const offsets = new Array(numCharacters * 2);\n    let index = 0;\n\n    for (let i = 0; i < numCharacters; i++) {\n      // For a multi-line object, offset in x-direction needs consider\n      // the row offset in the paragraph and the object offset in the row\n      const rowOffset = ((1 - anchorX) * (width - rowWidth[i])) / 2;\n      offsets[index++] = ((anchorX - 1) * width) / 2 + rowOffset + x[i];\n      offsets[index++] = ((anchorY - 1) * height) / 2 + y[i];\n    }\n    return offsets;\n  };\n\n  renderLayers() {\n    const {\n      startIndices,\n      numInstances,\n      getText,\n      fontAtlasManager: {scale, texture, mapping},\n      styleVersion\n    } = this.state;\n\n    const {\n      data,\n      _dataDiff,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      getBackgroundColor,\n      getBorderColor,\n      getBorderWidth,\n      backgroundPadding,\n      background,\n      billboard,\n      fontSettings,\n      outlineWidth,\n      outlineColor,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    const CharactersLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n    const BackgroundLayerClass = this.getSubLayerClass('background', TextBackgroundLayer);\n\n    return [\n      background &&\n        new BackgroundLayerClass(\n          {\n            // background props\n            getFillColor: getBackgroundColor,\n            getLineColor: getBorderColor,\n            getLineWidth: getBorderWidth,\n            padding: backgroundPadding,\n\n            // props shared with characters layer\n            getPosition,\n            getSize,\n            getAngle,\n            getPixelOffset,\n            billboard,\n            sizeScale: sizeScale / this.state.fontAtlasManager.props.fontSize,\n            sizeUnits,\n            sizeMinPixels,\n            sizeMaxPixels,\n\n            transitions: transitions && {\n              getPosition: transitions.getPosition,\n              getAngle: transitions.getAngle,\n              getSize: transitions.getSize,\n              getFillColor: transitions.getBackgroundColor,\n              getLineColor: transitions.getBorderColor,\n              getLineWidth: transitions.getBorderWidth,\n              getPixelOffset: transitions.getPixelOffset\n            }\n          },\n          this.getSubLayerProps({\n            id: 'background',\n            updateTriggers: {\n              getPosition: updateTriggers.getPosition,\n              getAngle: updateTriggers.getAngle,\n              getSize: updateTriggers.getSize,\n              getFillColor: updateTriggers.getBackgroundColor,\n              getLineColor: updateTriggers.getBorderColor,\n              getLineWidth: updateTriggers.getBorderWidth,\n              getPixelOffset: updateTriggers.getPixelOffset,\n              getBoundingRect: {\n                getText: updateTriggers.getText,\n                getTextAnchor: updateTriggers.getTextAnchor,\n                getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n                styleVersion\n              }\n            }\n          }),\n          {\n            data:\n              // @ts-ignore (2339) attribute is not defined on all data types\n              data.attributes && data.attributes.background\n                ? // @ts-ignore (2339) attribute is not defined on all data types\n                  {length: data.length, attributes: data.attributes.background}\n                : data,\n            _dataDiff,\n            // Maintain the same background behavior as <=8.3. Remove in v9?\n            autoHighlight: false,\n            getBoundingRect: this.getBoundingRect\n          }\n        ),\n      new CharactersLayerClass(\n        {\n          sdf: fontSettings.sdf,\n          smoothing: Number.isFinite(fontSettings.smoothing)\n            ? fontSettings.smoothing\n            : DEFAULT_FONT_SETTINGS.smoothing,\n          outlineWidth,\n          outlineColor,\n          iconAtlas: texture,\n          iconMapping: mapping,\n\n          getPosition,\n          getColor,\n          getSize,\n          getAngle,\n          getPixelOffset,\n\n          billboard,\n          sizeScale: sizeScale * scale,\n          sizeUnits,\n          sizeMinPixels: sizeMinPixels * scale,\n          sizeMaxPixels: sizeMaxPixels * scale,\n\n          transitions: transitions && {\n            getPosition: transitions.getPosition,\n            getAngle: transitions.getAngle,\n            getColor: transitions.getColor,\n            getSize: transitions.getSize,\n            getPixelOffset: transitions.getPixelOffset\n          }\n        },\n        this.getSubLayerProps({\n          id: 'characters',\n          updateTriggers: {\n            getIcon: updateTriggers.getText,\n            getPosition: updateTriggers.getPosition,\n            getAngle: updateTriggers.getAngle,\n            getColor: updateTriggers.getColor,\n            getSize: updateTriggers.getSize,\n            getPixelOffset: updateTriggers.getPixelOffset,\n            getIconOffsets: {\n              getText: updateTriggers.getText,\n              getTextAnchor: updateTriggers.getTextAnchor,\n              getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n              styleVersion\n            }\n          }\n        }),\n        {\n          data,\n          _dataDiff,\n          startIndices,\n          numInstances,\n          getIconOffsets: this.getIconOffsets,\n          getIcon: getText\n        }\n      )\n    ];\n  }\n\n  static set fontAtlasCacheLimit(limit: number) {\n    setFontAtlasCacheLimit(limit);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}