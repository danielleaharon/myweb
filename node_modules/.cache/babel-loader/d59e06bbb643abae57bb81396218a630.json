{"ast":null,"code":"import { log, assertWebGLContext } from '@luma.gl/gltools';\nimport Texture from './texture';\nconst FACES = [34069, 34070, 34071, 34072, 34073, 34074];\nexport default class TextureCube extends Texture {\n  get [Symbol.toStringTag]() {\n    return 'TextureCube';\n  }\n\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assertWebGLContext(gl);\n    super(gl, Object.assign({}, props, {\n      target: 34067\n    }));\n    this.initialize(props);\n    Object.seal(this);\n  }\n\n  initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      mipmaps = true,\n      parameters = {}\n    } = props;\n    this.opts = props;\n    this.setCubeMapImageData(props).then(() => {\n      this.loaded = true;\n\n      if (mipmaps) {\n        this.generateMipmap(props);\n      }\n\n      this.setParameters(parameters);\n    });\n    return this;\n  }\n\n  subImage(_ref) {\n    let {\n      face,\n      data,\n      x = 0,\n      y = 0,\n      mipmapLevel = 0\n    } = _ref;\n    return this._subImage({\n      target: face,\n      data,\n      x,\n      y,\n      mipmapLevel\n    });\n  }\n\n  async setCubeMapImageData(_ref2) {\n    let {\n      width,\n      height,\n      pixels,\n      data,\n      border = 0,\n      format = 6408,\n      type = 5121\n    } = _ref2;\n    const {\n      gl\n    } = this;\n    const imageDataMap = pixels || data;\n    const resolvedFaces = await Promise.all(FACES.map(face => {\n      const facePixels = imageDataMap[face];\n      return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);\n    }));\n    this.bind();\n    FACES.forEach((face, index) => {\n      if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {\n        log.warn(\"\".concat(this.id, \" has mipmap and multiple LODs.\"))();\n      }\n\n      resolvedFaces[index].forEach((image, lodLevel) => {\n        if (width && height) {\n          gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);\n        } else {\n          gl.texImage2D(face, lodLevel, format, format, type, image);\n        }\n      });\n    });\n    this.unbind();\n  }\n\n  setImageDataForFace(options) {\n    const {\n      face,\n      width,\n      height,\n      pixels,\n      data,\n      border = 0,\n      format = 6408,\n      type = 5121\n    } = options;\n    const {\n      gl\n    } = this;\n    const imageData = pixels || data;\n    this.bind();\n\n    if (imageData instanceof Promise) {\n      imageData.then(resolvedImageData => this.setImageDataForFace(Object.assign({}, options, {\n        face,\n        data: resolvedImageData,\n        pixels: resolvedImageData\n      })));\n    } else if (this.width || this.height) {\n      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);\n    } else {\n      gl.texImage2D(face, 0, format, format, type, imageData);\n    }\n\n    return this;\n  }\n\n}\nTextureCube.FACES = FACES;","map":{"version":3,"sources":["../../../src/classes/texture-cube.js"],"names":["FACES","Symbol","toStringTag","constructor","props","assertWebGLContext","target","Object","initialize","mipmaps","parameters","subImage","x","y","mipmapLevel","setCubeMapImageData","border","format","type","gl","imageDataMap","pixels","resolvedFaces","face","facePixels","Promise","Array","log","width","setImageDataForFace","imageData","resolvedImageData","data","TextureCube"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {log, assertWebGLContext} from '@luma.gl/gltools';\nimport Texture from './texture';\n\nconst FACES = [\n  GL.TEXTURE_CUBE_MAP_POSITIVE_X,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_X,\n  GL.TEXTURE_CUBE_MAP_POSITIVE_Y,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n  GL.TEXTURE_CUBE_MAP_POSITIVE_Z,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_Z\n];\n\nexport default class TextureCube extends Texture {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'TextureCube';\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGLContext(gl);\n\n    super(gl, Object.assign({}, props, {target: GL.TEXTURE_CUBE_MAP}));\n\n    this.initialize(props);\n\n    Object.seal(this);\n  }\n\n  initialize(props = {}) {\n    const {mipmaps = true, parameters = {}} = props;\n\n    // Store props for accessors\n    this.opts = props;\n\n    // @ts-ignore\n    this.setCubeMapImageData(props).then(() => {\n      this.loaded = true;\n\n      // TODO - should genMipmap() be called on the cubemap or on the faces?\n      // TODO - without generateMipmap() cube textures do not work at all!!! Why?\n      if (mipmaps) {\n        this.generateMipmap(props);\n      }\n\n      this.setParameters(parameters);\n    });\n    return this;\n  }\n\n  subImage({face, data, x = 0, y = 0, mipmapLevel = 0}) {\n    // @ts-ignore TODO - is this a bug?\n    return this._subImage({target: face, data, x, y, mipmapLevel});\n  }\n\n  /* eslint-disable max-statements, max-len */\n  async setCubeMapImageData({\n    width,\n    height,\n    pixels,\n    data,\n    border = 0,\n    format = GL.RGBA,\n    type = GL.UNSIGNED_BYTE\n  }) {\n    const {gl} = this;\n    const imageDataMap = pixels || data;\n\n    // pixel data (imageDataMap) is an Object from Face to Image or Promise.\n    // For example:\n    // {\n    // GL.TEXTURE_CUBE_MAP_POSITIVE_X : Image-or-Promise,\n    // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : Image-or-Promise,\n    // ... }\n    // To provide multiple level-of-details (LODs) this can be Face to Array\n    // of Image or Promise, like this\n    // {\n    // GL.TEXTURE_CUBE_MAP_POSITIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n    // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n    // ... }\n\n    const resolvedFaces = await Promise.all(\n      FACES.map(face => {\n        const facePixels = imageDataMap[face];\n        return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);\n      })\n    );\n\n    this.bind();\n\n    FACES.forEach((face, index) => {\n      if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {\n        // If the user provides multiple LODs, then automatic mipmap\n        // generation generateMipmap() should be disabled to avoid overwritting them.\n        log.warn(`${this.id} has mipmap and multiple LODs.`)();\n      }\n      resolvedFaces[index].forEach((image, lodLevel) => {\n        // TODO: adjust width & height for LOD!\n        if (width && height) {\n          gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);\n        } else {\n          gl.texImage2D(face, lodLevel, format, format, type, image);\n        }\n      });\n    });\n\n    this.unbind();\n  }\n\n  // TODO: update this method to accept LODs\n  setImageDataForFace(options) {\n    const {\n      face,\n      width,\n      height,\n      pixels,\n      data,\n      border = 0,\n      format = GL.RGBA,\n      type = GL.UNSIGNED_BYTE\n      // generateMipmap = false // TODO\n    } = options;\n\n    const {gl} = this;\n\n    const imageData = pixels || data;\n\n    this.bind();\n    if (imageData instanceof Promise) {\n      imageData.then(resolvedImageData =>\n        this.setImageDataForFace(\n          Object.assign({}, options, {\n            face,\n            data: resolvedImageData,\n            pixels: resolvedImageData\n          })\n        )\n      );\n    } else if (this.width || this.height) {\n      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);\n    } else {\n      gl.texImage2D(face, 0, format, format, type, imageData);\n    }\n\n    return this;\n  }\n}\n\nTextureCube.FACES = FACES;\n"]},"metadata":{},"sourceType":"module"}