{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Attribute from './attribute';\nimport log from '../../utils/log';\nimport debug from '../../debug';\nimport AttributeTransitionManager from './attribute-transition-manager';\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\nexport default class AttributeManager {\n  constructor(gl, {\n    id = 'attribute-manager',\n    stats,\n    timeline\n  } = {}) {\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"gl\", void 0);\n\n    _defineProperty(this, \"attributes\", void 0);\n\n    _defineProperty(this, \"updateTriggers\", void 0);\n\n    _defineProperty(this, \"needsRedraw\", void 0);\n\n    _defineProperty(this, \"userData\", void 0);\n\n    _defineProperty(this, \"stats\", void 0);\n\n    _defineProperty(this, \"attributeTransitionManager\", void 0);\n\n    this.id = id;\n    this.gl = gl;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.needsRedraw = true;\n    this.userData = {};\n    this.stats = stats;\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: \"\".concat(id, \"-transitions\"),\n      timeline\n    });\n    Object.seal(this);\n  }\n\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n\n    this.attributeTransitionManager.finalize();\n  }\n\n  getNeedsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n\n  setNeedsRedraw() {\n    this.needsRedraw = true;\n  }\n\n  add(attributes) {\n    this._add(attributes);\n  }\n\n  addInstanced(attributes) {\n    this._add(attributes, {\n      instanced: 1\n    });\n  }\n\n  remove(attributeNameArray) {\n    for (const name of attributeNameArray) {\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  invalidate(triggerName, dataRange) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n\n    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n\n  invalidateAll(dataRange) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n\n    debug(TRACE_INVALIDATE, this, 'all');\n  }\n\n  update({\n    data,\n    numInstances,\n    startIndices = null,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {}\n  }) {\n    let updated = false;\n    debug(TRACE_UPDATE_START, this);\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n      attribute.numInstances = numInstances;\n\n      if (props[attributeName]) {\n        log.removed(\"props.\".concat(attributeName), \"data.attributes.\".concat(attributeName))();\n      }\n\n      if (attribute.setExternalBuffer(buffers[attributeName])) {} else if (attribute.setBinaryValue(typeof accessorName === 'string' ? buffers[accessorName] : undefined, data.startIndices)) {} else if (typeof accessorName === 'string' && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {} else if (attribute.needsUpdate()) {\n        updated = true;\n\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n\n      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();\n    }\n\n    if (updated) {\n      debug(TRACE_UPDATE_END, this, numInstances);\n    }\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n\n  updateTransition() {\n    const {\n      attributeTransitionManager\n    } = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getChangedAttributes(opts = {\n    clearChangedFlags: false\n  }) {\n    const {\n      attributes,\n      attributeTransitionManager\n    } = this;\n    const changedAttributes = { ...attributeTransitionManager.getAttributes()\n    };\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n\n    return changedAttributes;\n  }\n\n  getShaderAttributes(attributes, excludeAttributes = {}) {\n    if (!attributes) {\n      attributes = this.getAttributes();\n    }\n\n    const shaderAttributes = {};\n\n    for (const attributeName in attributes) {\n      if (!excludeAttributes[attributeName]) {\n        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n      }\n    }\n\n    return shaderAttributes;\n  }\n\n  _add(attributes, extraProps = {}) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);\n    }\n\n    this._mapUpdateTriggersToAttributes();\n  }\n\n  _createAttribute(name, attribute, extraProps) {\n    const props = { ...attribute,\n      id: name,\n      size: attribute.isIndexed && 1 || attribute.size || 1,\n      divisor: extraProps.instanced ? 1 : attribute.divisor || 0\n    };\n    return new Attribute(this.gl, props);\n  }\n\n  _mapUpdateTriggersToAttributes() {\n    const triggers = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n\n        triggers[triggerName].push(attributeName);\n      });\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  _invalidateTrigger(triggerName, dataRange) {\n    const {\n      attributes,\n      updateTriggers\n    } = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n\n    return invalidatedAttributes;\n  }\n\n  _updateAttribute(opts) {\n    const {\n      attribute,\n      numInstances\n    } = opts;\n    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n\n    if (attribute.constant) {\n      attribute.setConstantValue(attribute.value);\n      return;\n    }\n\n    if (attribute.allocate(numInstances)) {\n      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n\n    const updated = attribute.updateBuffer(opts);\n\n    if (updated) {\n      this.needsRedraw = true;\n      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../../src/lib/attribute/attribute-manager.ts"],"names":["TRACE_INVALIDATE","TRACE_UPDATE_START","TRACE_UPDATE_END","TRACE_ATTRIBUTE_UPDATE_START","TRACE_ATTRIBUTE_ALLOCATE","TRACE_ATTRIBUTE_UPDATE_END","constructor","id","timeline","Object","finalize","getNeedsRedraw","opts","clearRedrawFlags","redraw","setNeedsRedraw","add","addInstanced","instanced","remove","invalidate","invalidatedAttributes","debug","invalidateAll","update","startIndices","props","buffers","context","updated","attribute","accessorName","log","data","attributes","transitions","updateTransition","attributeTransitionManager","transitionUpdated","getAttributes","getChangedAttributes","clearChangedFlags","changedAttributes","getShaderAttributes","excludeAttributes","shaderAttributes","_add","extraProps","_createAttribute","size","divisor","_mapUpdateTriggersToAttributes","triggers","triggerName","_invalidateTrigger","updateTriggers","name","_updateAttribute","numInstances"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\nimport Attribute, {AttributeOptions} from './attribute';\nimport {IShaderAttribute} from './shader-attribute';\nimport log from '../../utils/log';\nimport debug from '../../debug';\nimport {NumericArray} from '../../types/types';\n\nimport AttributeTransitionManager from './attribute-transition-manager';\n\nimport type {Stat} from 'probe.gl';\nimport type {Timeline} from '@luma.gl/engine';\n\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\n\nexport default class AttributeManager {\n  /**\n   * @classdesc\n   * Automated attribute generation and management. Suitable when a set of\n   * vertex shader attributes are generated by iteration over a data array,\n   * and updates to these attributes are needed either when the data itself\n   * changes, or when other data relevant to the calculations change.\n   *\n   * - First the application registers descriptions of its dynamic vertex\n   *   attributes using AttributeManager.add().\n   * - Then, when any change that affects attributes is detected by the\n   *   application, the app will call AttributeManager.invalidate().\n   * - Finally before it renders, it calls AttributeManager.update() to\n   *   ensure that attributes are automatically rebuilt if anything has been\n   *   invalidated.\n   *\n   * The application provided update functions describe how attributes\n   * should be updated from a data array and are expected to traverse\n   * that data array (or iterable) and fill in the attribute's typed array.\n   *\n   * Note that the attribute manager intentionally does not do advanced\n   * change detection, but instead makes it easy to build such detection\n   * by offering the ability to \"invalidate\" each attribute separately.\n   */\n  id: string;\n  gl: WebGLRenderingContext;\n  attributes: Record<string, Attribute>;\n  updateTriggers: {[name: string]: string[]};\n  needsRedraw: string | boolean;\n  userData: any;\n\n  private stats?: Stat;\n  private attributeTransitionManager: AttributeTransitionManager;\n\n  constructor(\n    gl: WebGLRenderingContext,\n    {\n      id = 'attribute-manager',\n      stats,\n      timeline\n    }: {\n      id?: string;\n      stats?: Stat;\n      timeline?: Timeline;\n    } = {}\n  ) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributes = {};\n\n    this.updateTriggers = {};\n    this.needsRedraw = true;\n\n    this.userData = {};\n    this.stats = stats;\n\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: `${id}-transitions`,\n      timeline\n    });\n\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n    this.attributeTransitionManager.finalize();\n  }\n\n  // Returns the redraw flag, optionally clearing it.\n  // Redraw flag will be set if any attributes attributes changed since\n  // flag was last cleared.\n  //\n  // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n  // @return {false|String} - reason a redraw is needed.\n  getNeedsRedraw(opts: {clearRedrawFlags?: boolean} = {clearRedrawFlags: false}): string | false {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n\n  // Sets the redraw flag.\n  // @param {Boolean} redraw=true\n  setNeedsRedraw() {\n    this.needsRedraw = true;\n  }\n\n  // Adds attributes\n  add(attributes: {[id: string]: AttributeOptions}) {\n    this._add(attributes);\n  }\n\n  // Adds attributes\n  addInstanced(attributes: {[id: string]: AttributeOptions}) {\n    this._add(attributes, {instanced: 1});\n  }\n\n  /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray: string[]) {\n    for (const name of attributeNameArray) {\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  // Marks an attribute for update\n  invalidate(triggerName: string, dataRange?: {startRow?: number; endRow?: number}) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n\n  invalidateAll(dataRange?: {startRow?: number; endRow?: number}) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, 'all');\n  }\n\n  // Ensure all attribute buffers are updated from props or data.\n  update({\n    data,\n    numInstances,\n    startIndices = null,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {}\n  }: {\n    data: any;\n    numInstances: number;\n    startIndices?: NumericArray | null;\n    transitions: any;\n    props: any;\n    buffers: any;\n    context: any;\n  }) {\n    // keep track of whether some attributes are updated\n    let updated = false;\n\n    debug(TRACE_UPDATE_START, this);\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n      attribute.numInstances = numInstances;\n\n      if (props[attributeName]) {\n        log.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();\n      }\n\n      if (attribute.setExternalBuffer(buffers[attributeName])) {\n        // Step 1: try update attribute directly from external buffers\n      } else if (\n        attribute.setBinaryValue(\n          typeof accessorName === 'string' ? buffers[accessorName] : undefined,\n          data.startIndices\n        )\n      ) {\n        // Step 2: try set packed value from external typed array\n      } else if (\n        typeof accessorName === 'string' &&\n        !buffers[accessorName] &&\n        attribute.setConstantValue(props[accessorName])\n      ) {\n        // Step 3: try set constant value from props\n        // Note: if buffers[accessorName] is supplied, ignore props[accessorName]\n        // This may happen when setBinaryValue falls through to use the auto updater\n      } else if (attribute.needsUpdate()) {\n        // Step 4: update via updater callback\n        updated = true;\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n\n      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();\n    }\n\n    if (updated) {\n      // Only initiate alloc/update (and logging) if actually needed\n      debug(TRACE_UPDATE_END, this, numInstances);\n    }\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n\n  // Update attribute transition to the current timestamp\n  // Returns `true` if any transition is in progress\n  updateTransition() {\n    const {attributeTransitionManager} = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes(): {[id: string]: Attribute} {\n    return this.attributes;\n  }\n\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuffers need to be updated\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes(opts: {clearChangedFlags?: boolean} = {clearChangedFlags: false}): {\n    [id: string]: Attribute;\n  } {\n    const {attributes, attributeTransitionManager} = this;\n\n    const changedAttributes = {...attributeTransitionManager.getAttributes()};\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n\n    return changedAttributes;\n  }\n\n  // Returns shader attributes\n  getShaderAttributes(\n    attributes?: {[id: string]: Attribute},\n    excludeAttributes: Record<string, boolean> = {}\n  ): {[id: string]: IShaderAttribute} {\n    if (!attributes) {\n      attributes = this.getAttributes();\n    }\n    const shaderAttributes = {};\n    for (const attributeName in attributes) {\n      if (!excludeAttributes[attributeName]) {\n        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n      }\n    }\n    return shaderAttributes;\n  }\n\n  // PRIVATE METHODS\n\n  // Used to register an attribute\n  private _add(attributes: {[id: string]: AttributeOptions}, extraProps: any = {}) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);\n    }\n\n    this._mapUpdateTriggersToAttributes();\n  }\n  /* eslint-enable max-statements */\n\n  private _createAttribute(name: string, attribute: AttributeOptions, extraProps: any) {\n    // For expected default values see:\n    // https://github.com/visgl/luma.gl/blob/1affe21352e289eeaccee2a876865138858a765c/modules/webgl/src/classes/accessor.js#L5-L13\n    // and https://deck.gl/docs/api-reference/core/attribute-manager#add\n    const props: AttributeOptions = {\n      ...attribute,\n      id: name,\n      size: (attribute.isIndexed && 1) || attribute.size || 1,\n      divisor: extraProps.instanced ? 1 : attribute.divisor || 0\n    };\n\n    return new Attribute(this.gl, props);\n  }\n\n  // build updateTrigger name to attribute name mapping\n  private _mapUpdateTriggersToAttributes() {\n    const triggers: {[name: string]: string[]} = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n        triggers[triggerName].push(attributeName);\n      });\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  private _invalidateTrigger(\n    triggerName: string,\n    dataRange?: {startRow?: number; endRow?: number}\n  ): string[] {\n    const {attributes, updateTriggers} = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n    return invalidatedAttributes;\n  }\n\n  private _updateAttribute(opts: {\n    attribute: Attribute;\n    numInstances: number;\n    data: any;\n    props: any;\n    context: any;\n  }) {\n    const {attribute, numInstances} = opts;\n    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n\n    if (attribute.constant) {\n      // The attribute is flagged as constant outside of an update cycle\n      // Skip allocation and updater call\n      attribute.setConstantValue(attribute.value as NumericArray);\n      return;\n    }\n\n    if (attribute.allocate(numInstances)) {\n      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n\n    // Calls update on any buffers that need update\n    const updated = attribute.updateBuffer(opts);\n    if (updated) {\n      this.needsRedraw = true;\n      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}