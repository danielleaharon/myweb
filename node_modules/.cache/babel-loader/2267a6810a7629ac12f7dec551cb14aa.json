{"ast":null,"code":"import { COORDINATE_SYSTEM } from '../../lib/constants';\nimport { getOffsetOrigin } from './viewport-uniforms';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\nimport * as vec4 from 'gl-matrix/vec4';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { addMetersToLngLat } from '@math.gl/web-mercator';\n\nfunction lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {\n  const p = viewport.projectPosition(lngLatZ);\n\n  if (offsetMode && viewport instanceof WebMercatorViewport) {\n    const [longitude, latitude, z = 0] = lngLatZ;\n    const distanceScales = viewport.getDistanceScales([longitude, latitude]);\n    p[2] = z * distanceScales.unitsPerMeter[2];\n  }\n\n  return p;\n}\n\nfunction normalizeParameters(opts) {\n  const {\n    viewport,\n    modelMatrix,\n    coordinateOrigin\n  } = opts;\n  let {\n    coordinateSystem,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  } = opts;\n\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  if (fromCoordinateSystem === undefined) {\n    fromCoordinateSystem = coordinateSystem;\n  }\n\n  if (fromCoordinateOrigin === undefined) {\n    fromCoordinateOrigin = coordinateOrigin;\n  }\n\n  return {\n    viewport,\n    coordinateSystem,\n    coordinateOrigin,\n    modelMatrix,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  };\n}\n\nexport function getWorldPosition(position, {\n  viewport,\n  modelMatrix,\n  coordinateSystem,\n  coordinateOrigin,\n  offsetMode\n}) {\n  let [x, y, z = 0] = position;\n\n  if (modelMatrix) {\n    [x, y, z] = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);\n  }\n\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n      return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x, y, z]), viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.CARTESIAN:\n    default:\n      return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);\n  }\n}\nexport function projectPosition(position, params) {\n  const {\n    viewport,\n    coordinateSystem,\n    coordinateOrigin,\n    modelMatrix,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  } = normalizeParameters(params);\n  const {\n    geospatialOrigin,\n    shaderCoordinateOrigin,\n    offsetMode\n  } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);\n  const worldPosition = getWorldPosition(position, {\n    viewport,\n    modelMatrix,\n    coordinateSystem: fromCoordinateSystem,\n    coordinateOrigin: fromCoordinateOrigin,\n    offsetMode\n  });\n\n  if (offsetMode) {\n    const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n    vec3.sub(worldPosition, worldPosition, positionCommonSpace);\n  }\n\n  return worldPosition;\n}","map":{"version":3,"sources":["../../../../src/shaderlib/project/project-functions.ts"],"names":["offsetMode","p","viewport","z","distanceScales","coordinateOrigin","fromCoordinateOrigin","coordinateSystem","COORDINATE_SYSTEM","fromCoordinateSystem","vec4","lngLatZToWorldPosition","x","y","addMetersToLngLat","normalizeParameters","getOffsetOrigin","worldPosition","getWorldPosition","positionCommonSpace","geospatialOrigin","vec3"],"mappings":"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","sourcesContent":["/**\n * Projection utils\n * TODO: move to Viewport class?\n */\nimport {COORDINATE_SYSTEM} from '../../lib/constants';\nimport {getOffsetOrigin} from './viewport-uniforms';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\n\nimport * as vec4 from 'gl-matrix/vec4';\nimport * as vec3 from 'gl-matrix/vec3';\nimport {addMetersToLngLat} from '@math.gl/web-mercator';\n\nimport type {CoordinateSystem} from '../../lib/constants';\nimport type Viewport from '../../viewports/viewport';\nimport type {NumericArray} from '../../types/types';\n\n// In project.glsl, offset modes calculate z differently from LNG_LAT mode.\n// offset modes apply the y adjustment (unitsPerMeter2) when projecting z\n// LNG_LAT mode only use the linear scale.\nfunction lngLatZToWorldPosition(\n  lngLatZ: [number, number, number],\n  viewport: Viewport,\n  offsetMode: boolean = false\n): [number, number, number] {\n  const p = viewport.projectPosition(lngLatZ);\n\n  // TODO - avoid using instanceof\n  if (offsetMode && viewport instanceof WebMercatorViewport) {\n    const [longitude, latitude, z = 0] = lngLatZ;\n    const distanceScales = viewport.getDistanceScales([longitude, latitude]);\n    p[2] = z * distanceScales.unitsPerMeter[2];\n  }\n  return p;\n}\n\nfunction normalizeParameters(opts: {\n  viewport: Viewport;\n  coordinateSystem: CoordinateSystem;\n  coordinateOrigin: [number, number, number];\n  modelMatrix?: NumericArray | null;\n  fromCoordinateSystem?: CoordinateSystem;\n  fromCoordinateOrigin?: [number, number, number];\n}): {\n  viewport: Viewport;\n  coordinateSystem: CoordinateSystem;\n  coordinateOrigin: [number, number, number];\n  modelMatrix?: NumericArray | null;\n  fromCoordinateSystem: CoordinateSystem;\n  fromCoordinateOrigin: [number, number, number];\n} {\n  const {viewport, modelMatrix, coordinateOrigin} = opts;\n  let {coordinateSystem, fromCoordinateSystem, fromCoordinateOrigin} = opts;\n\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial\n      ? COORDINATE_SYSTEM.LNGLAT\n      : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  if (fromCoordinateSystem === undefined) {\n    fromCoordinateSystem = coordinateSystem;\n  }\n  if (fromCoordinateOrigin === undefined) {\n    fromCoordinateOrigin = coordinateOrigin;\n  }\n\n  return {\n    viewport,\n    coordinateSystem,\n    coordinateOrigin,\n    modelMatrix,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  };\n}\n\n/** Get the common space position from world coordinates in the given coordinate system */\nexport function getWorldPosition(\n  position: number[],\n  {\n    viewport,\n    modelMatrix,\n    coordinateSystem,\n    coordinateOrigin,\n    offsetMode\n  }: {\n    viewport: Viewport;\n    modelMatrix?: NumericArray | null;\n    coordinateSystem: CoordinateSystem;\n    coordinateOrigin: [number, number, number];\n    offsetMode?: boolean;\n  }\n): [number, number, number] {\n  let [x, y, z = 0] = position;\n\n  if (modelMatrix) {\n    [x, y, z] = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);\n  }\n\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n      return lngLatZToWorldPosition(\n        [x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)],\n        viewport,\n        offsetMode\n      );\n\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n      return lngLatZToWorldPosition(\n        addMetersToLngLat(coordinateOrigin, [x, y, z]) as [number, number, number],\n        viewport,\n        offsetMode\n      );\n\n    case COORDINATE_SYSTEM.CARTESIAN:\n    default:\n      return viewport.isGeospatial\n        ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]]\n        : viewport.projectPosition([x, y, z]);\n  }\n}\n\n/**\n * Equivalent to project_position in project.glsl\n * projects a user supplied position to world position directly with or without\n * a reference coordinate system\n */\nexport function projectPosition(\n  position: number[],\n  params: {\n    /** The current viewport */\n    viewport: Viewport;\n    /** The reference coordinate system used to align world position */\n    coordinateSystem: CoordinateSystem;\n    /** The reference coordinate origin used to align world position */\n    coordinateOrigin: [number, number, number];\n    /** The model matrix of the supplied position */\n    modelMatrix?: NumericArray | null;\n    /** The coordinate system that the supplied position is in. Default to the same as `coordinateSystem`. */\n    fromCoordinateSystem?: CoordinateSystem;\n    /** The coordinate origin that the supplied position is in. Default to the same as `coordinateOrigin`. */\n    fromCoordinateOrigin?: [number, number, number];\n  }\n): [number, number, number] {\n  const {\n    viewport,\n    coordinateSystem,\n    coordinateOrigin,\n    modelMatrix,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  } = normalizeParameters(params);\n\n  const {geospatialOrigin, shaderCoordinateOrigin, offsetMode} = getOffsetOrigin(\n    viewport,\n    coordinateSystem,\n    coordinateOrigin\n  );\n\n  const worldPosition = getWorldPosition(position, {\n    viewport,\n    modelMatrix,\n    coordinateSystem: fromCoordinateSystem,\n    coordinateOrigin: fromCoordinateOrigin,\n    offsetMode\n  });\n\n  if (offsetMode) {\n    const positionCommonSpace = viewport.projectPosition(\n      geospatialOrigin || shaderCoordinateOrigin\n    );\n    vec3.sub(worldPosition, worldPosition, positionCommonSpace);\n  }\n\n  return worldPosition;\n}\n"]},"metadata":{},"sourceType":"module"}