{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { isAsyncIterable } from '../utils/iterable-utils';\nimport { ASYNC_ORIGINAL_SYMBOL, ASYNC_RESOLVED_SYMBOL, ASYNC_DEFAULTS_SYMBOL } from './constants';\nconst EMPTY_PROPS = Object.freeze({});\nexport default class ComponentState {\n  constructor(component) {\n    _defineProperty(this, \"component\", void 0);\n\n    _defineProperty(this, \"onAsyncPropUpdated\", void 0);\n\n    _defineProperty(this, \"asyncProps\", void 0);\n\n    _defineProperty(this, \"oldProps\", void 0);\n\n    _defineProperty(this, \"oldAsyncProps\", void 0);\n\n    this.component = component;\n    this.asyncProps = {};\n\n    this.onAsyncPropUpdated = () => {};\n\n    this.oldProps = null;\n    this.oldAsyncProps = null;\n  }\n\n  finalize() {\n    for (const propName in this.asyncProps) {\n      const asyncProp = this.asyncProps[propName];\n\n      if (asyncProp && asyncProp.type && asyncProp.type.release) {\n        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);\n      }\n    }\n  }\n\n  getOldProps() {\n    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;\n  }\n\n  resetOldProps() {\n    this.oldAsyncProps = null;\n    this.oldProps = this.component.props;\n  }\n\n  hasAsyncProp(propName) {\n    return propName in this.asyncProps;\n  }\n\n  getAsyncProp(propName) {\n    const asyncProp = this.asyncProps[propName];\n    return asyncProp && asyncProp.resolvedValue;\n  }\n\n  isAsyncPropLoading(propName) {\n    if (propName) {\n      const asyncProp = this.asyncProps[propName];\n      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);\n    }\n\n    for (const key in this.asyncProps) {\n      if (this.isAsyncPropLoading(key)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reloadAsyncProp(propName, value) {\n    this._watchPromise(propName, Promise.resolve(value));\n  }\n\n  setAsyncProps(props) {\n    const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};\n    const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;\n    const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};\n\n    for (const propName in resolvedValues) {\n      const value = resolvedValues[propName];\n\n      this._createAsyncPropData(propName, defaultValues[propName]);\n\n      this._updateAsyncProp(propName, value);\n\n      resolvedValues[propName] = this.getAsyncProp(propName);\n    }\n\n    for (const propName in originalValues) {\n      const value = originalValues[propName];\n\n      this._createAsyncPropData(propName, defaultValues[propName]);\n\n      this._updateAsyncProp(propName, value);\n    }\n  }\n\n  _fetch(propName, url) {\n    return null;\n  }\n\n  _onResolve(propName, value) {}\n\n  _onError(propName, error) {}\n\n  _updateAsyncProp(propName, value) {\n    if (!this._didAsyncInputValueChange(propName, value)) {\n      return;\n    }\n\n    if (typeof value === 'string') {\n      value = this._fetch(propName, value);\n    }\n\n    if (value instanceof Promise) {\n      this._watchPromise(propName, value);\n\n      return;\n    }\n\n    if (isAsyncIterable(value)) {\n      this._resolveAsyncIterable(propName, value);\n\n      return;\n    }\n\n    this._setPropValue(propName, value);\n  }\n\n  _freezeAsyncOldProps() {\n    if (!this.oldAsyncProps && this.oldProps) {\n      this.oldAsyncProps = Object.create(this.oldProps);\n\n      for (const propName in this.asyncProps) {\n        Object.defineProperty(this.oldAsyncProps, propName, {\n          enumerable: true,\n          value: this.oldProps[propName]\n        });\n      }\n    }\n  }\n\n  _didAsyncInputValueChange(propName, value) {\n    const asyncProp = this.asyncProps[propName];\n\n    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {\n      return false;\n    }\n\n    asyncProp.lastValue = value;\n    return true;\n  }\n\n  _setPropValue(propName, value) {\n    this._freezeAsyncOldProps();\n\n    const asyncProp = this.asyncProps[propName];\n\n    if (asyncProp) {\n      value = this._postProcessValue(asyncProp, value);\n      asyncProp.resolvedValue = value;\n      asyncProp.pendingLoadCount++;\n      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n    }\n  }\n\n  _setAsyncPropValue(propName, value, loadCount) {\n    const asyncProp = this.asyncProps[propName];\n\n    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n      this._freezeAsyncOldProps();\n\n      asyncProp.resolvedValue = value;\n      asyncProp.resolvedLoadCount = loadCount;\n      this.onAsyncPropUpdated(propName, value);\n    }\n  }\n\n  _watchPromise(propName, promise) {\n    const asyncProp = this.asyncProps[propName];\n\n    if (asyncProp) {\n      asyncProp.pendingLoadCount++;\n      const loadCount = asyncProp.pendingLoadCount;\n      promise.then(data => {\n        data = this._postProcessValue(asyncProp, data);\n\n        this._setAsyncPropValue(propName, data, loadCount);\n\n        this._onResolve(propName, data);\n      }).catch(error => {\n        this._onError(propName, error);\n      });\n    }\n  }\n\n  async _resolveAsyncIterable(propName, iterable) {\n    if (propName !== 'data') {\n      this._setPropValue(propName, iterable);\n\n      return;\n    }\n\n    const asyncProp = this.asyncProps[propName];\n\n    if (!asyncProp) {\n      return;\n    }\n\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    let data = [];\n    let count = 0;\n\n    for await (const chunk of iterable) {\n      const {\n        dataTransform\n      } = this.component.props;\n\n      if (dataTransform) {\n        data = dataTransform(chunk, data);\n      } else {\n        data = data.concat(chunk);\n      }\n\n      Object.defineProperty(data, '__diff', {\n        enumerable: false,\n        value: [{\n          startRow: count,\n          endRow: data.length\n        }]\n      });\n      count = data.length;\n\n      this._setAsyncPropValue(propName, data, loadCount);\n    }\n\n    this._onResolve(propName, data);\n  }\n\n  _postProcessValue(asyncProp, value) {\n    const propType = asyncProp.type;\n\n    if (propType) {\n      if (propType.release) {\n        propType.release(asyncProp.resolvedValue, propType, this.component);\n      }\n\n      if (propType.transform) {\n        return propType.transform(value, propType, this.component);\n      }\n    }\n\n    return value;\n  }\n\n  _createAsyncPropData(propName, defaultValue) {\n    const asyncProp = this.asyncProps[propName];\n\n    if (!asyncProp) {\n      const propTypes = this.component && this.component.constructor._propTypes;\n      this.asyncProps[propName] = {\n        type: propTypes && propTypes[propName],\n        lastValue: null,\n        resolvedValue: defaultValue,\n        pendingLoadCount: 0,\n        resolvedLoadCount: 0\n      };\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/lifecycle/component-state.ts"],"names":["EMPTY_PROPS","Object","constructor","finalize","asyncProp","getOldProps","resetOldProps","hasAsyncProp","propName","getAsyncProp","isAsyncPropLoading","Boolean","reloadAsyncProp","Promise","setAsyncProps","resolvedValues","props","originalValues","defaultValues","value","_fetch","_onResolve","_onError","_updateAsyncProp","isAsyncIterable","_freezeAsyncOldProps","enumerable","_didAsyncInputValueChange","_setPropValue","_setAsyncPropValue","loadCount","_watchPromise","promise","data","error","_resolveAsyncIterable","count","dataTransform","startRow","endRow","length","_postProcessValue","propType","_createAsyncPropData","propTypes","type","lastValue","resolvedValue","pendingLoadCount","resolvedLoadCount"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {isAsyncIterable} from '../utils/iterable-utils';\nimport {ASYNC_ORIGINAL_SYMBOL, ASYNC_RESOLVED_SYMBOL, ASYNC_DEFAULTS_SYMBOL} from './constants';\nimport type Component from './component';\nimport {PropType} from './prop-types';\n\nconst EMPTY_PROPS = Object.freeze({});\n\ntype AsyncPropState = {\n  type: PropType;\n  lastValue: any;\n  resolvedValue: any;\n  pendingLoadCount: number;\n  resolvedLoadCount: number;\n};\n\nexport default class ComponentState<ComponentT extends Component> {\n  component: ComponentT;\n  onAsyncPropUpdated: (propName: string, value: any) => void;\n\n  private asyncProps: Partial<Record<string, AsyncPropState>>;\n  private oldProps: ComponentT['props'] | null;\n  private oldAsyncProps: ComponentT['props'] | null;\n\n  constructor(component: ComponentT) {\n    this.component = component;\n    this.asyncProps = {}; // Prop values that the layer sees\n    this.onAsyncPropUpdated = () => {};\n    this.oldProps = null; // Last props before update\n    this.oldAsyncProps = null; // Last props before update, with async values copied.\n  }\n\n  finalize() {\n    for (const propName in this.asyncProps) {\n      const asyncProp = this.asyncProps[propName];\n      if (asyncProp && asyncProp.type && asyncProp.type.release) {\n        // Release any resources created by transforms\n        asyncProp.type.release(\n          asyncProp.resolvedValue,\n          asyncProp.type,\n          this.component as Component\n        );\n      }\n    }\n  }\n\n  /* Layer-facing props API */\n\n  getOldProps(): ComponentT['props'] | typeof EMPTY_PROPS {\n    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;\n  }\n\n  resetOldProps() {\n    this.oldAsyncProps = null;\n    this.oldProps = this.component.props;\n  }\n\n  // Checks if a prop is overridden\n  hasAsyncProp(propName: string): boolean {\n    return propName in this.asyncProps;\n  }\n\n  // Returns value of an overriden prop\n  getAsyncProp(propName: string): any {\n    const asyncProp = this.asyncProps[propName];\n    return asyncProp && asyncProp.resolvedValue;\n  }\n\n  isAsyncPropLoading(propName?: string): boolean {\n    if (propName) {\n      const asyncProp = this.asyncProps[propName];\n      return Boolean(\n        asyncProp &&\n          asyncProp.pendingLoadCount > 0 &&\n          asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount\n      );\n    }\n    for (const key in this.asyncProps) {\n      if (this.isAsyncPropLoading(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Without changing the original prop value, swap out the data resolution under the hood\n  reloadAsyncProp(propName: string, value: any) {\n    this._watchPromise(propName, Promise.resolve(value));\n  }\n\n  // Updates all async/overridden props (when new props come in)\n  // Checks if urls have changed, starts loading, or removes override\n  setAsyncProps(props: ComponentT['props']) {\n    // NOTE: prop param and default values are only support for testing\n    const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};\n    const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;\n    const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};\n\n    // TODO - use async props from the layer's prop types\n    for (const propName in resolvedValues) {\n      const value = resolvedValues[propName];\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n      // Use transformed value\n      resolvedValues[propName] = this.getAsyncProp(propName);\n    }\n\n    for (const propName in originalValues) {\n      const value = originalValues[propName];\n      // Makes sure a record exists for this prop\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n  }\n\n  /* Placeholder methods for subclassing */\n\n  protected _fetch(propName: string, url: string): any {\n    return null;\n  }\n\n  protected _onResolve(propName: string, value: any) {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n  protected _onError(propName: string, error: Error) {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n  // Intercept strings (URLs) and Promises and activates loading and prop rewriting\n  private _updateAsyncProp(propName: string, value: any) {\n    if (!this._didAsyncInputValueChange(propName, value)) {\n      return;\n    }\n\n    // interpret value string as url and start a new load tracked by a promise\n    if (typeof value === 'string') {\n      value = this._fetch(propName, value);\n    }\n\n    // interprets promise and track the \"loading\"\n    if (value instanceof Promise) {\n      this._watchPromise(propName, value);\n      return;\n    }\n\n    if (isAsyncIterable(value)) {\n      this._resolveAsyncIterable(propName, value); // eslint-disable-line @typescript-eslint/no-floating-promises\n      return;\n    }\n\n    // else, normal, non-async value. Just store value for now\n    this._setPropValue(propName, value);\n  }\n\n  // Whenever async props are changing, we need to make a copy of oldProps\n  // otherwise the prop rewriting will affect the value both in props and oldProps.\n  // While the copy is relatively expensive, this only happens on load completion.\n  private _freezeAsyncOldProps() {\n    if (!this.oldAsyncProps && this.oldProps) {\n      // 1. inherit all synchronous props from oldProps\n      // 2. reconfigure the async prop descriptors to fixed values\n      this.oldAsyncProps = Object.create(this.oldProps);\n      for (const propName in this.asyncProps) {\n        Object.defineProperty(this.oldAsyncProps, propName, {\n          enumerable: true,\n          value: this.oldProps[propName]\n        });\n      }\n    }\n  }\n\n  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)\n  private _didAsyncInputValueChange(propName: string, value: any): boolean {\n    // @ts-ignore\n    const asyncProp: AsyncPropState = this.asyncProps[propName];\n    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {\n      return false;\n    }\n    asyncProp.lastValue = value;\n    return true;\n  }\n\n  // Set normal, non-async value\n  private _setPropValue(propName: string, value: any) {\n    // Save the current value before overwriting so that diffProps can access both\n    this._freezeAsyncOldProps();\n\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp) {\n      value = this._postProcessValue(asyncProp, value);\n      asyncProp.resolvedValue = value;\n      asyncProp.pendingLoadCount++;\n      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n    }\n  }\n\n  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously\n  private _setAsyncPropValue(propName: string, value: any, loadCount: number) {\n    // Only update if loadCount is larger or equal to resolvedLoadCount\n    // otherwise a more recent load has already completed\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n      // Save the current value before overwriting so that diffProps can access both\n      this._freezeAsyncOldProps();\n\n      asyncProp.resolvedValue = value;\n      asyncProp.resolvedLoadCount = loadCount;\n\n      // Call callback to inform listener\n      this.onAsyncPropUpdated(propName, value);\n    }\n  }\n\n  // Tracks a promise, sets the prop when loaded, handles load count\n  private _watchPromise(propName: string, promise: Promise<any>) {\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp) {\n      asyncProp.pendingLoadCount++;\n      const loadCount = asyncProp.pendingLoadCount;\n      promise\n        .then(data => {\n          data = this._postProcessValue(asyncProp, data);\n          this._setAsyncPropValue(propName, data, loadCount);\n          this._onResolve(propName, data);\n        })\n        .catch(error => {\n          this._onError(propName, error);\n        });\n    }\n  }\n\n  private async _resolveAsyncIterable(\n    propName: string,\n    iterable: AsyncIterable<any>\n  ): Promise<void> {\n    if (propName !== 'data') {\n      // we only support data as async iterable\n      this._setPropValue(propName, iterable);\n      return;\n    }\n\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      return;\n    }\n\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    let data: any[] = [];\n    let count = 0;\n\n    for await (const chunk of iterable) {\n      // @ts-expect-error (2339) dataTransform is not decared in base component props\n      const {dataTransform} = this.component.props;\n      if (dataTransform) {\n        data = dataTransform(chunk, data) as any[];\n      } else {\n        data = data.concat(chunk);\n      }\n\n      // Used by the default _dataDiff function\n      Object.defineProperty(data, '__diff', {\n        enumerable: false,\n        value: [{startRow: count, endRow: data.length}]\n      });\n\n      count = data.length;\n      this._setAsyncPropValue(propName, data, loadCount);\n    }\n\n    this._onResolve(propName, data);\n  }\n\n  // Give the app a chance to post process the loaded data\n  private _postProcessValue(asyncProp, value: any) {\n    const propType = asyncProp.type;\n    if (propType) {\n      if (propType.release) {\n        propType.release(asyncProp.resolvedValue, propType, this.component);\n      }\n      if (propType.transform) {\n        return propType.transform(value, propType, this.component);\n      }\n    }\n    return value;\n  }\n\n  // Creating an asyncProp record if needed\n  private _createAsyncPropData(propName: string, defaultValue: any) {\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      // @ts-expect-error\n      const propTypes = this.component && this.component.constructor._propTypes;\n      // assert(defaultValue !== undefined);\n      this.asyncProps[propName] = {\n        type: propTypes && propTypes[propName],\n        lastValue: null, // Supplied prop value (can be url/promise, not visible to layer)\n        resolvedValue: defaultValue, // Resolved prop value (valid data, can be \"shown\" to layer)\n        pendingLoadCount: 0, // How many loads have been issued\n        resolvedLoadCount: 0 // Latest resolved load, (earlier loads will be ignored)\n      };\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}