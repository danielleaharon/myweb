{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport TransitionInterpolator from './transition-interpolator';\nimport { lerp } from '@math.gl/core';\nconst DEFAULT_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];\nconst DEFAULT_REQUIRED_PROPS = ['longitude', 'latitude', 'zoom'];\nexport default class LinearInterpolator extends TransitionInterpolator {\n  constructor(opts = {}) {\n    const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;\n    const normalizedOpts = Array.isArray(opts) ? {} : opts;\n    normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {\n      compare: transitionProps,\n      required: transitionProps\n    } : transitionProps || {\n      compare: DEFAULT_PROPS,\n      required: DEFAULT_REQUIRED_PROPS\n    };\n    super(normalizedOpts.transitionProps);\n\n    _defineProperty(this, \"opts\", void 0);\n\n    this.opts = normalizedOpts;\n  }\n\n  initializeProps(startProps, endProps) {\n    const result = super.initializeProps(startProps, endProps);\n    const {\n      makeViewport,\n      around\n    } = this.opts;\n\n    if (makeViewport && around) {\n      const startViewport = makeViewport(startProps);\n      const endViewport = makeViewport(endProps);\n      const aroundPosition = startViewport.unproject(around);\n      result.start.around = around;\n      Object.assign(result.end, {\n        around: endViewport.project(aroundPosition),\n        aroundPosition,\n        width: endProps.width,\n        height: endProps.height\n      });\n    }\n\n    return result;\n  }\n\n  interpolateProps(startProps, endProps, t) {\n    const propsInTransition = {};\n\n    for (const key of this._propsToExtract) {\n      propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t);\n    }\n\n    if (endProps.aroundPosition && this.opts.makeViewport) {\n      const viewport = this.opts.makeViewport({ ...endProps,\n        ...propsInTransition\n      });\n      Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, lerp(startProps.around, endProps.around, t)));\n    }\n\n    return propsInTransition;\n  }\n\n}","map":{"version":3,"sources":["../../../src/transitions/linear-interpolator.ts"],"names":["DEFAULT_PROPS","DEFAULT_REQUIRED_PROPS","constructor","opts","transitionProps","Array","normalizedOpts","compare","required","initializeProps","result","around","makeViewport","startViewport","endViewport","aroundPosition","Object","width","endProps","height","interpolateProps","propsInTransition","lerp","startProps","viewport"],"mappings":";AAAA,OAAA,sBAAA,MAAA,2BAAA;AACA,SAAA,IAAA,QAAA,eAAA;AAIA,MAAMA,aAAa,GAAG,CAAA,WAAA,EAAA,UAAA,EAAA,MAAA,EAAA,SAAA,EAAtB,OAAsB,CAAtB;AACA,MAAMC,sBAAsB,GAAG,CAAA,WAAA,EAAA,UAAA,EAA/B,MAA+B,CAA/B;AAWA,eAAe,MAAA,kBAAA,SAAA,sBAAA,CAAwD;AAYrEC,EAAAA,WAAW,CACTC,IAYK,GAbI,EAAA,EAcT;AAEA,UAAMC,eAAe,GAAGC,KAAK,CAALA,OAAAA,CAAAA,IAAAA,IAAAA,IAAAA,GAA6BF,IAAI,CAAzD,eAAA;AAEA,UAAMG,cAAc,GAAGD,KAAK,CAALA,OAAAA,CAAAA,IAAAA,IAAAA,EAAAA,GAAvB,IAAA;AACAC,IAAAA,cAAc,CAAdA,eAAAA,GAAiC,KAAK,CAAL,OAAA,CAAA,eAAA,IAC7B;AACEC,MAAAA,OAAO,EADT,eAAA;AAEEC,MAAAA,QAAQ,EAAEJ;AAFZ,KAD6B,GAK7BA,eAAe,IAAI;AACjBG,MAAAA,OAAO,EADU,aAAA;AAEjBC,MAAAA,QAAQ,EAAEP;AAFO,KALvBK;AAUA,UAAMA,cAAc,CAApB,eAAA;;AAfA,IAAA,eAAA,CAAA,IAAA,EAAA,MAAA,EAAA,KAAA,CAAA,CAAA;;AAgBA,SAAA,IAAA,GAAA,cAAA;AACD;;AAEDG,EAAAA,eAAe,CAAA,UAAA,EAAA,QAAA,EAMb;AACA,UAAMC,MAAM,GAAG,MAAA,eAAA,CAAA,UAAA,EAAf,QAAe,CAAf;AAEA,UAAM;AAAA,MAAA,YAAA;AAAeC,MAAAA;AAAf,QAAyB,KAA/B,IAAA;;AACA,QAAIC,YAAY,IAAhB,MAAA,EAA4B;AAC1B,YAAMC,aAAa,GAAGD,YAAY,CAAlC,UAAkC,CAAlC;AACA,YAAME,WAAW,GAAGF,YAAY,CAAhC,QAAgC,CAAhC;AACA,YAAMG,cAAc,GAAGF,aAAa,CAAbA,SAAAA,CAAvB,MAAuBA,CAAvB;AACAH,MAAAA,MAAM,CAANA,KAAAA,CAAAA,MAAAA,GAAAA,MAAAA;AACAM,MAAAA,MAAM,CAANA,MAAAA,CAAcN,MAAM,CAApBM,GAAAA,EAA0B;AACxBL,QAAAA,MAAM,EAAEG,WAAW,CAAXA,OAAAA,CADgB,cAChBA,CADgB;AAAA,QAAA,cAAA;AAGxBG,QAAAA,KAAK,EAAEC,QAAQ,CAHS,KAAA;AAIxBC,QAAAA,MAAM,EAAED,QAAQ,CAACC;AAJO,OAA1BH;AAMD;;AAED,WAAA,MAAA;AACD;;AAEDI,EAAAA,gBAAgB,CAAA,UAAA,EAAA,QAAA,EAAA,CAAA,EAIO;AACrB,UAAMC,iBAAiB,GAAvB,EAAA;;AACA,SAAK,MAAL,GAAA,IAAkB,KAAlB,eAAA,EAAwC;AACtCA,MAAAA,iBAAiB,CAAjBA,GAAiB,CAAjBA,GAAyBC,IAAI,CAACC,UAAU,CAAVA,GAAU,CAAVA,IAAD,CAAA,EAAuBL,QAAQ,CAARA,GAAQ,CAARA,IAAvB,CAAA,EAA7BG,CAA6B,CAA7BA;AACD;;AAED,QAAIH,QAAQ,CAARA,cAAAA,IAA2B,KAAA,IAAA,CAA/B,YAAA,EAAuD;AAErD,YAAMM,QAAQ,GAAG,KAAA,IAAA,CAAA,YAAA,CAAuB,EAAC,GAAD,QAAA;AAAc,WAAGH;AAAjB,OAAvB,CAAjB;AACAL,MAAAA,MAAM,CAANA,MAAAA,CAAAA,iBAAAA,EAEEQ,QAAQ,CAARA,aAAAA,CACEN,QAAQ,CADVM,cAAAA,EAGEF,IAAI,CAACC,UAAU,CAAX,MAAA,EAAgCL,QAAQ,CAAxC,MAAA,EALRF,CAKQ,CAHNQ,CAFFR;AAQD;;AACD,WAAA,iBAAA;AACD;;AA9FoE","sourcesContent":["import TransitionInterpolator from './transition-interpolator';\nimport {lerp} from '@math.gl/core';\n\nimport type Viewport from '../viewports/viewport';\n\nconst DEFAULT_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];\nconst DEFAULT_REQUIRED_PROPS = ['longitude', 'latitude', 'zoom'];\n\ntype PropsWithAnchor = {\n  around?: number[];\n  aroundPosition?: number[];\n  [key: string]: any;\n};\n\n/**\n * Performs linear interpolation of two view states.\n */\nexport default class LinearInterpolator extends TransitionInterpolator {\n  opts: {\n    around?: number[];\n    makeViewport?: (props: Record<string, any>) => Viewport;\n  };\n\n  /**\n   * @param {Object} opts\n   * @param {Array} opts.transitionProps - list of props to apply linear transition to.\n   * @param {Array} opts.around - a screen point to zoom/rotate around.\n   * @param {Function} opts.makeViewport - construct a viewport instance with given props.\n   */\n  constructor(\n    opts:\n      | string[]\n      | {\n          transitionProps?:\n            | string[]\n            | {\n                compare: string[];\n                extract?: string[];\n                required?: string[];\n              };\n          around?: number[];\n          makeViewport?: (props: Record<string, any>) => Viewport;\n        } = {}\n  ) {\n    // Backward compatibility\n    const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;\n\n    const normalizedOpts = Array.isArray(opts) ? {} : opts;\n    normalizedOpts.transitionProps = Array.isArray(transitionProps)\n      ? {\n          compare: transitionProps,\n          required: transitionProps\n        }\n      : transitionProps || {\n          compare: DEFAULT_PROPS,\n          required: DEFAULT_REQUIRED_PROPS\n        };\n\n    super(normalizedOpts.transitionProps);\n    this.opts = normalizedOpts;\n  }\n\n  initializeProps(\n    startProps: Record<string, any>,\n    endProps: Record<string, any>\n  ): {\n    start: PropsWithAnchor;\n    end: PropsWithAnchor;\n  } {\n    const result = super.initializeProps(startProps, endProps);\n\n    const {makeViewport, around} = this.opts;\n    if (makeViewport && around) {\n      const startViewport = makeViewport(startProps);\n      const endViewport = makeViewport(endProps);\n      const aroundPosition = startViewport.unproject(around);\n      result.start.around = around;\n      Object.assign(result.end, {\n        around: endViewport.project(aroundPosition),\n        aroundPosition,\n        width: endProps.width,\n        height: endProps.height\n      });\n    }\n\n    return result;\n  }\n\n  interpolateProps(\n    startProps: PropsWithAnchor,\n    endProps: PropsWithAnchor,\n    t: number\n  ): Record<string, any> {\n    const propsInTransition = {};\n    for (const key of this._propsToExtract) {\n      propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t);\n    }\n\n    if (endProps.aroundPosition && this.opts.makeViewport) {\n      // Linear transition should be performed in common space\n      const viewport = this.opts.makeViewport({...endProps, ...propsInTransition});\n      Object.assign(\n        propsInTransition,\n        viewport.panByPosition(\n          endProps.aroundPosition,\n          // anchor point in current screen coordinates\n          lerp(startProps.around as number[], endProps.around as number[], t) as number[]\n        )\n      );\n    }\n    return propsInTransition;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}