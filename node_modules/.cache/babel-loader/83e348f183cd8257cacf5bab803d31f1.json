{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Pass from './pass';\nimport { clear, setParameters, withParameters, cssToDeviceRatio } from '@luma.gl/core';\nexport default class LayersPass extends Pass {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"_lastRenderIndex\", -1);\n  }\n\n  render(options) {\n    const gl = this.gl;\n    setParameters(gl, {\n      framebuffer: options.target\n    });\n    return this._drawLayers(options);\n  }\n\n  _drawLayers(options) {\n    const {\n      target,\n      moduleParameters,\n      viewports,\n      views,\n      onViewportActive,\n      clearStack = true,\n      clearCanvas = true\n    } = options;\n    options.pass = options.pass || 'unknown';\n    const gl = this.gl;\n\n    if (clearCanvas) {\n      clearGLCanvas(gl);\n    }\n\n    if (clearStack) {\n      this._lastRenderIndex = -1;\n    }\n\n    const renderStats = [];\n\n    for (const viewport of viewports) {\n      const view = views && views[viewport.id];\n      onViewportActive(viewport);\n\n      const drawLayerParams = this._getDrawLayerParams(viewport, options);\n\n      const subViewports = viewport.subViewports || [viewport];\n\n      for (const subViewport of subViewports) {\n        const stats = this._drawLayersInViewport(gl, {\n          target,\n          moduleParameters,\n          viewport: subViewport,\n          view,\n          pass: options.pass,\n          layers: options.layers\n        }, drawLayerParams);\n\n        renderStats.push(stats);\n      }\n    }\n\n    return renderStats;\n  }\n\n  _getDrawLayerParams(viewport, {\n    layers,\n    pass,\n    layerFilter,\n    cullRect,\n    effects,\n    moduleParameters\n  }) {\n    const drawLayerParams = [];\n    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);\n    const drawContext = {\n      layer: layers[0],\n      viewport,\n      isPicking: pass.startsWith('picking'),\n      renderPass: pass,\n      cullRect\n    };\n    const layerFilterCache = {};\n\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n\n      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);\n\n      const layerParam = {\n        shouldDrawLayer\n      };\n\n      if (shouldDrawLayer) {\n        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n        layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);\n        layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);\n      }\n\n      drawLayerParams[layerIndex] = layerParam;\n    }\n\n    return drawLayerParams;\n  }\n\n  _drawLayersInViewport(gl, {\n    layers,\n    moduleParameters: globalModuleParameters,\n    pass,\n    target,\n    viewport,\n    view\n  }, drawLayerParams) {\n    const glViewport = getGLViewport(gl, {\n      moduleParameters: globalModuleParameters,\n      target,\n      viewport\n    });\n\n    if (view && view.props.clear) {\n      const clearOpts = view.props.clear === true ? {\n        color: true,\n        depth: true\n      } : view.props.clear;\n      withParameters(gl, {\n        scissorTest: true,\n        scissor: glViewport\n      }, () => clear(gl, clearOpts));\n    }\n\n    const renderStatus = {\n      totalCount: layers.length,\n      visibleCount: 0,\n      compositeCount: 0,\n      pickableCount: 0\n    };\n    setParameters(gl, {\n      viewport: glViewport\n    });\n\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      const {\n        shouldDrawLayer,\n        layerRenderIndex,\n        moduleParameters,\n        layerParameters\n      } = drawLayerParams[layerIndex];\n\n      if (shouldDrawLayer && layer.props.pickable) {\n        renderStatus.pickableCount++;\n      }\n\n      if (layer.isComposite) {\n        renderStatus.compositeCount++;\n      } else if (shouldDrawLayer) {\n        renderStatus.visibleCount++;\n        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);\n        moduleParameters.viewport = viewport;\n\n        try {\n          layer._drawLayer({\n            moduleParameters,\n            uniforms: {\n              layerIndex: layerRenderIndex\n            },\n            parameters: layerParameters\n          });\n        } catch (err) {\n          layer.raiseError(err, \"drawing \".concat(layer, \" to \").concat(pass));\n        }\n      }\n    }\n\n    return renderStatus;\n  }\n\n  shouldDrawLayer(layer) {\n    return true;\n  }\n\n  getModuleParameters(layer, effects) {\n    return null;\n  }\n\n  getLayerParameters(layer, layerIndex, viewport) {\n    return layer.props.parameters;\n  }\n\n  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {\n    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);\n\n    if (!shouldDrawLayer) {\n      return false;\n    }\n\n    drawContext.layer = layer;\n    let parent = layer.parent;\n\n    while (parent) {\n      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {\n        return false;\n      }\n\n      drawContext.layer = parent;\n      parent = parent.parent;\n    }\n\n    if (layerFilter) {\n      const rootLayerId = drawContext.layer.id;\n\n      if (!(rootLayerId in layerFilterCache)) {\n        layerFilterCache[rootLayerId] = layerFilter(drawContext);\n      }\n\n      if (!layerFilterCache[rootLayerId]) {\n        return false;\n      }\n    }\n\n    layer.activateViewport(drawContext.viewport);\n    return true;\n  }\n\n  _getModuleParameters(layer, effects, pass, overrides) {\n    var _layer$internalState;\n\n    const moduleParameters = Object.assign(Object.create(((_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.propsInTransition) || layer.props), {\n      autoWrapLongitude: layer.wrapLongitude,\n      viewport: layer.context.viewport,\n      mousePosition: layer.context.mousePosition,\n      pickingActive: 0,\n      devicePixelRatio: cssToDeviceRatio(this.gl)\n    });\n\n    if (effects) {\n      for (const effect of effects) {\n        var _effect$getModulePara;\n\n        Object.assign(moduleParameters, (_effect$getModulePara = effect.getModuleParameters) === null || _effect$getModulePara === void 0 ? void 0 : _effect$getModulePara.call(effect, layer));\n      }\n    }\n\n    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);\n  }\n\n}\nexport function layerIndexResolver(startIndex = 0, layerIndices = {}) {\n  const resolvers = {};\n\n  const resolveLayerIndex = (layer, isDrawn) => {\n    const indexOverride = layer.props._offset;\n    const layerId = layer.id;\n    const parentId = layer.parent && layer.parent.id;\n    let index;\n\n    if (parentId && !(parentId in layerIndices)) {\n      resolveLayerIndex(layer.parent, false);\n    }\n\n    if (parentId in resolvers) {\n      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n\n    layerIndices[layerId] = index;\n    return index;\n  };\n\n  return resolveLayerIndex;\n}\n\nfunction getGLViewport(gl, {\n  moduleParameters,\n  target,\n  viewport\n}) {\n  const useTarget = target && target.id !== 'default-framebuffer';\n  const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || cssToDeviceRatio(gl);\n  const height = useTarget ? target.height : gl.drawingBufferHeight;\n  const dimensions = viewport;\n  return [dimensions.x * pixelRatio, height - (dimensions.y + dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];\n}\n\nfunction clearGLCanvas(gl) {\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  setParameters(gl, {\n    viewport: [0, 0, width, height]\n  });\n  gl.clear(16384 | 256);\n}","map":{"version":3,"sources":["../../../src/passes/layers-pass.ts"],"names":["render","gl","setParameters","framebuffer","options","target","_drawLayers","clearStack","clearCanvas","clearGLCanvas","renderStats","view","views","viewport","onViewportActive","drawLayerParams","subViewports","stats","pass","layers","_getDrawLayerParams","moduleParameters","indexResolver","layerIndexResolver","drawContext","layer","isPicking","renderPass","cullRect","layerFilterCache","layerIndex","shouldDrawLayer","layerParam","_drawLayersInViewport","glViewport","getGLViewport","clearOpts","color","depth","withParameters","scissorTest","scissor","clear","renderStatus","totalCount","visibleCount","compositeCount","pickableCount","layerParameters","Math","uniforms","layerRenderIndex","parameters","getModuleParameters","getLayerParameters","_shouldDrawLayer","parent","rootLayerId","layerFilter","_getModuleParameters","Object","autoWrapLongitude","mousePosition","pickingActive","devicePixelRatio","cssToDeviceRatio","effect","startIndex","layerIndices","resolvers","resolveLayerIndex","indexOverride","layerId","parentId","resolver","index","Number","isDrawn","useTarget","pixelRatio","height","dimensions","width"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport Pass from './pass';\nimport {clear, setParameters, withParameters, cssToDeviceRatio} from '@luma.gl/core';\n\nimport type {Framebuffer} from '@luma.gl/core';\nimport type Viewport from '../viewports/viewport';\nimport type View from '../views/view';\nimport type Layer from '../lib/layer';\nimport type {Effect} from '../lib/effect';\n\nexport type Rect = {x: number; y: number; width: number; height: number};\n\nexport type LayersPassRenderOptions = {\n  target?: Framebuffer;\n  pass: string;\n  layers: Layer[];\n  viewports: Viewport[];\n  onViewportActive: (viewport: Viewport) => void;\n  cullRect?: Rect;\n  views?: Record<string, View>;\n  effects?: Effect[];\n  /** If true, recalculates render index (z) from 0. Set to false if a stack of layers are rendered in multiple passes. */\n  clearStack?: boolean;\n  clearCanvas?: boolean;\n  layerFilter?: (context: FilterContext) => boolean;\n  moduleParameters?: any;\n};\n\ntype DrawLayerParameters = {\n  shouldDrawLayer: boolean;\n  layerRenderIndex?: number;\n  moduleParameters?: any;\n  layerParameters?: any;\n};\n\nexport type FilterContext = {\n  layer: Layer;\n  viewport: Viewport;\n  isPicking: boolean;\n  renderPass: string;\n  cullRect?: Rect;\n};\n\nexport type RenderStats = {\n  totalCount: number;\n  visibleCount: number;\n  compositeCount: number;\n  pickableCount: number;\n};\n\nexport default class LayersPass extends Pass {\n  _lastRenderIndex: number = -1;\n\n  render(options: LayersPassRenderOptions): any {\n    const gl = this.gl;\n\n    setParameters(gl, {framebuffer: options.target});\n    return this._drawLayers(options);\n  }\n\n  // Draw a list of layers in a list of viewports\n  private _drawLayers(options: LayersPassRenderOptions) {\n    const {\n      target,\n      moduleParameters,\n      viewports,\n      views,\n      onViewportActive,\n      clearStack = true,\n      clearCanvas = true\n    } = options;\n    options.pass = options.pass || 'unknown';\n\n    const gl = this.gl;\n    if (clearCanvas) {\n      clearGLCanvas(gl);\n    }\n\n    if (clearStack) {\n      this._lastRenderIndex = -1;\n    }\n\n    const renderStats: RenderStats[] = [];\n\n    for (const viewport of viewports) {\n      const view = views && views[viewport.id];\n\n      // Update context to point to this viewport\n      onViewportActive(viewport);\n\n      const drawLayerParams = this._getDrawLayerParams(viewport, options);\n\n      // render this viewport\n      // @ts-expect-error\n      const subViewports = viewport.subViewports || [viewport];\n      for (const subViewport of subViewports) {\n        const stats = this._drawLayersInViewport(\n          gl,\n          {\n            target,\n            moduleParameters,\n            viewport: subViewport,\n            view,\n            pass: options.pass,\n            layers: options.layers\n          },\n          drawLayerParams\n        );\n        renderStats.push(stats);\n      }\n    }\n    return renderStats;\n  }\n\n  // Resolve the parameters needed to draw each layer\n  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),\n  // this is only done once for the parent viewport\n  private _getDrawLayerParams(\n    viewport: Viewport,\n    {layers, pass, layerFilter, cullRect, effects, moduleParameters}: LayersPassRenderOptions\n  ): DrawLayerParameters[] {\n    const drawLayerParams: DrawLayerParameters[] = [];\n    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);\n    const drawContext: FilterContext = {\n      layer: layers[0],\n      viewport,\n      isPicking: pass.startsWith('picking'),\n      renderPass: pass,\n      cullRect\n    };\n    const layerFilterCache = {};\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      // Check if we should draw layer\n      const shouldDrawLayer = this._shouldDrawLayer(\n        layer,\n        drawContext,\n        layerFilter,\n        layerFilterCache\n      );\n\n      const layerParam: DrawLayerParameters = {\n        shouldDrawLayer\n      };\n\n      if (shouldDrawLayer) {\n        // This is the \"logical\" index for ordering this layer in the stack\n        // used to calculate polygon offsets\n        // It can be the same as another layer\n        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n\n        layerParam.moduleParameters = this._getModuleParameters(\n          layer,\n          effects,\n          pass,\n          moduleParameters\n        );\n        layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);\n      }\n      drawLayerParams[layerIndex] = layerParam;\n    }\n    return drawLayerParams;\n  }\n\n  // Draws a list of layers in one viewport\n  // TODO - when picking we could completely skip rendering viewports that dont\n  // intersect with the picking rect\n  /* eslint-disable max-depth, max-statements */\n  private _drawLayersInViewport(\n    gl,\n    {layers, moduleParameters: globalModuleParameters, pass, target, viewport, view},\n    drawLayerParams\n  ): RenderStats {\n    const glViewport = getGLViewport(gl, {\n      moduleParameters: globalModuleParameters,\n      target,\n      viewport\n    });\n\n    if (view && view.props.clear) {\n      const clearOpts = view.props.clear === true ? {color: true, depth: true} : view.props.clear;\n      withParameters(\n        gl,\n        {\n          scissorTest: true,\n          scissor: glViewport\n        },\n        () => clear(gl, clearOpts)\n      );\n    }\n\n    // render layers in normal colors\n    const renderStatus = {\n      totalCount: layers.length,\n      visibleCount: 0,\n      compositeCount: 0,\n      pickableCount: 0\n    };\n\n    setParameters(gl, {viewport: glViewport});\n\n    // render layers in normal colors\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      const {shouldDrawLayer, layerRenderIndex, moduleParameters, layerParameters} =\n        drawLayerParams[layerIndex];\n\n      // Calculate stats\n      if (shouldDrawLayer && layer.props.pickable) {\n        renderStatus.pickableCount++;\n      }\n      if (layer.isComposite) {\n        renderStatus.compositeCount++;\n      } else if (shouldDrawLayer) {\n        // Draw the layer\n        renderStatus.visibleCount++;\n\n        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);\n\n        // overwrite layer.context.viewport with the sub viewport\n        moduleParameters.viewport = viewport;\n\n        try {\n          layer._drawLayer({\n            moduleParameters,\n            uniforms: {layerIndex: layerRenderIndex},\n            parameters: layerParameters\n          });\n        } catch (err) {\n          layer.raiseError(err, `drawing ${layer} to ${pass}`);\n        }\n      }\n    }\n\n    return renderStatus;\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  /* Methods for subclass overrides */\n  protected shouldDrawLayer(layer: Layer): boolean {\n    return true;\n  }\n\n  protected getModuleParameters(layer: Layer, effects?: Effect[]): any {\n    return null;\n  }\n\n  protected getLayerParameters(layer: Layer, layerIndex: number, viewport: Viewport): any {\n    return layer.props.parameters;\n  }\n\n  /* Private */\n  private _shouldDrawLayer(\n    layer: Layer,\n    drawContext: FilterContext,\n    layerFilter: ((params: FilterContext) => boolean) | undefined,\n    layerFilterCache: Record<string, boolean>\n  ) {\n    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);\n\n    if (!shouldDrawLayer) {\n      return false;\n    }\n\n    drawContext.layer = layer;\n\n    let parent = layer.parent as Layer;\n    while (parent) {\n      // @ts-ignore\n      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {\n        return false;\n      }\n      drawContext.layer = parent;\n      parent = parent.parent as Layer;\n    }\n\n    if (layerFilter) {\n      const rootLayerId = drawContext.layer.id;\n      if (!(rootLayerId in layerFilterCache)) {\n        layerFilterCache[rootLayerId] = layerFilter(drawContext);\n      }\n      if (!layerFilterCache[rootLayerId]) {\n        return false;\n      }\n    }\n\n    // If a layer is drawn, update its viewportChanged flag\n    layer.activateViewport(drawContext.viewport);\n\n    return true;\n  }\n\n  private _getModuleParameters(\n    layer: Layer,\n    effects: Effect[] | undefined,\n    pass: string,\n    overrides: any\n  ): any {\n    const moduleParameters = Object.assign(\n      Object.create(layer.internalState?.propsInTransition || layer.props),\n      {\n        autoWrapLongitude: layer.wrapLongitude,\n        // @ts-ignore\n        viewport: layer.context.viewport,\n        // @ts-ignore\n        mousePosition: layer.context.mousePosition,\n        pickingActive: 0,\n        devicePixelRatio: cssToDeviceRatio(this.gl)\n      }\n    );\n\n    if (effects) {\n      for (const effect of effects) {\n        Object.assign(moduleParameters, effect.getModuleParameters?.(layer));\n      }\n    }\n\n    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);\n  }\n}\n\n// If the _index prop is defined, return a layer index that's relative to its parent\n// Otherwise return the index of the layer among all rendered layers\n// This is done recursively, i.e. if the user overrides a layer's default index,\n// all its descendants will be resolved relative to that index.\n// This implementation assumes that parent layers always appear before its children\n// which is true if the layer array comes from the LayerManager\nexport function layerIndexResolver(\n  startIndex: number = 0,\n  layerIndices: Record<string, number> = {}\n): (layer: Layer, isDrawn: boolean) => number {\n  const resolvers = {};\n\n  const resolveLayerIndex = (layer, isDrawn) => {\n    const indexOverride = layer.props._offset;\n    const layerId = layer.id;\n    const parentId = layer.parent && layer.parent.id;\n\n    let index;\n\n    if (parentId && !(parentId in layerIndices)) {\n      // Populate layerIndices with the parent layer's index\n      resolveLayerIndex(layer.parent, false);\n    }\n\n    if (parentId in resolvers) {\n      const resolver = (resolvers[parentId] =\n        resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices));\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      // Mark layer as needing its own resolver\n      // We don't actually create it until it's used for the first time\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n\n    layerIndices[layerId] = index;\n    return index;\n  };\n  return resolveLayerIndex;\n}\n\n// Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\nfunction getGLViewport(\n  gl,\n  {\n    moduleParameters,\n    target,\n    viewport\n  }: {\n    moduleParameters: any;\n    target?: Framebuffer;\n    viewport: Viewport;\n  }\n): [number, number, number, number] {\n  const useTarget = target && target.id !== 'default-framebuffer';\n  const pixelRatio =\n    (moduleParameters && moduleParameters.devicePixelRatio) || cssToDeviceRatio(gl);\n\n  // Default framebuffer is used when writing to canvas\n  const height = useTarget ? target.height : gl.drawingBufferHeight;\n\n  // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\n  const dimensions = viewport;\n  return [\n    dimensions.x * pixelRatio,\n    height - (dimensions.y + dimensions.height) * pixelRatio,\n    dimensions.width * pixelRatio,\n    dimensions.height * pixelRatio\n  ];\n}\n\nfunction clearGLCanvas(gl: WebGLRenderingContext) {\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  // clear depth and color buffers, restoring transparency\n  setParameters(gl, {viewport: [0, 0, width, height]});\n  gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n}\n"]},"metadata":{},"sourceType":"module"}