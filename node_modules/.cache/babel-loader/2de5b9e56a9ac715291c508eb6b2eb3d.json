{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Buffer, Transform } from '@luma.gl/core';\nimport Attribute from '../lib/attribute/attribute';\nimport { padBuffer, getAttributeTypeFromSize, getSourceBufferAttribute, getAttributeBufferLength, cycleBuffers } from '../lib/attribute/attribute-transition-utils';\nimport Transition from './transition';\nexport default class GPUInterpolationTransition {\n  constructor({\n    gl,\n    attribute,\n    timeline\n  }) {\n    _defineProperty(this, \"gl\", void 0);\n\n    _defineProperty(this, \"type\", 'interpolation');\n\n    _defineProperty(this, \"attributeInTransition\", void 0);\n\n    _defineProperty(this, \"settings\", void 0);\n\n    _defineProperty(this, \"attribute\", void 0);\n\n    _defineProperty(this, \"transition\", void 0);\n\n    _defineProperty(this, \"currentStartIndices\", void 0);\n\n    _defineProperty(this, \"currentLength\", void 0);\n\n    _defineProperty(this, \"transform\", void 0);\n\n    _defineProperty(this, \"buffers\", void 0);\n\n    this.gl = gl;\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    this.attributeInTransition = new Attribute(gl, attribute.settings);\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = 0;\n    this.transform = getTransform(gl, attribute);\n    const bufferOpts = {\n      byteLength: 0,\n      usage: 35050\n    };\n    this.buffers = [new Buffer(gl, bufferOpts), new Buffer(gl, bufferOpts)];\n  }\n\n  get inProgress() {\n    return this.transition.inProgress;\n  }\n\n  start(transitionSettings, numInstances) {\n    if (transitionSettings.duration <= 0) {\n      this.transition.cancel();\n      return;\n    }\n\n    this.settings = transitionSettings;\n    const {\n      gl,\n      buffers,\n      attribute\n    } = this;\n    cycleBuffers(buffers);\n    const padBufferOpts = {\n      numInstances,\n      attribute,\n      fromLength: this.currentLength,\n      fromStartIndices: this.currentStartIndices,\n      getData: transitionSettings.enter\n    };\n\n    for (const buffer of buffers) {\n      padBuffer({\n        buffer,\n        ...padBufferOpts\n      });\n    }\n\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = getAttributeBufferLength(attribute, numInstances);\n    this.attributeInTransition.setData({\n      buffer: buffers[1],\n      value: attribute.value\n    });\n    this.transition.start(transitionSettings);\n    this.transform.update({\n      elementCount: Math.floor(this.currentLength / attribute.size),\n      sourceBuffers: {\n        aFrom: buffers[0],\n        aTo: getSourceBufferAttribute(gl, attribute)\n      },\n      feedbackBuffers: {\n        vCurrent: buffers[1]\n      }\n    });\n  }\n\n  update() {\n    const updated = this.transition.update();\n\n    if (updated) {\n      const {\n        duration,\n        easing\n      } = this.settings;\n      const {\n        time\n      } = this.transition;\n      let t = time / duration;\n\n      if (easing) {\n        t = easing(t);\n      }\n\n      this.transform.run({\n        uniforms: {\n          time: t\n        }\n      });\n    }\n\n    return updated;\n  }\n\n  cancel() {\n    this.transition.cancel();\n    this.transform.delete();\n\n    for (const buffer of this.buffers) {\n      buffer.delete();\n    }\n\n    this.buffers.length = 0;\n  }\n\n}\nconst vs = \"\\n#define SHADER_NAME interpolation-transition-vertex-shader\\n\\nuniform float time;\\nattribute ATTRIBUTE_TYPE aFrom;\\nattribute ATTRIBUTE_TYPE aTo;\\nvarying ATTRIBUTE_TYPE vCurrent;\\n\\nvoid main(void) {\\n  vCurrent = mix(aFrom, aTo, time);\\n  gl_Position = vec4(0.0);\\n}\\n\";\n\nfunction getTransform(gl, attribute) {\n  const attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    vs,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent']\n  });\n}","map":{"version":3,"sources":["../../../src/transitions/gpu-interpolation-transition.ts"],"names":["constructor","timeline","attribute","getTransform","bufferOpts","byteLength","usage","inProgress","start","transitionSettings","cycleBuffers","padBufferOpts","fromLength","fromStartIndices","getData","enter","padBuffer","getAttributeBufferLength","buffer","buffers","value","elementCount","Math","sourceBuffers","aFrom","aTo","getSourceBufferAttribute","feedbackBuffers","vCurrent","update","updated","easing","time","t","uniforms","cancel","vs","attributeType","getAttributeTypeFromSize","defines","ATTRIBUTE_TYPE","varyings"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {Buffer, Transform} from '@luma.gl/core';\nimport Attribute from '../lib/attribute/attribute';\nimport {\n  padBuffer,\n  getAttributeTypeFromSize,\n  getSourceBufferAttribute,\n  getAttributeBufferLength,\n  cycleBuffers,\n  InterpolationTransitionSettings\n} from '../lib/attribute/attribute-transition-utils';\nimport Transition from './transition';\n\nimport type {Timeline, Transform as LumaTransform} from '@luma.gl/engine';\nimport type {Buffer as LumaBuffer} from '@luma.gl/webgl';\nimport type {NumericArray} from '../types/types';\nimport type GPUTransition from './gpu-transition';\n\nexport default class GPUInterpolationTransition implements GPUTransition {\n  gl: WebGLRenderingContext;\n  type = 'interpolation';\n  attributeInTransition: Attribute;\n\n  private settings?: InterpolationTransitionSettings;\n  private attribute: Attribute;\n  private transition: Transition;\n  private currentStartIndices: NumericArray | null;\n  private currentLength: number;\n  private transform: LumaTransform;\n  private buffers: LumaBuffer[];\n\n  constructor({\n    gl,\n    attribute,\n    timeline\n  }: {\n    gl: WebGLRenderingContext;\n    attribute: Attribute;\n    timeline: Timeline;\n  }) {\n    this.gl = gl;\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    // this is the attribute we return during the transition - note: if it is a constant\n    // attribute, it will be converted and returned as a regular attribute\n    // `attribute.userData` is the original options passed when constructing the attribute.\n    // This ensures that we set the proper `doublePrecision` flag and shader attributes.\n    this.attributeInTransition = new Attribute(gl, attribute.settings);\n    this.currentStartIndices = attribute.startIndices;\n    // storing currentLength because this.buffer may be larger than the actual length we want to use\n    // this is because we only reallocate buffers when they grow, not when they shrink,\n    // due to performance costs\n    this.currentLength = 0;\n    this.transform = getTransform(gl, attribute);\n    const bufferOpts = {\n      byteLength: 0,\n      usage: GL.DYNAMIC_COPY\n    };\n    this.buffers = [\n      new Buffer(gl, bufferOpts), // from\n      new Buffer(gl, bufferOpts) // current\n    ];\n  }\n\n  get inProgress(): boolean {\n    return this.transition.inProgress;\n  }\n\n  // this is called when an attribute's values have changed and\n  // we need to start animating towards the new values\n  // this also correctly resizes / pads the transform's buffers\n  // in case the attribute's buffer has changed in length or in\n  // startIndices\n  start(transitionSettings: InterpolationTransitionSettings, numInstances: number): void {\n    if (transitionSettings.duration <= 0) {\n      this.transition.cancel();\n      return;\n    }\n    this.settings = transitionSettings;\n\n    const {gl, buffers, attribute} = this;\n    // Alternate between two buffers when new transitions start.\n    // Last destination buffer is used as an attribute (from state),\n    // And the other buffer is now the current buffer.\n    cycleBuffers(buffers);\n\n    const padBufferOpts = {\n      numInstances,\n      attribute,\n      fromLength: this.currentLength,\n      fromStartIndices: this.currentStartIndices,\n      getData: transitionSettings.enter\n    };\n\n    for (const buffer of buffers) {\n      padBuffer({buffer, ...padBufferOpts});\n    }\n\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = getAttributeBufferLength(attribute, numInstances);\n    this.attributeInTransition.setData({\n      buffer: buffers[1],\n      // Hack: Float64Array is required for double-precision attributes\n      // to generate correct shader attributes\n      value: attribute.value as NumericArray\n    });\n\n    this.transition.start(transitionSettings);\n\n    this.transform.update({\n      elementCount: Math.floor(this.currentLength / attribute.size),\n      sourceBuffers: {\n        aFrom: buffers[0],\n        aTo: getSourceBufferAttribute(gl, attribute)\n      },\n      feedbackBuffers: {\n        vCurrent: buffers[1]\n      }\n    });\n  }\n\n  update(): boolean {\n    const updated = this.transition.update();\n    if (updated) {\n      const {duration, easing} = this.settings as InterpolationTransitionSettings;\n      const {time} = this.transition;\n      let t = time / duration;\n      if (easing) {\n        t = easing(t);\n      }\n      this.transform.run({\n        uniforms: {time: t}\n      });\n    }\n    return updated;\n  }\n\n  cancel(): void {\n    this.transition.cancel();\n    this.transform.delete();\n    for (const buffer of this.buffers) {\n      buffer.delete();\n    }\n    this.buffers.length = 0;\n  }\n}\n\nconst vs = `\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n`;\n\nfunction getTransform(gl: WebGLRenderingContext, attribute: Attribute): LumaTransform {\n  const attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    vs,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent']\n  });\n}\n"]},"metadata":{},"sourceType":"module"}