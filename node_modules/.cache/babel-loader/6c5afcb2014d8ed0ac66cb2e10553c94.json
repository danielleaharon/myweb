{"ast":null,"code":"import { createTexture, destroyTexture } from '../utils/texture';\nimport { deepEqual } from '../utils/deep-equal';\nconst TYPE_DEFINITIONS = {\n  boolean: {\n    validate(value, propType) {\n      return true;\n    },\n\n    equal(value1, value2, propType) {\n      return Boolean(value1) === Boolean(value2);\n    }\n\n  },\n  number: {\n    validate(value, propType) {\n      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);\n    }\n\n  },\n  color: {\n    validate(value, propType) {\n      return propType.optional && !value || isArray(value) && (value.length === 3 || value.length === 4);\n    },\n\n    equal(value1, value2, propType) {\n      return arrayEqual(value1, value2);\n    }\n\n  },\n  accessor: {\n    validate(value, propType) {\n      const valueType = getTypeOf(value);\n      return valueType === 'function' || valueType === getTypeOf(propType.value);\n    },\n\n    equal(value1, value2, propType) {\n      if (typeof value2 === 'function') {\n        return true;\n      }\n\n      return arrayEqual(value1, value2);\n    }\n\n  },\n  array: {\n    validate(value, propType) {\n      return propType.optional && !value || isArray(value);\n    },\n\n    equal(value1, value2, propType) {\n      return propType.compare ? arrayEqual(value1, value2) : value1 === value2;\n    }\n\n  },\n  object: {\n    equal(value1, value2, propType) {\n      return propType.compare ? deepEqual(value1, value2) : value1 === value2;\n    }\n\n  },\n  function: {\n    validate(value, propType) {\n      return propType.optional && !value || typeof value === 'function';\n    },\n\n    equal(value1, value2, propType) {\n      return !propType.compare || value1 === value2;\n    }\n\n  },\n  data: {\n    transform: (value, propType, component) => {\n      const {\n        dataTransform\n      } = component.props;\n      return dataTransform && value ? dataTransform(value) : value;\n    }\n  },\n  image: {\n    transform: (value, propType, component) => {\n      return createTexture(component, value);\n    },\n    release: value => {\n      destroyTexture(value);\n    }\n  }\n};\n\nfunction arrayEqual(array1, array2) {\n  if (array1 === array2) {\n    return true;\n  }\n\n  if (!isArray(array1) || !isArray(array2)) {\n    return false;\n  }\n\n  const len = array1.length;\n\n  if (len !== array2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < len; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  const defaultProps = {};\n  const deprecatedProps = {};\n\n  for (const [propName, propDef] of Object.entries(propDefs)) {\n    const deprecated = propDef === null || propDef === void 0 ? void 0 : propDef.deprecatedFor;\n\n    if (deprecated) {\n      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];\n    } else {\n      const propType = parsePropType(propName, propDef);\n      propTypes[propName] = propType;\n      defaultProps[propName] = propType.value;\n    }\n  }\n\n  return {\n    propTypes,\n    defaultProps,\n    deprecatedProps\n  };\n}\n\nfunction parsePropType(name, propDef) {\n  switch (getTypeOf(propDef)) {\n    case 'object':\n      return normalizePropDefinition(name, propDef);\n\n    case 'array':\n      return normalizePropDefinition(name, {\n        type: 'array',\n        value: propDef,\n        compare: false\n      });\n\n    case 'boolean':\n      return normalizePropDefinition(name, {\n        type: 'boolean',\n        value: propDef\n      });\n\n    case 'number':\n      return normalizePropDefinition(name, {\n        type: 'number',\n        value: propDef\n      });\n\n    case 'function':\n      return normalizePropDefinition(name, {\n        type: 'function',\n        value: propDef,\n        compare: true\n      });\n\n    default:\n      return {\n        name,\n        type: 'unknown',\n        value: propDef\n      };\n  }\n}\n\nfunction normalizePropDefinition(name, propDef) {\n  if (!('type' in propDef)) {\n    if (!('value' in propDef)) {\n      return {\n        name,\n        type: 'object',\n        value: propDef\n      };\n    }\n\n    return {\n      name,\n      type: getTypeOf(propDef.value),\n      ...propDef\n    };\n  }\n\n  return {\n    name,\n    ...TYPE_DEFINITIONS[propDef.type],\n    ...propDef\n  };\n}\n\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n\nfunction getTypeOf(value) {\n  if (isArray(value)) {\n    return 'array';\n  }\n\n  if (value === null) {\n    return 'null';\n  }\n\n  return typeof value;\n}","map":{"version":3,"sources":["../../../src/lifecycle/prop-types.ts"],"names":["TYPE_DEFINITIONS","boolean","validate","equal","Boolean","number","Number","value","propType","color","isArray","arrayEqual","accessor","valueType","getTypeOf","array","value1","object","deepEqual","function","data","transform","dataTransform","component","image","createTexture","release","destroyTexture","array1","len","array2","i","propTypes","defaultProps","deprecatedProps","Object","deprecated","propDef","Array","parsePropType","normalizePropDefinition","type","compare","ArrayBuffer"],"mappings":"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","sourcesContent":["import {createTexture, destroyTexture} from '../utils/texture';\nimport {deepEqual} from '../utils/deep-equal';\n\nimport type Component from './component';\nimport type {Color, Texture} from '../types/layer-props';\n\ntype BasePropType<ValueT> = {\n  value: ValueT;\n  async?: boolean;\n  validate?: (value: any, propType: PropType) => boolean;\n  equal?: (value1: ValueT, value2: ValueT, propType: PropType) => boolean;\n};\n\n/**\n * Normalized prop type definition\n */\nexport type PropType = BasePropType<any> & {\n  type: string;\n  name: string;\n  transform?: (value: any, propType: PropType, component: Component<any>) => any;\n  release?: (value: any, propType: PropType, component: Component<any>) => void;\n};\n\ntype DefaultProp<T> =\n  | T\n  | DeprecatedProp\n  | BooleanPropType\n  | NumberPropType\n  | ColorPropType\n  | ImagePropType\n  | DataPropType<T>\n  | ArrayPropType<T>\n  | ObjectPropType<T>\n  | AccessorPropType<T>\n  | FunctionPropType<T>;\n\nexport type DefaultProps<T extends Record<string, any>> = {\n  [propName in keyof T]?: DefaultProp<Required<T>[propName]>;\n};\n\ntype BooleanPropType = BasePropType<boolean> & {\n  type: 'boolean';\n};\ntype NumberPropType = BasePropType<number> & {\n  type: 'number';\n  min?: number;\n  max?: number;\n};\ntype ColorPropType = BasePropType<Color | null> & {\n  type: 'color';\n  optional?: boolean;\n};\ntype ArrayPropType<T = any[]> = BasePropType<T> & {\n  type: 'array';\n  optional?: boolean;\n  compare?: boolean;\n};\ntype AccessorPropType<T = any> = BasePropType<T> & {\n  type: 'accessor';\n};\ntype FunctionPropType<T = Function> = BasePropType<T> & {\n  type: 'function';\n  optional?: boolean;\n  compare?: boolean;\n};\ntype DataPropType<T = any> = BasePropType<T> & {\n  type: 'data';\n};\ntype ImagePropType = BasePropType<Texture | null> & {\n  type: 'image';\n};\ntype ObjectPropType<T = any> = BasePropType<T> & {\n  type: 'object';\n  optional?: boolean;\n  compare?: boolean;\n};\ntype DeprecatedProp = {\n  deprecatedFor?: string | string[];\n};\ntype PropTypeDef =\n  | DeprecatedProp\n  | boolean\n  | BooleanPropType\n  | number\n  | NumberPropType\n  | string\n  | DataPropType\n  | number[]\n  | ColorPropType\n  | ArrayPropType\n  | AccessorPropType\n  | FunctionPropType\n  | ImagePropType\n  | ObjectPropType\n  | null;\n\nconst TYPE_DEFINITIONS = {\n  boolean: {\n    validate(value, propType: BooleanPropType) {\n      return true;\n    },\n    equal(value1, value2, propType: BooleanPropType) {\n      return Boolean(value1) === Boolean(value2);\n    }\n  },\n  number: {\n    validate(value, propType: NumberPropType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max!) &&\n        (!('min' in propType) || value >= propType.min!)\n      );\n    }\n  },\n  color: {\n    validate(value, propType: ColorPropType) {\n      return (\n        (propType.optional && !value) ||\n        (isArray(value) && (value.length === 3 || value.length === 4))\n      );\n    },\n    equal(value1, value2, propType: ColorPropType) {\n      return arrayEqual(value1, value2);\n    }\n  },\n  accessor: {\n    validate(value, propType: AccessorPropType) {\n      const valueType = getTypeOf(value);\n      return valueType === 'function' || valueType === getTypeOf(propType.value);\n    },\n    equal(value1, value2, propType: AccessorPropType) {\n      if (typeof value2 === 'function') {\n        return true;\n      }\n      return arrayEqual(value1, value2);\n    }\n  },\n  array: {\n    validate(value, propType: ArrayPropType) {\n      return (propType.optional && !value) || isArray(value);\n    },\n    equal(value1, value2, propType: ArrayPropType) {\n      return propType.compare ? arrayEqual(value1, value2) : value1 === value2;\n    }\n  },\n  object: {\n    equal(value1, value2, propType: ObjectPropType) {\n      return propType.compare ? deepEqual(value1, value2) : value1 === value2;\n    }\n  },\n  function: {\n    validate(value, propType: FunctionPropType) {\n      return (propType.optional && !value) || typeof value === 'function';\n    },\n    equal(value1, value2, propType: FunctionPropType) {\n      return !propType.compare || value1 === value2;\n    }\n  },\n  data: {\n    transform: (value, propType: DataPropType, component) => {\n      const {dataTransform} = component.props;\n      return dataTransform && value ? dataTransform(value) : value;\n    }\n  },\n  image: {\n    transform: (value, propType: ImagePropType, component) => {\n      return createTexture(component, value);\n    },\n    release: value => {\n      destroyTexture(value);\n    }\n  }\n} as const;\n\nfunction arrayEqual(array1, array2) {\n  if (array1 === array2) {\n    return true;\n  }\n  if (!isArray(array1) || !isArray(array2)) {\n    return false;\n  }\n  const len = array1.length;\n  if (len !== array2.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function parsePropTypes(propDefs: Record<string, PropTypeDef>): {\n  propTypes: Record<string, PropType>;\n  defaultProps: Record<string, any>;\n  deprecatedProps: Record<string, string[]>;\n} {\n  const propTypes = {};\n  const defaultProps = {};\n  const deprecatedProps = {};\n\n  for (const [propName, propDef] of Object.entries(propDefs)) {\n    const deprecated = (propDef as DeprecatedProp)?.deprecatedFor;\n    if (deprecated) {\n      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];\n    } else {\n      const propType = parsePropType(propName, propDef);\n      propTypes[propName] = propType;\n      defaultProps[propName] = propType.value;\n    }\n  }\n  return {propTypes, defaultProps, deprecatedProps};\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(name: string, propDef: PropTypeDef): PropType {\n  switch (getTypeOf(propDef)) {\n    case 'object':\n      return normalizePropDefinition(name, propDef);\n\n    case 'array':\n      return normalizePropDefinition(name, {type: 'array', value: propDef, compare: false});\n\n    case 'boolean':\n      return normalizePropDefinition(name, {type: 'boolean', value: propDef});\n\n    case 'number':\n      return normalizePropDefinition(name, {type: 'number', value: propDef});\n\n    case 'function':\n      // return guessFunctionType(name, propDef);\n      return normalizePropDefinition(name, {type: 'function', value: propDef, compare: true});\n\n    default:\n      return {name, type: 'unknown', value: propDef};\n  }\n}\n\nfunction normalizePropDefinition(name, propDef): PropType {\n  if (!('type' in propDef)) {\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {name, type: 'object', value: propDef};\n    }\n    return {name, type: getTypeOf(propDef.value), ...propDef};\n  }\n  return {name, ...TYPE_DEFINITIONS[propDef.type], ...propDef};\n}\n\nfunction isArray(value: any): boolean {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value: any): string {\n  if (isArray(value)) {\n    return 'array';\n  }\n  if (value === null) {\n    return 'null';\n  }\n  return typeof value;\n}\n"]},"metadata":{},"sourceType":"module"}