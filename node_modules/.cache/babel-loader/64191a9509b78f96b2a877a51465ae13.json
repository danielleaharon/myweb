{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\n\nimport Constants from '../constants';\nimport { getBlocks, isRotation } from './Piece';\nvar GAME_HEIGHT = Constants.GAME_HEIGHT,\n    GAME_WIDTH = Constants.GAME_WIDTH;\n\nvar serializeCoords = function (_a) {\n  var x = _a.x,\n      y = _a.y;\n  return \"\".concat(x, \",\").concat(y);\n};\n\nexport function buildMatrix() {\n  var matrix = new Array(GAME_HEIGHT);\n\n  for (var y = 0; y < matrix.length; y++) {\n    matrix[y] = buildGameRow();\n  }\n\n  return matrix;\n}\n\nfunction buildGameRow() {\n  return new Array(GAME_WIDTH).fill(null);\n}\n\nexport var addPieceToBoard = function (matrix, positionedPiece, isGhost) {\n  if (isGhost === void 0) {\n    isGhost = false;\n  }\n\n  var piece = positionedPiece.piece,\n      rotation = positionedPiece.rotation,\n      position = positionedPiece.position;\n  var block = getBlocks(piece)[rotation];\n\n  if (!block) {\n    throw new Error(\"Unexpected: no rotation \".concat(rotation, \" found to piece \").concat(piece));\n  }\n\n  var filledCells = block.reduce(function (output, row, y) {\n    return output.concat(row.map(function (cell, x) {\n      return cell ? {\n        x: x + position.x,\n        y: y + position.y\n      } : false;\n    }));\n  }, []);\n  var filled = new Set(filledCells.map(function (value) {\n    return value ? serializeCoords(value) : '';\n  }).filter(Boolean));\n  var value = isGhost ? 'ghost' : piece;\n  return matrix.map(function (row, y) {\n    return row.map(function (cell, x) {\n      return filled.has(serializeCoords({\n        x: x,\n        y: y\n      })) ? value : cell;\n    });\n  });\n};\nexport function setPiece(matrix, positionedPiece) {\n  var _matrix = addPieceToBoard(matrix, positionedPiece); // TODO: purify\n\n\n  var linesCleared = clearFullLines(_matrix);\n  return [_matrix, linesCleared];\n}\n\nfunction clearFullLines(matrix) {\n  var linesCleared = 0;\n\n  for (var y = 0; y < matrix.length; y++) {\n    // it's a full line\n    if (every(matrix[y])) {\n      // so rip it out\n      matrix.splice(y, 1);\n      matrix.unshift(buildGameRow());\n      linesCleared += 1;\n    }\n  }\n\n  return linesCleared;\n}\n\nfunction every(list) {\n  for (var i = 0; i < list.length; i++) {\n    if (!list[i]) return false;\n  }\n\n  return true;\n}\n\nexport function isEmptyPosition(matrix, positionedPiece) {\n  var piece = positionedPiece.piece,\n      rotation = positionedPiece.rotation,\n      position = positionedPiece.position;\n  var blocks = getBlocks(piece)[rotation];\n\n  for (var x = 0; x < Constants.BLOCK_WIDTH; x++) {\n    for (var y = 0; y < Constants.BLOCK_HEIGHT; y++) {\n      var block = blocks[y][x];\n      var matrixX = x + position.x;\n      var matrixY = y + position.y; // might not be filled, ya know\n\n      if (block) {\n        // make sure it's on the matrix\n        if (matrixX >= 0 && matrixX < GAME_WIDTH && matrixY < GAME_HEIGHT) {\n          // make sure it's available\n          if (!matrix[matrixY] || matrix[matrixY][matrixX]) {\n            // that square is taken by the matrix already\n            return false;\n          }\n        } else {\n          // there's a square in the block that's off the matrix\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction assert(value) {\n  if (!value) throw new Error('assertion failed');\n}\n\nfunction tryMove(move) {\n  return function (gameboard, positionedPiece) {\n    var updatedPiece = move(positionedPiece);\n\n    if (isEmptyPosition(gameboard, updatedPiece)) {\n      return updatedPiece;\n    }\n\n    return undefined;\n  };\n}\n\nexport var moveLeft = tryMove(function (positionedPiece) {\n  var newPosition = __assign(__assign({}, positionedPiece.position), {\n    x: positionedPiece.position.x - 1\n  });\n\n  return __assign(__assign({}, positionedPiece), {\n    position: newPosition\n  });\n});\nexport var moveRight = tryMove(function (positionedPiece) {\n  var newPosition = __assign(__assign({}, positionedPiece.position), {\n    x: positionedPiece.position.x + 1\n  });\n\n  return __assign(__assign({}, positionedPiece), {\n    position: newPosition\n  });\n});\nexport var moveDown = tryMove(function (positionedPiece) {\n  var newPosition = __assign(__assign({}, positionedPiece.position), {\n    y: positionedPiece.position.y + 1\n  });\n\n  return __assign(__assign({}, positionedPiece), {\n    position: newPosition\n  });\n});\nexport var flipClockwise = tryMove(function (positionedPiece) {\n  var _a;\n\n  var rotation = (((_a = positionedPiece.rotation) !== null && _a !== void 0 ? _a : 0) + 1) % Constants.ROTATION_COUNT;\n  assert(isRotation(rotation));\n  return __assign(__assign({}, positionedPiece), {\n    rotation: rotation\n  });\n});\nexport var flipCounterclockwise = tryMove(function (positionedPiece) {\n  var _a;\n\n  var rotation = ((_a = positionedPiece.rotation) !== null && _a !== void 0 ? _a : 0) - 1;\n  if (rotation < 0) rotation += Constants.ROTATION_COUNT;\n  assert(isRotation(rotation));\n  return __assign(__assign({}, positionedPiece), {\n    rotation: rotation\n  });\n});\nexport function hardDrop(gameboard, positionedPiece) {\n  var position = __assign({}, positionedPiece.position);\n\n  while (isEmptyPosition(gameboard, __assign(__assign({}, positionedPiece), {\n    position: position\n  }))) {\n    position.y += 1;\n  } // at this point, we just found a non-empty position, so let's step back\n\n\n  position.y -= 1;\n  return __assign(__assign({}, positionedPiece), {\n    position: position\n  });\n}","map":{"version":3,"sources":["/Users/user/Desktop/עבודות להגשה/myweb/node_modules/react-tetris/lib/models/Matrix.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","Constants","getBlocks","isRotation","GAME_HEIGHT","GAME_WIDTH","serializeCoords","_a","x","y","concat","buildMatrix","matrix","Array","buildGameRow","fill","addPieceToBoard","positionedPiece","isGhost","piece","rotation","position","block","Error","filledCells","reduce","output","row","map","cell","filled","Set","value","filter","Boolean","has","setPiece","_matrix","linesCleared","clearFullLines","every","splice","unshift","list","isEmptyPosition","blocks","BLOCK_WIDTH","BLOCK_HEIGHT","matrixX","matrixY","assert","tryMove","move","gameboard","updatedPiece","undefined","moveLeft","newPosition","moveRight","moveDown","flipClockwise","ROTATION_COUNT","flipCounterclockwise","hardDrop"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport Constants from '../constants';\nimport { getBlocks, isRotation } from './Piece';\nvar GAME_HEIGHT = Constants.GAME_HEIGHT, GAME_WIDTH = Constants.GAME_WIDTH;\nvar serializeCoords = function (_a) {\n    var x = _a.x, y = _a.y;\n    return \"\".concat(x, \",\").concat(y);\n};\nexport function buildMatrix() {\n    var matrix = new Array(GAME_HEIGHT);\n    for (var y = 0; y < matrix.length; y++) {\n        matrix[y] = buildGameRow();\n    }\n    return matrix;\n}\nfunction buildGameRow() {\n    return new Array(GAME_WIDTH).fill(null);\n}\nexport var addPieceToBoard = function (matrix, positionedPiece, isGhost) {\n    if (isGhost === void 0) { isGhost = false; }\n    var piece = positionedPiece.piece, rotation = positionedPiece.rotation, position = positionedPiece.position;\n    var block = getBlocks(piece)[rotation];\n    if (!block) {\n        throw new Error(\"Unexpected: no rotation \".concat(rotation, \" found to piece \").concat(piece));\n    }\n    var filledCells = block.reduce(function (output, row, y) {\n        return output.concat(row.map(function (cell, x) {\n            return cell ? { x: x + position.x, y: y + position.y } : false;\n        }));\n    }, []);\n    var filled = new Set(filledCells\n        .map(function (value) { return (value ? serializeCoords(value) : ''); })\n        .filter(Boolean));\n    var value = isGhost ? 'ghost' : piece;\n    return matrix.map(function (row, y) {\n        return row.map(function (cell, x) {\n            return filled.has(serializeCoords({ x: x, y: y })) ? value : cell;\n        });\n    });\n};\nexport function setPiece(matrix, positionedPiece) {\n    var _matrix = addPieceToBoard(matrix, positionedPiece);\n    // TODO: purify\n    var linesCleared = clearFullLines(_matrix);\n    return [_matrix, linesCleared];\n}\nfunction clearFullLines(matrix) {\n    var linesCleared = 0;\n    for (var y = 0; y < matrix.length; y++) {\n        // it's a full line\n        if (every(matrix[y])) {\n            // so rip it out\n            matrix.splice(y, 1);\n            matrix.unshift(buildGameRow());\n            linesCleared += 1;\n        }\n    }\n    return linesCleared;\n}\nfunction every(list) {\n    for (var i = 0; i < list.length; i++) {\n        if (!list[i])\n            return false;\n    }\n    return true;\n}\nexport function isEmptyPosition(matrix, positionedPiece) {\n    var piece = positionedPiece.piece, rotation = positionedPiece.rotation, position = positionedPiece.position;\n    var blocks = getBlocks(piece)[rotation];\n    for (var x = 0; x < Constants.BLOCK_WIDTH; x++) {\n        for (var y = 0; y < Constants.BLOCK_HEIGHT; y++) {\n            var block = blocks[y][x];\n            var matrixX = x + position.x;\n            var matrixY = y + position.y;\n            // might not be filled, ya know\n            if (block) {\n                // make sure it's on the matrix\n                if (matrixX >= 0 && matrixX < GAME_WIDTH && matrixY < GAME_HEIGHT) {\n                    // make sure it's available\n                    if (!matrix[matrixY] || matrix[matrixY][matrixX]) {\n                        // that square is taken by the matrix already\n                        return false;\n                    }\n                }\n                else {\n                    // there's a square in the block that's off the matrix\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\nfunction assert(value) {\n    if (!value)\n        throw new Error('assertion failed');\n}\nfunction tryMove(move) {\n    return function (gameboard, positionedPiece) {\n        var updatedPiece = move(positionedPiece);\n        if (isEmptyPosition(gameboard, updatedPiece)) {\n            return updatedPiece;\n        }\n        return undefined;\n    };\n}\nexport var moveLeft = tryMove(function (positionedPiece) {\n    var newPosition = __assign(__assign({}, positionedPiece.position), { x: positionedPiece.position.x - 1 });\n    return __assign(__assign({}, positionedPiece), { position: newPosition });\n});\nexport var moveRight = tryMove(function (positionedPiece) {\n    var newPosition = __assign(__assign({}, positionedPiece.position), { x: positionedPiece.position.x + 1 });\n    return __assign(__assign({}, positionedPiece), { position: newPosition });\n});\nexport var moveDown = tryMove(function (positionedPiece) {\n    var newPosition = __assign(__assign({}, positionedPiece.position), { y: positionedPiece.position.y + 1 });\n    return __assign(__assign({}, positionedPiece), { position: newPosition });\n});\nexport var flipClockwise = tryMove(function (positionedPiece) {\n    var _a;\n    var rotation = (((_a = positionedPiece.rotation) !== null && _a !== void 0 ? _a : 0) + 1) % Constants.ROTATION_COUNT;\n    assert(isRotation(rotation));\n    return __assign(__assign({}, positionedPiece), { rotation: rotation });\n});\nexport var flipCounterclockwise = tryMove(function (positionedPiece) {\n    var _a;\n    var rotation = ((_a = positionedPiece.rotation) !== null && _a !== void 0 ? _a : 0) - 1;\n    if (rotation < 0)\n        rotation += Constants.ROTATION_COUNT;\n    assert(isRotation(rotation));\n    return __assign(__assign({}, positionedPiece), { rotation: rotation });\n});\nexport function hardDrop(gameboard, positionedPiece) {\n    var position = __assign({}, positionedPiece.position);\n    while (isEmptyPosition(gameboard, __assign(__assign({}, positionedPiece), { position: position }))) {\n        position.y += 1;\n    }\n    // at this point, we just found a non-empty position, so let's step back\n    position.y -= 1;\n    return __assign(__assign({}, positionedPiece), { position: position });\n}\n"]},"metadata":{},"sourceType":"module"}