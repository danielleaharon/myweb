{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Texture2D } from '@luma.gl/core';\nimport { equals } from '@math.gl/core';\nimport MaskPass from '../../passes/mask-pass';\nimport { OPERATION } from '../../lib/constants';\nimport { getMaskBounds, getMaskViewport } from './utils';\nimport log from '../../utils/log';\nexport default class MaskEffect {\n  constructor() {\n    _defineProperty(this, \"id\", 'mask-effect');\n\n    _defineProperty(this, \"props\", null);\n\n    _defineProperty(this, \"useInPicking\", true);\n\n    _defineProperty(this, \"dummyMaskMap\", void 0);\n\n    _defineProperty(this, \"channels\", []);\n\n    _defineProperty(this, \"masks\", null);\n\n    _defineProperty(this, \"maskPass\", void 0);\n\n    _defineProperty(this, \"maskMap\", void 0);\n\n    _defineProperty(this, \"lastViewport\", void 0);\n  }\n\n  preRender(gl, {\n    layers,\n    layerFilter,\n    viewports,\n    onViewportActive,\n    views\n  }) {\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation === OPERATION.MASK);\n\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return;\n    }\n\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {\n        id: 'default-mask'\n      });\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    const channelMap = this._sortMaskChannels(maskLayers);\n\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    for (const maskId in channelMap) {\n      this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n  }\n\n  _renderChannel(channelInfo, {\n    layerFilter,\n    onViewportActive,\n    views,\n    viewport,\n    viewportChanged\n  }) {\n    const oldChannelInfo = this.channels[channelInfo.index];\n\n    if (!oldChannelInfo) {\n      return;\n    }\n\n    const maskChanged = channelInfo === oldChannelInfo || oldChannelInfo.layers.length !== channelInfo.layers.length || channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      this.lastViewport = viewport;\n      channelInfo.bounds = getMaskBounds({\n        layers: channelInfo.layers,\n        viewport\n      });\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        const {\n          maskPass,\n          maskMap\n        } = this;\n        const maskViewport = getMaskViewport({\n          bounds: channelInfo.bounds,\n          viewport,\n          width: maskMap.width,\n          height: maskMap.height\n        });\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n      }\n    }\n\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n  }\n\n  _sortMaskChannels(maskLayers) {\n    const channelMap = {};\n    let channelCount = 0;\n\n    for (const layer of maskLayers) {\n      const {\n        id\n      } = layer.root;\n      let channelInfo = channelMap[id];\n\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue;\n        }\n\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => (c === null || c === void 0 ? void 0 : c.id) === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n\n    return channelMap;\n  }\n\n  getModuleParameters() {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup() {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/effects/mask/mask-effect.ts"],"names":["preRender","views","width","height","maskLayers","layers","l","OPERATION","id","channelMap","viewport","viewports","viewportChanged","_renderChannel","oldChannelInfo","channelInfo","maskChanged","b","getMaskBounds","equals","maskMap","maskViewport","getMaskViewport","bounds","maskPass","pass","channel","moduleParameters","devicePixelRatio","index","coordinateOrigin","coordinateSystem","_sortMaskChannels","channelCount","layer","log","c","layerBounds","i","getModuleParameters","maskChannels","masks","cleanup"],"mappings":"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","sourcesContent":["import {Texture2D} from '@luma.gl/core';\n// import {readPixelsToArray} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport MaskPass from '../../passes/mask-pass';\nimport {OPERATION} from '../../lib/constants';\nimport {getMaskBounds, getMaskViewport} from './utils';\nimport log from '../../utils/log';\n\nimport type {Effect, PreRenderOptions} from '../../lib/effect';\nimport type Layer from '../../lib/layer';\nimport type Viewport from '../../viewports/viewport';\nimport type {MaskBounds} from './utils';\nimport type {CoordinateSystem} from '../../lib/constants';\n\ntype Mask = {\n  /** The channel index */\n  index: number;\n  bounds: MaskBounds;\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\ntype Channel = {\n  id: string;\n  index: number;\n  layers: Layer[];\n  bounds: MaskBounds;\n  maskBounds: MaskBounds;\n  layerBounds: MaskBounds[];\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\n// Class to manage mask effect\nexport default class MaskEffect implements Effect {\n  id = 'mask-effect';\n  props = null;\n  useInPicking = true;\n\n  private dummyMaskMap?: Texture2D;\n  private channels: (Channel | null)[] = [];\n  private masks: Record<string, Mask> | null = null;\n  private maskPass?: MaskPass;\n  private maskMap?: Texture2D;\n  private lastViewport?: Viewport;\n\n  preRender(\n    gl: WebGLRenderingContext,\n    {layers, layerFilter, viewports, onViewportActive, views}: PreRenderOptions\n  ): void {\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation === OPERATION.MASK);\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return;\n    }\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {id: 'default-mask'});\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    for (const maskId in channelMap) {\n      this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n\n    // // Debug show FBO contents on screen\n    // const color = readPixelsToArray(this.maskMap);\n    // let canvas = document.getElementById('fbo-canvas');\n    // if (!canvas) {\n    //   canvas = document.createElement('canvas');\n    //   canvas.id = 'fbo-canvas';\n    //   canvas.width = this.maskMap.width;\n    //   canvas.height = this.maskMap.height;\n    //   canvas.style.zIndex = 100;\n    //   canvas.style.position = 'absolute';\n    //   canvas.style.right = 0;\n    //   canvas.style.border = 'blue 1px solid';\n    //   canvas.style.width = '256px';\n    //   canvas.style.transform = 'scaleY(-1)';\n    //   document.body.appendChild(canvas);\n    // }\n    // const ctx = canvas.getContext('2d');\n    // const imageData = ctx.createImageData(this.maskMap.width, this.maskMap.height);\n    // for (let i = 0; i < color.length; i += 4) {\n    //   imageData.data[i + 0] = color[i + 0];\n    //   imageData.data[i + 1] = color[i + 1];\n    //   imageData.data[i + 2] = color[i + 2];\n    //   imageData.data[i + 3] = color[i + 3] + 128;\n    // }\n    // ctx.putImageData(imageData, 0, 0);\n  }\n\n  private _renderChannel(\n    channelInfo: Channel,\n    {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ) {\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return;\n    }\n\n    const maskChanged =\n      // If a channel is new\n      channelInfo === oldChannelInfo ||\n      // If sublayers have changed\n      oldChannelInfo.layers.length !== channelInfo.layers.length ||\n      // If a sublayer's positions have been updated, the cached bounds will change shallowly\n      channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n\n      channelInfo.bounds = getMaskBounds({layers: channelInfo.layers, viewport});\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {maskPass, maskMap} = this;\n\n        const maskViewport = getMaskViewport({\n          bounds: channelInfo.bounds,\n          viewport,\n          width: maskMap.width,\n          height: maskMap.height\n        });\n\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n      }\n    }\n\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n  }\n\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  private _sortMaskChannels(maskLayers: Layer[]): Record<string, Channel> {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {id} = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n\n  getModuleParameters(): {\n    maskMap: Texture2D;\n    maskChannels: Record<string, Mask> | null;\n  } {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}