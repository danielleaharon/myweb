{"ast":null,"code":"import typedArrayManager from './typed-array-manager';\nimport { Vector3 } from '@math.gl/core';\nexport function createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nexport function mod(value, divisor) {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nexport function getCameraPosition(viewMatrixInverse) {\n  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];\n}\nexport function getFrustumPlanes(viewProjectionMatrix) {\n  return {\n    left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),\n    right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),\n    bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),\n    top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),\n    near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),\n    far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])\n  };\n}\nconst scratchVector = new Vector3();\n\nfunction getFrustumPlane(a, b, c, d) {\n  scratchVector.set(a, b, c);\n  const L = scratchVector.len();\n  return {\n    distance: d / L,\n    normal: new Vector3(-a / L, -b / L, -c / L)\n  };\n}\n\nexport function fp64LowPart(x) {\n  return x - Math.fround(x);\n}\nlet scratchArray;\nexport function toDoublePrecisionArray(typedArray, options) {\n  const {\n    size = 1,\n    startIndex = 0\n  } = options;\n  const endIndex = options.endIndex !== undefined ? options.endIndex : typedArray.length;\n  const count = (endIndex - startIndex) / size;\n  scratchArray = typedArrayManager.allocate(scratchArray, count, {\n    type: Float32Array,\n    size: size * 2\n  });\n  let sourceIndex = startIndex;\n  let targetIndex = 0;\n\n  while (sourceIndex < endIndex) {\n    for (let j = 0; j < size; j++) {\n      const value = typedArray[sourceIndex++];\n      scratchArray[targetIndex + j] = value;\n      scratchArray[targetIndex + j + size] = fp64LowPart(value);\n    }\n\n    targetIndex += size * 2;\n  }\n\n  return scratchArray.subarray(0, count * size * 2);\n}","map":{"version":3,"sources":["../../../src/utils/math-utils.ts"],"names":["modulus","value","divisor","viewMatrixInverse","left","getFrustumPlane","viewProjectionMatrix","right","bottom","top","near","far","scratchVector","L","distance","d","normal","x","Math","size","startIndex","endIndex","options","typedArray","count","scratchArray","type","sourceIndex","targetIndex","j","fp64LowPart"],"mappings":"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","sourcesContent":["// Extensions to math.gl library. Intended to be folded back.\nimport typedArrayManager from './typed-array-manager';\nimport {Vector3, NumericArray} from '@math.gl/core';\n\nimport type {Matrix4} from '@math.gl/core';\n\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\nexport function createMat4(): number[] {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\nexport function mod(value: number, divisor: number): number {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\n\n// Extract camera vectors (move to math library?)\nexport function getCameraPosition(\n  viewMatrixInverse: Matrix4 | NumericArray\n): [number, number, number] {\n  // Read the translation from the inverse view matrix\n  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];\n}\n\nexport type FrustumPlane = {\n  distance: number;\n  normal: Vector3;\n};\n\n// https://www.gamedevs.org/uploads/fast-extraction-viewing-frustum-planes-from-world-view-projection-matrix.pdf\nexport function getFrustumPlanes(viewProjectionMatrix: Matrix4 | NumericArray): {\n  left: FrustumPlane;\n  right: FrustumPlane;\n  top: FrustumPlane;\n  bottom: FrustumPlane;\n  near: FrustumPlane;\n  far: FrustumPlane;\n} {\n  return {\n    left: getFrustumPlane(\n      viewProjectionMatrix[3] + viewProjectionMatrix[0],\n      viewProjectionMatrix[7] + viewProjectionMatrix[4],\n      viewProjectionMatrix[11] + viewProjectionMatrix[8],\n      viewProjectionMatrix[15] + viewProjectionMatrix[12]\n    ),\n    right: getFrustumPlane(\n      viewProjectionMatrix[3] - viewProjectionMatrix[0],\n      viewProjectionMatrix[7] - viewProjectionMatrix[4],\n      viewProjectionMatrix[11] - viewProjectionMatrix[8],\n      viewProjectionMatrix[15] - viewProjectionMatrix[12]\n    ),\n    bottom: getFrustumPlane(\n      viewProjectionMatrix[3] + viewProjectionMatrix[1],\n      viewProjectionMatrix[7] + viewProjectionMatrix[5],\n      viewProjectionMatrix[11] + viewProjectionMatrix[9],\n      viewProjectionMatrix[15] + viewProjectionMatrix[13]\n    ),\n    top: getFrustumPlane(\n      viewProjectionMatrix[3] - viewProjectionMatrix[1],\n      viewProjectionMatrix[7] - viewProjectionMatrix[5],\n      viewProjectionMatrix[11] - viewProjectionMatrix[9],\n      viewProjectionMatrix[15] - viewProjectionMatrix[13]\n    ),\n    near: getFrustumPlane(\n      viewProjectionMatrix[3] + viewProjectionMatrix[2],\n      viewProjectionMatrix[7] + viewProjectionMatrix[6],\n      viewProjectionMatrix[11] + viewProjectionMatrix[10],\n      viewProjectionMatrix[15] + viewProjectionMatrix[14]\n    ),\n    far: getFrustumPlane(\n      viewProjectionMatrix[3] - viewProjectionMatrix[2],\n      viewProjectionMatrix[7] - viewProjectionMatrix[6],\n      viewProjectionMatrix[11] - viewProjectionMatrix[10],\n      viewProjectionMatrix[15] - viewProjectionMatrix[14]\n    )\n  };\n}\n\nconst scratchVector = new Vector3();\n\nfunction getFrustumPlane(a: number, b: number, c: number, d: number): FrustumPlane {\n  scratchVector.set(a, b, c);\n  const L = scratchVector.len();\n  return {distance: d / L, normal: new Vector3(-a / L, -b / L, -c / L)};\n}\n\n/**\n * Calculate the low part of a WebGL 64 bit float\n * @param x {number} - the input float number\n * @returns {number} - the lower 32 bit of the number\n */\nexport function fp64LowPart(x: number): number {\n  return x - Math.fround(x);\n}\n\nlet scratchArray;\n\n/**\n * Split a Float64Array into a double-length Float32Array\n * @param typedArray\n * @param options\n * @param options.size  - per attribute size\n * @param options.startIndex - start index in the source array\n * @param options.endIndex  - end index in the source array\n * @returns {} - high part, low part for each attribute:\n    [1xHi, 1yHi, 1zHi, 1xLow, 1yLow, 1zLow, 2xHi, ...]\n */\nexport function toDoublePrecisionArray(\n  typedArray: Float64Array,\n  options: {size?: number; startIndex?: number; endIndex?: number}\n): Float32Array {\n  const {size = 1, startIndex = 0} = options;\n\n  const endIndex = options.endIndex !== undefined ? options.endIndex : typedArray.length;\n\n  const count = (endIndex - startIndex) / size;\n  scratchArray = typedArrayManager.allocate(scratchArray, count, {\n    type: Float32Array,\n    size: size * 2\n  });\n\n  let sourceIndex = startIndex;\n  let targetIndex = 0;\n  while (sourceIndex < endIndex) {\n    for (let j = 0; j < size; j++) {\n      const value = typedArray[sourceIndex++];\n      scratchArray[targetIndex + j] = value;\n      scratchArray[targetIndex + j + size] = fp64LowPart(value);\n    }\n    targetIndex += size * 2;\n  }\n\n  return scratchArray.subarray(0, count * size * 2);\n}\n"]},"metadata":{},"sourceType":"module"}