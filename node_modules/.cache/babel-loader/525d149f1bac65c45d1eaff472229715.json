{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Layer, project32, picking, log, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport vs from './icon-layer-vertex.glsl';\nimport fs from './icon-layer-fragment.glsl';\nimport IconManager from './icon-manager';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  iconAtlas: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  iconMapping: {\n    type: 'object',\n    value: {},\n    async: true\n  },\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  sizeMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  alphaCutoff: {\n    type: 'number',\n    value: 0.05,\n    min: 0,\n    max: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getIcon: {\n    type: 'accessor',\n    value: x => x.icon\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 1\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  onIconError: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  }\n};\nexport default class IconLayer extends Layer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking]\n    });\n  }\n\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.gl, {\n        onUpdate: this._onUpdate.bind(this),\n        onError: this._onError.bind(this)\n      })\n    };\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIcon',\n        transform: this.getInstanceOffset\n      },\n      instanceIconFrames: {\n        size: 4,\n        accessor: 'getIcon',\n        transform: this.getInstanceIconFrame\n      },\n      instanceColorModes: {\n        size: 1,\n        type: 5121,\n        accessor: 'getIcon',\n        transform: this.getInstanceColorMode\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      }\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const attributeManager = this.getAttributeManager();\n    const {\n      iconAtlas,\n      iconMapping,\n      data,\n      getIcon,\n      textureParameters\n    } = props;\n    const {\n      iconManager\n    } = this.state;\n    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');\n    iconManager.setProps({\n      loadOptions: props.loadOptions,\n      autoPacking: !prePacked,\n      iconAtlas,\n      iconMapping: prePacked ? iconMapping : null,\n      textureParameters\n    });\n\n    if (prePacked) {\n      if (oldProps.iconMapping !== props.iconMapping) {\n        attributeManager.invalidate('getIcon');\n      }\n    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {\n      iconManager.packIcons(data, getIcon);\n    }\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n  }\n\n  get isLoaded() {\n    return super.isLoaded && this.state.iconManager.isLoaded;\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.iconManager.finalize();\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      sizeScale,\n      sizeMinPixels,\n      sizeMaxPixels,\n      sizeUnits,\n      billboard,\n      alphaCutoff\n    } = this.props;\n    const {\n      iconManager\n    } = this.state;\n    const iconsTexture = iconManager.getTexture();\n\n    if (iconsTexture) {\n      this.state.model.setUniforms(uniforms).setUniforms({\n        iconsTexture,\n        iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n        sizeUnits: UNIT[sizeUnits],\n        sizeScale,\n        sizeMinPixels,\n        sizeMaxPixels,\n        billboard,\n        alphaCutoff\n      }).draw();\n    }\n  }\n\n  _getModel(gl) {\n    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 6,\n        attributes: {\n          positions: {\n            size: 2,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _onUpdate() {\n    this.setNeedsRedraw();\n  }\n\n  _onError(evt) {\n    var _this$getCurrentLayer;\n\n    const onIconError = (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.props.onIconError;\n\n    if (onIconError) {\n      onIconError(evt);\n    } else {\n      log.error(evt.error.message)();\n    }\n  }\n\n  getInstanceOffset(icon) {\n    const {\n      width,\n      height,\n      anchorX = width / 2,\n      anchorY = height / 2\n    } = this.state.iconManager.getIconMapping(icon);\n    return [width / 2 - anchorX, height / 2 - anchorY];\n  }\n\n  getInstanceColorMode(icon) {\n    const mapping = this.state.iconManager.getIconMapping(icon);\n    return mapping.mask ? 1 : 0;\n  }\n\n  getInstanceIconFrame(icon) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.state.iconManager.getIconMapping(icon);\n    return [x, y, width, height];\n  }\n\n}\n\n_defineProperty(IconLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(IconLayer, \"layerName\", 'IconLayer');","map":{"version":3,"sources":["../../../src/icon-layer/icon-layer.ts"],"names":["DEFAULT_COLOR","defaultProps","iconAtlas","type","value","async","iconMapping","sizeScale","min","billboard","sizeUnits","sizeMinPixels","sizeMaxPixels","Number","MAX_SAFE_INTEGER","alphaCutoff","max","getPosition","x","position","getIcon","icon","getColor","getSize","getAngle","getPixelOffset","onIconError","compare","optional","IconLayer","getShaders","modules","initializeState","iconManager","onUpdate","onError","attributeManager","instancePositions","size","fp64","transition","accessor","instanceSizes","defaultValue","instanceOffsets","transform","getInstanceOffset","instanceIconFrames","getInstanceIconFrame","instanceColorModes","getInstanceColorMode","instanceColors","normalized","instanceAngles","instancePixelOffset","updateState","changeFlags","textureParameters","prePacked","loadOptions","props","autoPacking","oldProps","gl","isLoaded","finalizeState","draw","uniforms","iconsTexture","iconsTextureDim","UNIT","_getModel","positions","id","geometry","drawMode","attributes","isInstanced","_onUpdate","_onError","log","evt","anchorX","width","anchorY","height","mapping"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {Layer, project32, picking, log, UNIT} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport vs from './icon-layer-vertex.glsl';\nimport fs from './icon-layer-fragment.glsl';\nimport IconManager from './icon-manager';\n\nimport type {\n  LayerProps,\n  Accessor,\n  AccessorFunction,\n  Position,\n  Color,\n  Texture,\n  Unit,\n  UpdateParameters,\n  LayerContext,\n  DefaultProps\n} from '@deck.gl/core';\nimport type {UnpackedIcon, IconMapping, LoadIconErrorContext} from './icon-manager';\n\ntype _IconLayerProps<DataT> = {\n  /** A prepacked image that contains all icons. */\n  iconAtlas?: string | Texture;\n  /** Icon names mapped to icon definitions, or a URL to load such mapping from a JSON file. */\n  iconMapping?: string | IconMapping;\n\n  /** Icon size multiplier.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * The units of the icon size, one of `meters`, `common`, and `pixels`.\n   *\n   * @default 'pixels'\n   */\n  sizeUnits?: Unit;\n  /**\n   * The minimum size in pixels. When using non-pixel `sizeUnits`, this prop can be used to prevent the icon from getting too small when zoomed out.\n   */\n  sizeMinPixels?: number;\n  /**\n   * The maximum size in pixels. When using non-pixel `sizeUnits`, this prop can be used to prevent the icon from getting too big when zoomed in.\n   */\n  sizeMaxPixels?: number;\n  /** If `true`, the icon always faces camera. Otherwise the icon faces up (z)\n   * @default true\n   */\n  billboard?: boolean;\n  /**\n   * Discard pixels whose opacity is below this threshold.\n   * A discarded pixel would create a \"hole\" in the icon that is not considered part of the object.\n   * @default 0.05\n   */\n  alphaCutoff?: number;\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Icon definition accessor.\n   * Should return the icon id if using pre-packed icons (`iconAtlas` + `iconMapping`).\n   * Return an object that defines the icon if using auto-packing.\n   */\n  getIcon?: AccessorFunction<DataT, string> | AccessorFunction<DataT, UnpackedIcon>;\n  /** Icon color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /** Icon size accessor.\n   * @default 1\n   */\n  getSize?: Accessor<DataT, number>;\n  /** Icon rotation accessor, in degrees.\n   * @default 0\n   */\n  getAngle?: Accessor<DataT, number>;\n  /**\n   * Icon offsest accessor, in pixels.\n   * @default [0, 0]\n   */\n  getPixelOffset?: Accessor<DataT, [number, number]>;\n  /**\n   * Callback called if the attempt to fetch an icon returned by `getIcon` fails.\n   */\n  onIconError?: ((context: LoadIconErrorContext) => void) | null;\n\n  /** Customize the [texture parameters](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter). */\n  textureParameters?: Record<number, number> | null;\n};\n\nexport type IconLayerProps<DataT = any> = _IconLayerProps<DataT> & LayerProps<DataT>;\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\nconst defaultProps: DefaultProps<IconLayerProps> = {\n  iconAtlas: {type: 'image', value: null, async: true},\n  iconMapping: {type: 'object', value: {}, async: true},\n  sizeScale: {type: 'number', value: 1, min: 0},\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {type: 'number', min: 0, value: 0}, //  min point radius in pixels\n  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER}, // max point radius in pixels\n  alphaCutoff: {type: 'number', value: 0.05, min: 0, max: 1},\n\n  getPosition: {type: 'accessor', value: x => x.position},\n  getIcon: {type: 'accessor', value: x => x.icon},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getSize: {type: 'accessor', value: 1},\n  getAngle: {type: 'accessor', value: 0},\n  getPixelOffset: {type: 'accessor', value: [0, 0]},\n\n  onIconError: {type: 'function', value: null, compare: false, optional: true}\n};\n\n/** Render raster icons at given coordinates. */\nexport default class IconLayer<DataT = any, ExtraPropsT = {}> extends Layer<\n  ExtraPropsT & Required<_IconLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'IconLayer';\n\n  state!: {\n    model?: Model;\n    iconManager: IconManager;\n  };\n\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.gl, {\n        onUpdate: this._onUpdate.bind(this),\n        onError: this._onError.bind(this)\n      })\n    };\n\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager!.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIcon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        transform: this.getInstanceOffset\n      },\n      instanceIconFrames: {\n        size: 4,\n        accessor: 'getIcon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        transform: this.getInstanceIconFrame\n      },\n      instanceColorModes: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        accessor: 'getIcon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        transform: this.getInstanceColorMode\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  /* eslint-disable max-statements, complexity */\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n    const {props, oldProps, changeFlags} = params;\n\n    const attributeManager = this.getAttributeManager();\n    const {iconAtlas, iconMapping, data, getIcon, textureParameters} = props;\n    const {iconManager} = this.state;\n\n    // internalState is always defined during updateState\n    const prePacked = iconAtlas || this.internalState!.isAsyncPropLoading('iconAtlas');\n    iconManager.setProps({\n      loadOptions: props.loadOptions,\n      autoPacking: !prePacked,\n      iconAtlas,\n      iconMapping: prePacked ? (iconMapping as IconMapping) : null,\n      textureParameters\n    });\n\n    // prepacked iconAtlas from user\n    if (prePacked) {\n      if (oldProps.iconMapping !== props.iconMapping) {\n        attributeManager!.invalidate('getIcon');\n      }\n    } else if (\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon))\n    ) {\n      // Auto packing - getIcon is expected to return an object\n      iconManager.packIcons(data, getIcon as AccessorFunction<any, UnpackedIcon>);\n    }\n\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      this.state.model?.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager!.invalidateAll();\n    }\n  }\n  /* eslint-enable max-statements, complexity */\n\n  get isLoaded(): boolean {\n    return super.isLoaded && this.state.iconManager.isLoaded;\n  }\n\n  finalizeState(context: LayerContext): void {\n    super.finalizeState(context);\n    // Release resources held by the icon manager\n    this.state.iconManager.finalize();\n  }\n\n  draw({uniforms}): void {\n    const {sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff} = this.props;\n    const {iconManager} = this.state;\n\n    const iconsTexture = iconManager.getTexture();\n    if (iconsTexture) {\n      this.state.model\n        .setUniforms(uniforms)\n        .setUniforms({\n          iconsTexture,\n          iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n          sizeUnits: UNIT[sizeUnits],\n          sizeScale,\n          sizeMinPixels,\n          sizeMaxPixels,\n          billboard,\n          alphaCutoff\n        })\n        .draw();\n    }\n  }\n\n  protected _getModel(gl: WebGLRenderingContext): Model {\n    // The icon-layer vertex shader uses 2d positions\n    // specifed via: attribute vec2 positions;\n    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        attributes: {\n          // The size must be explicitly passed here otherwise luma.gl\n          // will default to assuming that positions are 3D (x,y,z)\n          positions: {\n            size: 2,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  private _onUpdate(): void {\n    this.setNeedsRedraw();\n  }\n\n  private _onError(evt: LoadIconErrorContext): void {\n    const onIconError = this.getCurrentLayer()?.props.onIconError;\n    if (onIconError) {\n      onIconError(evt);\n    } else {\n      log.error(evt.error.message)();\n    }\n  }\n\n  protected getInstanceOffset(icon: string): number[] {\n    const {\n      width,\n      height,\n      anchorX = width / 2,\n      anchorY = height / 2\n    } = this.state.iconManager.getIconMapping(icon);\n    return [width / 2 - anchorX, height / 2 - anchorY];\n  }\n\n  protected getInstanceColorMode(icon: string): number {\n    const mapping = this.state.iconManager.getIconMapping(icon);\n    return mapping.mask ? 1 : 0;\n  }\n\n  protected getInstanceIconFrame(icon: string): number[] {\n    const {x, y, width, height} = this.state.iconManager.getIconMapping(icon);\n    return [x, y, width, height];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}