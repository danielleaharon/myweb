{"ast":null,"code":"import { cutPolylineByGrid, cutPolylineByMercatorBounds } from '@math.gl/polygon';\nexport function normalizePath(path, size, gridResolution, wrapLongitude) {\n  let flatPath;\n\n  if (Array.isArray(path[0])) {\n    const length = path.length * size;\n    flatPath = new Array(length);\n\n    for (let i = 0; i < path.length; i++) {\n      for (let j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  } else {\n    flatPath = path;\n  }\n\n  if (gridResolution) {\n    return cutPolylineByGrid(flatPath, {\n      size,\n      gridResolution\n    });\n  }\n\n  if (wrapLongitude) {\n    return cutPolylineByMercatorBounds(flatPath, {\n      size\n    });\n  }\n\n  return flatPath;\n}","map":{"version":3,"sources":["../../../src/path-layer/path.ts"],"names":["Array","path","length","flatPath","i","j","cutPolylineByGrid","gridResolution","cutPolylineByMercatorBounds","size"],"mappings":"AAAA,SAAA,iBAAA,EAAA,2BAAA,QAAA,kBAAA;AAeA,OAAO,SAAA,aAAA,CAAA,IAAA,EAAA,IAAA,EAAA,cAAA,EAAA,aAAA,EAKsB;AAC3B,MAAA,QAAA;;AACA,MAAIA,KAAK,CAALA,OAAAA,CAAcC,IAAI,CAAtB,CAAsB,CAAlBD,CAAJ,EAA4B;AAC1B,UAAME,MAAM,GAAGD,IAAI,CAAJA,MAAAA,GAAf,IAAA;AACAE,IAAAA,QAAQ,GAAG,IAAA,KAAA,CAAXA,MAAW,CAAXA;;AACA,SAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGH,IAAI,CAAxB,MAAA,EAAiCG,CAAjC,EAAA,EAAsC;AACpC,WAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,IAAA,EAA0BA,CAA1B,EAAA,EAA+B;AAC7BF,QAAAA,QAAQ,CAACC,CAAC,GAADA,IAAAA,GAATD,CAAQ,CAARA,GAAyBF,IAAI,CAAJA,CAAI,CAAJA,CAAAA,CAAAA,KAAzBE,CAAAA;AACD;AACF;AAPH,GAAA,MAQO;AACLA,IAAAA,QAAQ,GAARA,IAAAA;AACD;;AACD,MAAA,cAAA,EAAoB;AAClB,WAAOG,iBAAiB,CAAA,QAAA,EAAW;AAAA,MAAA,IAAA;AAAOC,MAAAA;AAAP,KAAX,CAAxB;AACD;;AACD,MAAA,aAAA,EAAmB;AACjB,WAAOC,2BAA2B,CAAA,QAAA,EAAW;AAACC,MAAAA;AAAD,KAAX,CAAlC;AACD;;AACD,SAAA,QAAA;AACD","sourcesContent":["import {cutPolylineByGrid, cutPolylineByMercatorBounds} from '@math.gl/polygon';\n\nimport type {NumericArray} from '@math.gl/core';\nimport type {Position} from '@deck.gl/core';\n\nexport type NestedPathGeometry = Position[];\nexport type FlatPathGeometry = NumericArray;\nexport type PathGeometry = NestedPathGeometry | FlatPathGeometry;\nexport type NormalizedPathGeometry = FlatPathGeometry[] | FlatPathGeometry;\n\n/**\n * Flattens a nested path object\n * Cut the feature if needed (globe projection, wrap longitude, etc.)\n * Returns a flat array of path positions, or a list of flat arrays representing multiple paths\n */\nexport function normalizePath(\n  path: PathGeometry,\n  size: number,\n  gridResolution?: number,\n  wrapLongitude?: boolean\n): number[][] | NumericArray {\n  let flatPath: NumericArray;\n  if (Array.isArray(path[0])) {\n    const length = path.length * size;\n    flatPath = new Array(length);\n    for (let i = 0; i < path.length; i++) {\n      for (let j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  } else {\n    flatPath = path as NumericArray;\n  }\n  if (gridResolution) {\n    return cutPolylineByGrid(flatPath, {size, gridResolution});\n  }\n  if (wrapLongitude) {\n    return cutPolylineByMercatorBounds(flatPath, {size});\n  }\n  return flatPath;\n}\n"]},"metadata":{},"sourceType":"module"}