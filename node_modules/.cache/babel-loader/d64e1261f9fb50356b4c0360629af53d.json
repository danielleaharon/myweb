{"ast":null,"code":"export var STAGE_WIDTH=12;export var STAGE_HEIGHT=25;export var createStage=function createStage(){return Array.from(Array(STAGE_HEIGHT),function(){return Array(STAGE_WIDTH).fill([0,'clear']);});};export var checkCollision=function checkCollision(player,stage,_ref){var moveX=_ref.x,moveY=_ref.y;// THIS IS SLOWER!!!\n// return player.tetromino.some((row, y) =>\n//   row.some((cell, x) => {\n//     if (cell !== 0) {\n//       return (\n//         !stage[y + player.pos.y + moveY] ||\n//         !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n//         stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !==\n//           'clear'\n//       );\n//     }\n//     return false;\n//   })\n// );\n// Using for loops to be able to return (and break). Not possible with forEach\nfor(var y=0;y<player.tetromino.length;y+=1){for(var x=0;x<player.tetromino[y].length;x+=1){// 1. Check that we're on an actual Tetromino cell\nif(player.tetromino[y][x]!==0){if(// 2. Check that our move is inside the game areas height (y)\n// That we're not go through bottom of the play area\n!stage[y+player.pos.y+moveY]||// 3. Check that our move is inside the game areas width (x)\n!stage[y+player.pos.y+moveY][x+player.pos.x+moveX]||// 4. Check that the cell wer'e moving to isn't set to clear\nstage[y+player.pos.y+moveY][x+player.pos.x+moveX][1]!=='clear'){return true;}}}}// 5. If everything above is false\nreturn false;};","map":{"version":3,"sources":["/Users/user/Desktop/עבודות להגשה/myweb/src/components/tetris/gameHelpers.js"],"names":["STAGE_WIDTH","STAGE_HEIGHT","createStage","Array","from","fill","checkCollision","player","stage","moveX","x","moveY","y","tetromino","length","pos"],"mappings":"AAAA,MAAO,IAAMA,CAAAA,WAAW,CAAG,EAApB,CACP,MAAO,IAAMC,CAAAA,YAAY,CAAG,EAArB,CAEP,MAAO,IAAMC,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,SACzBC,CAAAA,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACF,YAAD,CAAhB,CAAgC,iBAAME,CAAAA,KAAK,CAACH,WAAD,CAAL,CAAmBK,IAAnB,CAAwB,CAAC,CAAD,CAAI,OAAJ,CAAxB,CAAN,EAAhC,CADyB,EAApB,CAGP,MAAO,IAAMC,CAAAA,cAAc,CAAG,QAAjBA,CAAAA,cAAiB,CAACC,MAAD,CAASC,KAAT,MAA2C,IAAtBC,CAAAA,KAAsB,MAAzBC,CAAyB,CAAZC,KAAY,MAAfC,CAAe,CACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,IAAK,GAAIA,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGL,MAAM,CAACM,SAAP,CAAiBC,MAArC,CAA6CF,CAAC,EAAI,CAAlD,CAAqD,CACnD,IAAK,GAAIF,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGH,MAAM,CAACM,SAAP,CAAiBD,CAAjB,EAAoBE,MAAxC,CAAgDJ,CAAC,EAAI,CAArD,CAAwD,CACtD;AACA,GAAIH,MAAM,CAACM,SAAP,CAAiBD,CAAjB,EAAoBF,CAApB,IAA2B,CAA/B,CAAkC,CAChC,GACE;AACA;AACA,CAACF,KAAK,CAACI,CAAC,CAAGL,MAAM,CAACQ,GAAP,CAAWH,CAAf,CAAmBD,KAApB,CAAN,EACA;AACA,CAACH,KAAK,CAACI,CAAC,CAAGL,MAAM,CAACQ,GAAP,CAAWH,CAAf,CAAmBD,KAApB,CAAL,CAAgCD,CAAC,CAAGH,MAAM,CAACQ,GAAP,CAAWL,CAAf,CAAmBD,KAAnD,CAFD,EAGA;AACAD,KAAK,CAACI,CAAC,CAAGL,MAAM,CAACQ,GAAP,CAAWH,CAAf,CAAmBD,KAApB,CAAL,CAAgCD,CAAC,CAAGH,MAAM,CAACQ,GAAP,CAAWL,CAAf,CAAmBD,KAAnD,EAA0D,CAA1D,IACE,OARJ,CASE,CACA,MAAO,KAAP,CACD,CACF,CACF,CACF,CACD;AACA,MAAO,MAAP,CACD,CAtCM","sourcesContent":["export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 25;\n\nexport const createStage = () =>\n  Array.from(Array(STAGE_HEIGHT), () => Array(STAGE_WIDTH).fill([0, 'clear']));\n\nexport const checkCollision = (player, stage, { x: moveX, y: moveY }) => {\n  // THIS IS SLOWER!!!\n  // return player.tetromino.some((row, y) =>\n  //   row.some((cell, x) => {\n  //     if (cell !== 0) {\n  //       return (\n  //         !stage[y + player.pos.y + moveY] ||\n  //         !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n  //         stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !==\n  //           'clear'\n  //       );\n  //     }\n  //     return false;\n  //   })\n  // );\n\n  // Using for loops to be able to return (and break). Not possible with forEach\n  for (let y = 0; y < player.tetromino.length; y += 1) {\n    for (let x = 0; x < player.tetromino[y].length; x += 1) {\n      // 1. Check that we're on an actual Tetromino cell\n      if (player.tetromino[y][x] !== 0) {\n        if (\n          // 2. Check that our move is inside the game areas height (y)\n          // That we're not go through bottom of the play area\n          !stage[y + player.pos.y + moveY] ||\n          // 3. Check that our move is inside the game areas width (x)\n          !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n          // 4. Check that the cell wer'e moving to isn't set to clear\n          stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !==\n            'clear'\n        ) {\n          return true;\n        }\n      }\n    }\n  }\n  // 5. If everything above is false\n  return false;\n};"]},"metadata":{},"sourceType":"module"}