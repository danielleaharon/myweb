{"ast":null,"code":"export function binaryToFeatureForAccesor(data, index) {\n  if (!data) {\n    return null;\n  }\n\n  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;\n  const geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {\n  const feature = {\n    properties: { ...data.properties[propertiesIndex]\n    }\n  };\n\n  for (const prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\nexport function calculatePickingColors(geojsonBinary, encodePickingColor) {\n  const pickingColors = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n\n  for (const key in pickingColors) {\n    const featureIds = geojsonBinary[key].globalFeatureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    const pickingColor = [];\n\n    for (let i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key][i * 3 + 0] = pickingColor[0];\n      pickingColors[key][i * 3 + 1] = pickingColor[1];\n      pickingColors[key][i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}","map":{"version":3,"sources":["../../../src/geojson-layer/geojson-binary.ts"],"names":["featureIndex","data","geometryIndex","getPropertiesForIndex","feature","properties","pickingColors","points","lines","polygons","featureIds","geojsonBinary","pickingColor","i","encodePickingColor"],"mappings":"AAmBA,OAAO,SAAA,yBAAA,CAAA,IAAA,EAAA,KAAA,EAGwB;AAC7B,MAAI,CAAJ,IAAA,EAAW;AACT,WAAA,IAAA;AACD;;AAED,QAAMA,YAAY,GAAG,kBAAA,IAAA,GAA0BC,IAAD,CAAA,YAACA,CAA1B,KAA0BA,CAA1B,GAArB,KAAA;AACA,QAAMC,aAAa,GAAGD,IAAI,CAAJA,UAAAA,CAAAA,KAAAA,CAAtB,YAAsBA,CAAtB;;AAEA,MAAID,YAAY,KAAK,CAArB,CAAA,EAAyB;AACvB,WAAOG,qBAAqB,CAAA,IAAA,EAAA,aAAA,EAA5B,YAA4B,CAA5B;AACD;;AAED,SAAA,IAAA;AACD;;AAED,SAAA,qBAAA,CAAA,IAAA,EAAA,eAAA,EAAA,iBAAA,EAIwB;AACtB,QAAMC,OAAO,GAAG;AACdC,IAAAA,UAAU,EAAE,EAAC,GAAGJ,IAAI,CAAJA,UAAAA,CAAAA,eAAAA;AAAJ;AADE,GAAhB;;AAIA,OAAK,MAAL,IAAA,IAAmBA,IAAI,CAAvB,YAAA,EAAsC;AACpCG,IAAAA,OAAO,CAAPA,UAAAA,CAAAA,IAAAA,IAA2BH,IAAI,CAAJA,YAAAA,CAAAA,IAAAA,EAAAA,KAAAA,CAA3BG,iBAA2BH,CAA3BG;AACD;;AAED,SAAA,OAAA;AACD;;AAGD,OAAO,SAAA,sBAAA,CAAA,aAAA,EAAA,kBAAA,EAGqC;AAC1C,QAAME,aAAuD,GAAG;AAC9DC,IAAAA,MAAM,EADwD,IAAA;AAE9DC,IAAAA,KAAK,EAFyD,IAAA;AAG9DC,IAAAA,QAAQ,EAAE;AAHoD,GAAhE;;AAKA,OAAK,MAAL,GAAA,IAAA,aAAA,EAAiC;AAC/B,UAAMC,UAAU,GAAGC,aAAa,CAAbA,GAAa,CAAbA,CAAAA,gBAAAA,CAAnB,KAAA;AACAL,IAAAA,aAAa,CAAbA,GAAa,CAAbA,GAAqB,IAAA,iBAAA,CAAsBI,UAAU,CAAVA,MAAAA,GAA3CJ,CAAqB,CAArBA;AACA,UAAMM,YAAY,GAAlB,EAAA;;AACA,SAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGH,UAAU,CAA9B,MAAA,EAAuCG,CAAvC,EAAA,EAA4C;AAC1CC,MAAAA,kBAAkB,CAACJ,UAAU,CAAX,CAAW,CAAX,EAAlBI,YAAkB,CAAlBA;AACAR,MAAAA,aAAa,CAAbA,GAAa,CAAbA,CAAoBO,CAAC,GAADA,CAAAA,GAApBP,CAAAA,IAAiCM,YAAY,CAA7CN,CAA6C,CAA7CA;AACAA,MAAAA,aAAa,CAAbA,GAAa,CAAbA,CAAoBO,CAAC,GAADA,CAAAA,GAApBP,CAAAA,IAAiCM,YAAY,CAA7CN,CAA6C,CAA7CA;AACAA,MAAAA,aAAa,CAAbA,GAAa,CAAbA,CAAoBO,CAAC,GAADA,CAAAA,GAApBP,CAAAA,IAAiCM,YAAY,CAA7CN,CAA6C,CAA7CA;AACD;AACF;;AAED,SAAA,aAAA;AACD","sourcesContent":["// This module implement some utility functions to work with\n// the geojson-binary format defined at loaders.gl:\n// https://github.com/visgl/loaders.gl/blob/master/modules/gis/docs/api-reference/geojson-to-binary.md\n\nimport {\n  BinaryFeatures,\n  BinaryLineFeatures,\n  BinaryPointFeatures,\n  BinaryPolygonFeatures,\n  Feature\n} from '@loaders.gl/schema';\n\nexport type BinaryFeatureTypes = BinaryPointFeatures | BinaryLineFeatures | BinaryPolygonFeatures;\n\ntype FeaureOnlyProperties = Pick<Feature, 'properties'>;\n\n/**\n * Return the feature for an accesor\n */\nexport function binaryToFeatureForAccesor(\n  data: BinaryFeatureTypes,\n  index: number\n): FeaureOnlyProperties | null {\n  if (!data) {\n    return null;\n  }\n\n  const featureIndex = 'startIndices' in data ? (data as any).startIndices[index] : index;\n  const geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(\n  data: BinaryFeatureTypes,\n  propertiesIndex: number,\n  numericPropsIndex: number\n): FeaureOnlyProperties {\n  const feature = {\n    properties: {...data.properties[propertiesIndex]}\n  };\n\n  for (const prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\n// Custom picking color to keep binary indexes\nexport function calculatePickingColors(\n  geojsonBinary: BinaryFeatures,\n  encodePickingColor: (id: number, result: number[]) => void\n): Record<string, Uint8ClampedArray | null> {\n  const pickingColors: Record<string, Uint8ClampedArray | null> = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n  for (const key in pickingColors) {\n    const featureIds = geojsonBinary[key].globalFeatureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    const pickingColor = [];\n    for (let i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key]![i * 3 + 0] = pickingColor[0];\n      pickingColors[key]![i * 3 + 1] = pickingColor[1];\n      pickingColors[key]![i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}\n"]},"metadata":{},"sourceType":"module"}