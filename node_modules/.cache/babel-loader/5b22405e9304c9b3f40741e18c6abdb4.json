{"ast":null,"code":"import { lerp } from './math-utils';\nimport { scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat } from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n};\nexport default function flyToViewport(startProps, endProps, t, options) {\n  const {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0\n  } = getFlyToTransitionParams(startProps, endProps, options);\n\n  if (u1 < EPSILON) {\n    const viewport = {};\n\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n\n    return viewport;\n  }\n\n  const s = t * S;\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n  const scaleIncrement = 1 / w;\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n  const newCenter = worldToLngLat(newCenterWorld);\n  return {\n    longitude: newCenter[0],\n    latitude: newCenter[1],\n    zoom: newZoom\n  };\n}\nexport function getFlyToDuration(startProps, endProps, options) {\n  const opts = { ...DEFAULT_OPTS,\n    ...options\n  };\n  const {\n    screenSpeed,\n    speed,\n    maxDuration\n  } = opts;\n  const {\n    S,\n    rho\n  } = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration;\n\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2.sub([], endCenterXY, startCenterXY);\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta) * startScale;\n\n  const _u1 = Math.max(u1, EPSILON);\n\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n  return {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0,\n    r1\n  };\n}","map":{"version":3,"sources":["../../src/fly-to-viewport.ts"],"names":["EPSILON","VIEWPORT_TRANSITION_PROPS","DEFAULT_OPTS","curve","speed","r0","getFlyToTransitionParams","u1","viewport","startValue","startProps","endValue","endProps","lerp","s","t","w","Math","rho","u","w0","scaleIncrement","newZoom","startZoom","scaleToZoom","newCenterWorld","vec2","newCenter","worldToLngLat","longitude","latitude","zoom","opts","options","maxDuration","length","Number","duration","screenSpeed","Object","startCenter","startScale","zoomToScale","endZoom","endCenter","scale","startCenterXY","lngLatToWorld","endCenterXY","uDelta","w1","_u1","rho2","b0","b1","r1","S"],"mappings":"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","sourcesContent":["import {lerp} from './math-utils';\nimport {scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat} from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\n\nimport type {ViewportProps} from './normalize-viewport-props';\n\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'] as const;\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n  // screenSpeed and maxDuration are used only if specified\n};\n\nexport type FlytoTransitionOptions = {\n  curve?: number;\n  speed?: number;\n  screenSpeed?: number;\n  maxDuration?: number;\n};\n\n/**\n * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.\n * It implements “Smooth and efficient zooming and panning.” algorithm by\n * \"Jarke J. van Wijk and Wim A.A. Nuij\"\n */\nexport default function flyToViewport(\n  startProps: ViewportProps,\n  endProps: ViewportProps,\n  t: number,\n  options?: FlytoTransitionOptions\n): {\n  longitude: number;\n  latitude: number;\n  zoom: number;\n} {\n  // Equations from above paper are referred where needed.\n\n  const {startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0} = getFlyToTransitionParams(\n    startProps,\n    endProps,\n    options\n  );\n\n  // If change in center is too small, do linear interpolaiton.\n  if (u1 < EPSILON) {\n    const viewport = {};\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n    // @ts-expect-error properties are populated dynamically\n    return viewport;\n  }\n\n  const s = t * S;\n\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = (w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2)) / u1;\n\n  const scaleIncrement = 1 / w; // Using w method for scaling.\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n\n  const newCenter = worldToLngLat(newCenterWorld);\n  return {\n    longitude: newCenter[0],\n    latitude: newCenter[1],\n    zoom: newZoom\n  };\n}\n\n// returns transition duration in milliseconds\nexport function getFlyToDuration(\n  startProps: ViewportProps,\n  endProps: ViewportProps,\n  options?: FlytoTransitionOptions\n): number {\n  const opts = {...DEFAULT_OPTS, ...options};\n  const {screenSpeed, speed, maxDuration} = opts;\n  const {S, rho} = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration: number;\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\n// Private Methods\n\n// Calculate all parameters that are static for given startProps and endProps\nfunction getFlyToTransitionParams(\n  startProps: ViewportProps,\n  endProps: ViewportProps,\n  opts: FlytoTransitionOptions\n): {\n  startZoom: number;\n  startCenterXY: number[];\n  uDelta: number[];\n  w0: number;\n  u1: number;\n  S: number;\n  rho: number;\n  rho2: number;\n  r0: number;\n  r1: number;\n} {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2.sub([] as number[], endCenterXY, startCenterXY);\n\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta) * startScale;\n  // u0 is treated as '0' in Eq (9).\n\n  // If u1 is too small, will generate invalid number\n  const _u1 = Math.max(u1, EPSILON);\n\n  // Implement Equation (9) from above algorithm.\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n\n  return {startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0, r1};\n}\n"]},"metadata":{},"sourceType":"module"}