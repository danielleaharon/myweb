{"ast":null,"code":"import * as Polygon from './polygon';\nimport { Tesselator } from '@deck.gl/core';\nimport { cutPolygonByGrid, cutPolygonByMercatorBounds } from '@math.gl/polygon';\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {\n      fp64,\n      IndexType = Uint32Array\n    } = opts;\n    super({ ...opts,\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    });\n  }\n\n  get(attributeName) {\n    const {\n      attributes\n    } = this;\n\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n    const externalIndices = this.buffers.indices;\n\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n\n      return normalizedPolygon;\n    }\n\n    return polygon;\n  }\n\n  getGeometrySize(polygon) {\n    if (isCut(polygon)) {\n      let size = 0;\n\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n\n      return size;\n    }\n\n    return Polygon.getPositions(polygon).length / this.positionSize;\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n\n    return null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n\n      this._updatePositions(polygon, context);\n\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  _updateIndices(polygon, {\n    geometryIndex,\n    vertexStart: offset,\n    indexStart\n  }) {\n    const {\n      attributes,\n      indexStarts,\n      typedArrayManager\n    } = this;\n    let target = attributes.indices;\n\n    if (!target || !polygon) {\n      return;\n    }\n\n    let i = indexStart;\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  _updatePositions(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      attributes: {\n        positions\n      },\n      positionSize\n    } = this;\n\n    if (!positions || !polygon) {\n      return;\n    }\n\n    const polygonPositions = Polygon.getPositions(polygon);\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      positionSize\n    } = this;\n    const vertexValid = this.attributes.vertexValid;\n    const holeIndices = polygon && Polygon.getHoleIndices(polygon);\n\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n\n}\n\nfunction isCut(polygon) {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}","map":{"version":3,"sources":["../../../src/solid-polygon-layer/polygon-tesselator.ts"],"names":["constructor","IndexType","Uint32Array","attributes","positions","size","type","fp64","Float32Array","vertexValid","indices","get","attributeName","updateGeometry","externalIndices","normalizeGeometry","normalizedPolygon","Polygon","cutPolygonByGrid","gridResolution","edgeTypes","cutPolygonByMercatorBounds","maxLatitude","getGeometrySize","isCut","getGeometryFromBuffer","updateGeometryAttributes","polygon","geometrySize","context","_updateIndices","vertexStart","indexStart","typedArrayManager","target","i","copy","j","indexStarts","geometryIndex","_updatePositions","positionSize","polygonPositions","x","y","z","_updateVertexValid","holeIndices","Array","Number"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\nimport {cutPolygonByGrid, cutPolygonByMercatorBounds} from '@math.gl/polygon';\n\nimport type {\n  PolygonGeometry,\n  NormalizedPolygonGeometry,\n  FlatComplexPolygonGeometry\n} from './polygon';\nimport type {TypedArray} from '@math.gl/core';\n\ntype GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\ntype CutPolygon = FlatComplexPolygonGeometry & {\n  edgeTypes: number[];\n};\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator<\n  PolygonGeometry,\n  NormalizedPolygonGeometry | CutPolygon[],\n  {\n    fp64?: boolean;\n    IndexType?: Uint32ArrayConstructor | Uint16ArrayConstructor;\n    resolution?: number;\n    wrapLongitude?: boolean;\n    preproject?: (xy: number[]) => number[];\n  }\n> {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /** Get attribute by name */\n  get(attributeName: string): TypedArray | null {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /** Override base Tesselator method */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      // @ts-ignore (2339) value is not defined on TypedArray (fall through)\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n\n  /** Implement base Tesselator interface */\n  protected normalizeGeometry(polygon: PolygonGeometry): NormalizedPolygonGeometry | CutPolygon[] {\n    if (this.normalize) {\n      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(\n          Polygon.getPositions(normalizedPolygon),\n          Polygon.getHoleIndices(normalizedPolygon),\n          {\n            size: this.positionSize,\n            gridResolution: this.opts.resolution,\n            edgeTypes: true\n          }\n        ) as CutPolygon[];\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(\n          Polygon.getPositions(normalizedPolygon),\n          Polygon.getHoleIndices(normalizedPolygon),\n          {\n            size: this.positionSize,\n            maxLatitude: 86,\n            edgeTypes: true\n          }\n        ) as CutPolygon[];\n      }\n      return normalizedPolygon;\n    }\n    // normalize is explicitly set to false, assume that user passed in already normalized polygons\n    return polygon as NormalizedPolygonGeometry;\n  }\n\n  /** Implement base Tesselator interface */\n  protected getGeometrySize(polygon: NormalizedPolygonGeometry | CutPolygon[]): number {\n    if (isCut(polygon)) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return Polygon.getPositions(polygon).length / this.positionSize;\n  }\n\n  /** Override base Tesselator method */\n  protected getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return null;\n  }\n\n  /** Implement base Tesselator interface */\n  protected updateGeometryAttributes(\n    polygon: NormalizedPolygonGeometry | CutPolygon[] | null,\n    context: GeometryUpdateContext\n  ) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n      this._updatePositions(polygon, context);\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  // Flatten the indices array\n  private _updateIndices(\n    polygon: NormalizedPolygonGeometry | null,\n    {geometryIndex, vertexStart: offset, indexStart}: GeometryUpdateContext\n  ) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target || !polygon) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  private _updatePositions(\n    polygon: NormalizedPolygonGeometry | null,\n    {vertexStart, geometrySize}: GeometryUpdateContext\n  ) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions || !polygon) {\n      return;\n    }\n    const polygonPositions = Polygon.getPositions(polygon);\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  private _updateVertexValid(\n    polygon: NormalizedPolygonGeometry | null,\n    {vertexStart, geometrySize}: GeometryUpdateContext\n  ) {\n    const {positionSize} = this;\n    const vertexValid = this.attributes.vertexValid as TypedArray;\n    const holeIndices = polygon && Polygon.getHoleIndices(polygon);\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (polygon && (polygon as CutPolygon).edgeTypes) {\n      vertexValid.set((polygon as CutPolygon).edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n\nfunction isCut(polygon: NormalizedPolygonGeometry | CutPolygon[]): polygon is CutPolygon[] {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}\n"]},"metadata":{},"sourceType":"module"}