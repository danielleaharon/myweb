{"ast":null,"code":"import Input from './input';\nimport { INPUT_EVENT_TYPES } from '../constants';\nconst {\n  MOUSE_EVENTS\n} = INPUT_EVENT_TYPES;\nconst MOVE_EVENT_TYPE = 'pointermove';\nconst OVER_EVENT_TYPE = 'pointerover';\nconst OUT_EVENT_TYPE = 'pointerout';\nconst ENTER_EVENT_TYPE = 'pointerenter';\nconst LEAVE_EVENT_TYPE = 'pointerleave';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\n\nexport default class MoveInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, options);\n\n    this.handleEvent = event => {\n      this.handleOverEvent(event);\n      this.handleOutEvent(event);\n      this.handleEnterEvent(event);\n      this.handleLeaveEvent(event);\n      this.handleMoveEvent(event);\n    };\n\n    this.pressed = false;\n    const {\n      enable\n    } = this.options;\n    this.enableMoveEvent = enable;\n    this.enableLeaveEvent = enable;\n    this.enableEnterEvent = enable;\n    this.enableOutEvent = enable;\n    this.enableOverEvent = enable;\n    this.events = (this.options.events || []).concat(MOUSE_EVENTS);\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n\n\n  enableEventType(eventType, enabled) {\n    if (eventType === MOVE_EVENT_TYPE) {\n      this.enableMoveEvent = enabled;\n    }\n\n    if (eventType === OVER_EVENT_TYPE) {\n      this.enableOverEvent = enabled;\n    }\n\n    if (eventType === OUT_EVENT_TYPE) {\n      this.enableOutEvent = enabled;\n    }\n\n    if (eventType === ENTER_EVENT_TYPE) {\n      this.enableEnterEvent = enabled;\n    }\n\n    if (eventType === LEAVE_EVENT_TYPE) {\n      this.enableLeaveEvent = enabled;\n    }\n  }\n\n  handleOverEvent(event) {\n    if (this.enableOverEvent) {\n      if (event.type === 'mouseover') {\n        this._emit(OVER_EVENT_TYPE, event);\n      }\n    }\n  }\n\n  handleOutEvent(event) {\n    if (this.enableOutEvent) {\n      if (event.type === 'mouseout') {\n        this._emit(OUT_EVENT_TYPE, event);\n      }\n    }\n  }\n\n  handleEnterEvent(event) {\n    if (this.enableEnterEvent) {\n      if (event.type === 'mouseenter') {\n        this._emit(ENTER_EVENT_TYPE, event);\n      }\n    }\n  }\n\n  handleLeaveEvent(event) {\n    if (this.enableLeaveEvent) {\n      if (event.type === 'mouseleave') {\n        this._emit(LEAVE_EVENT_TYPE, event);\n      }\n    }\n  }\n\n  handleMoveEvent(event) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n\n          break;\n\n        case 'mousemove':\n          // Move events use `which` to track the button being pressed\n          if (event.which === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this._emit(MOVE_EVENT_TYPE, event);\n          }\n\n          break;\n\n        case 'mouseup':\n          this.pressed = false;\n          break;\n\n        default:\n      }\n    }\n  }\n\n  _emit(type, event) {\n    this.callback({\n      type,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/inputs/move-input.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import Input from './input';\nimport { INPUT_EVENT_TYPES } from '../constants';\nconst { MOUSE_EVENTS } = INPUT_EVENT_TYPES;\nconst MOVE_EVENT_TYPE = 'pointermove';\nconst OVER_EVENT_TYPE = 'pointerover';\nconst OUT_EVENT_TYPE = 'pointerout';\nconst ENTER_EVENT_TYPE = 'pointerenter';\nconst LEAVE_EVENT_TYPE = 'pointerleave';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport default class MoveInput extends Input {\n    constructor(element, callback, options) {\n        super(element, callback, options);\n        this.handleEvent = (event) => {\n            this.handleOverEvent(event);\n            this.handleOutEvent(event);\n            this.handleEnterEvent(event);\n            this.handleLeaveEvent(event);\n            this.handleMoveEvent(event);\n        };\n        this.pressed = false;\n        const { enable } = this.options;\n        this.enableMoveEvent = enable;\n        this.enableLeaveEvent = enable;\n        this.enableEnterEvent = enable;\n        this.enableOutEvent = enable;\n        this.enableOverEvent = enable;\n        this.events = (this.options.events || []).concat(MOUSE_EVENTS);\n        this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n    }\n    destroy() {\n        this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n    }\n    /**\n     * Enable this input (begin processing events)\n     * if the specified event type is among those handled by this input.\n     */\n    enableEventType(eventType, enabled) {\n        if (eventType === MOVE_EVENT_TYPE) {\n            this.enableMoveEvent = enabled;\n        }\n        if (eventType === OVER_EVENT_TYPE) {\n            this.enableOverEvent = enabled;\n        }\n        if (eventType === OUT_EVENT_TYPE) {\n            this.enableOutEvent = enabled;\n        }\n        if (eventType === ENTER_EVENT_TYPE) {\n            this.enableEnterEvent = enabled;\n        }\n        if (eventType === LEAVE_EVENT_TYPE) {\n            this.enableLeaveEvent = enabled;\n        }\n    }\n    handleOverEvent(event) {\n        if (this.enableOverEvent) {\n            if (event.type === 'mouseover') {\n                this._emit(OVER_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleOutEvent(event) {\n        if (this.enableOutEvent) {\n            if (event.type === 'mouseout') {\n                this._emit(OUT_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleEnterEvent(event) {\n        if (this.enableEnterEvent) {\n            if (event.type === 'mouseenter') {\n                this._emit(ENTER_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleLeaveEvent(event) {\n        if (this.enableLeaveEvent) {\n            if (event.type === 'mouseleave') {\n                this._emit(LEAVE_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleMoveEvent(event) {\n        if (this.enableMoveEvent) {\n            switch (event.type) {\n                case 'mousedown':\n                    if (event.button >= 0) {\n                        // Button is down\n                        this.pressed = true;\n                    }\n                    break;\n                case 'mousemove':\n                    // Move events use `which` to track the button being pressed\n                    if (event.which === 0) {\n                        // Button is not down\n                        this.pressed = false;\n                    }\n                    if (!this.pressed) {\n                        // Drag events are emitted by hammer already\n                        // we just need to emit the move event on hover\n                        this._emit(MOVE_EVENT_TYPE, event);\n                    }\n                    break;\n                case 'mouseup':\n                    this.pressed = false;\n                    break;\n                default:\n            }\n        }\n    }\n    _emit(type, event) {\n        this.callback({\n            type,\n            center: {\n                x: event.clientX,\n                y: event.clientY\n            },\n            srcEvent: event,\n            pointerType: 'mouse',\n            target: event.target\n        });\n    }\n}\n//# sourceMappingURL=move-input.js.map"]},"metadata":{},"sourceType":"module"}