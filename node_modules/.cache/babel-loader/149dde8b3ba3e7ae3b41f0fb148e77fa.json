{"ast":null,"code":"import { padArray } from '../../utils/array-utils';\nconst DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: t => t\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\nexport function normalizeTransitionSettings(userSettings, layerSettings) {\n  if (!userSettings) {\n    return null;\n  }\n\n  if (Number.isFinite(userSettings)) {\n    userSettings = {\n      type: 'interpolation',\n      duration: userSettings\n    };\n  }\n\n  const type = userSettings.type || 'interpolation';\n  return { ...DEFAULT_TRANSITION_SETTINGS[type],\n    ...layerSettings,\n    ...userSettings,\n    type\n  };\n}\nexport function getSourceBufferAttribute(gl, attribute) {\n  const buffer = attribute.getBuffer();\n\n  if (buffer) {\n    return [buffer, {\n      divisor: 0,\n      size: attribute.size,\n      normalized: attribute.settings.normalized\n    }];\n  }\n\n  return attribute.value;\n}\nexport function getAttributeTypeFromSize(size) {\n  switch (size) {\n    case 1:\n      return 'float';\n\n    case 2:\n      return 'vec2';\n\n    case 3:\n      return 'vec3';\n\n    case 4:\n      return 'vec4';\n\n    default:\n      throw new Error(\"No defined attribute type for size \\\"\".concat(size, \"\\\"\"));\n  }\n}\nexport function cycleBuffers(buffers) {\n  buffers.push(buffers.shift());\n}\nexport function getAttributeBufferLength(attribute, numInstances) {\n  const {\n    doublePrecision,\n    settings,\n    value,\n    size\n  } = attribute;\n  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n  return (settings.noAlloc ? value.length : numInstances * size) * multiplier;\n}\nexport function padBuffer({\n  buffer,\n  numInstances,\n  attribute,\n  fromLength,\n  fromStartIndices,\n  getData = x => x\n}) {\n  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const byteOffset = attribute.byteOffset;\n  const toStartIndices = attribute.startIndices;\n  const hasStartIndices = fromStartIndices && toStartIndices;\n  const toLength = getAttributeBufferLength(attribute, numInstances);\n  const isConstant = attribute.isConstant;\n\n  if (!hasStartIndices && fromLength >= toLength) {\n    return;\n  }\n\n  const toData = isConstant ? attribute.value : attribute.getBuffer().getData({\n    srcByteOffset: byteOffset\n  });\n\n  if (attribute.settings.normalized && !isConstant) {\n    const getter = getData;\n\n    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));\n  }\n\n  const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i, i + size), chunk);\n  const source = buffer.getData({\n    length: fromLength\n  });\n  const data = new Float32Array(toLength);\n  padArray({\n    source,\n    target: data,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size,\n    getData: getMissingData\n  });\n\n  if (buffer.byteLength < data.byteLength + byteOffset) {\n    buffer.reallocate(data.byteLength + byteOffset);\n  }\n\n  buffer.subData({\n    data,\n    offset: byteOffset\n  });\n}","map":{"version":3,"sources":["../../../../src/lib/attribute/attribute-transition-utils.ts"],"names":["DEFAULT_TRANSITION_SETTINGS","interpolation","duration","easing","t","spring","stiffness","damping","Number","userSettings","type","buffer","attribute","divisor","size","normalized","buffers","multiplier","doublePrecision","value","settings","numInstances","getData","x","precisionMultiplier","byteOffset","toStartIndices","hasStartIndices","fromStartIndices","toLength","getAttributeBufferLength","isConstant","fromLength","toData","srcByteOffset","getter","getMissingData","i","source","length","data","padArray","target","sourceStartIndices","targetStartIndices","offset"],"mappings":"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","sourcesContent":["import {padArray} from '../../utils/array-utils';\nimport {NumericArray} from '../../types/types';\nimport Attribute from './attribute';\nimport type {BufferAccessor} from './data-column';\nimport type {Buffer} from '@luma.gl/webgl';\n\nexport interface TransitionSettings {\n  type: string;\n  /** Callback to get the value that the entering vertices are transitioning from. */\n  enter?: (toValue: NumericArray, chunk?: NumericArray) => NumericArray;\n  /** Callback when the transition is started */\n  onStart?: () => void;\n  /** Callback when the transition is done */\n  onEnd?: () => void;\n  /** Callback when the transition is interrupted */\n  onInterrupt?: () => void;\n}\n\nexport type InterpolationTransitionSettings = TransitionSettings & {\n  type?: 'interpolation';\n  /** Duration of the transition animation, in milliseconds */\n  duration: number;\n  /** Easing function that maps a value from [0, 1] to [0, 1], see [http://easings.net/](http://easings.net/) */\n  easing?: (t: number) => number;\n};\n\nexport type SpringTransitionSettings = TransitionSettings & {\n  type: 'spring';\n  /** \"Tension\" factor for the spring */\n  stiffness: number;\n  /** \"Friction\" factor that counteracts the spring's acceleration */\n  damping: number;\n};\n\nconst DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: t => t\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\n\nexport function normalizeTransitionSettings(\n  userSettings: number | InterpolationTransitionSettings | SpringTransitionSettings,\n  layerSettings?: boolean | Partial<TransitionSettings>\n): TransitionSettings | null {\n  if (!userSettings) {\n    return null;\n  }\n  if (Number.isFinite(userSettings)) {\n    userSettings = {type: 'interpolation', duration: userSettings as number};\n  }\n  const type = (userSettings as TransitionSettings).type || 'interpolation';\n  return {\n    ...DEFAULT_TRANSITION_SETTINGS[type],\n    ...(layerSettings as TransitionSettings),\n    ...(userSettings as TransitionSettings),\n    type\n  };\n}\n\n// NOTE: NOT COPYING OVER OFFSET OR STRIDE HERE BECAUSE:\n// (1) WE DON'T SUPPORT INTERLEAVED BUFFERS FOR TRANSITIONS\n// (2) BUFFERS WITH OFFSETS ALWAYS CONTAIN VALUES OF THE SAME SIZE\n// (3) THE OPERATIONS IN THE SHADER ARE PER-COMPONENT (addition and scaling)\nexport function getSourceBufferAttribute(\n  gl: WebGLRenderingContext,\n  attribute: Attribute\n): [Buffer, BufferAccessor] | NumericArray {\n  // The Attribute we pass to Transform as a sourceBuffer must have {divisor: 0}\n  // so we create a copy of the attribute (with divisor=0) to use when running\n  // transform feedback\n  const buffer = attribute.getBuffer();\n  if (buffer) {\n    return [\n      buffer,\n      {\n        divisor: 0,\n        size: attribute.size,\n        normalized: attribute.settings.normalized\n      } as BufferAccessor\n    ];\n  }\n  // constant\n  // don't pass normalized here because the `value` from a normalized attribute is\n  // already normalized\n  return attribute.value as NumericArray;\n}\n\nexport function getAttributeTypeFromSize(size: number): string {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(`No defined attribute type for size \"${size}\"`);\n  }\n}\n\nexport function cycleBuffers(buffers: Buffer[]): void {\n  buffers.push(buffers.shift() as Buffer);\n}\n\nexport function getAttributeBufferLength(attribute: Attribute, numInstances: number): number {\n  const {doublePrecision, settings, value, size} = attribute;\n  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n  return (settings.noAlloc ? (value as NumericArray).length : numInstances * size) * multiplier;\n}\n\n// This helper is used when transitioning attributes from a set of values in one buffer layout\n// to a set of values in a different buffer layout. (Buffer layouts are used when attribute values\n// within a buffer should be grouped for drawElements, like the Polygon layer.) For example, a\n// buffer layout of [3, 4] might have data [A1, A2, A3, B1, B2, B3, B4]. If it needs to transition\n// to a buffer layout of [4, 2], it should produce a buffer, using the transition setting's `enter`\n// function, that looks like this: [A1, A2, A3, A4 (user `enter` fn), B1, B2, 0]. Note: the final\n// 0 in this buffer is because we never shrink buffers, only grow them, for performance reasons.\nexport function padBuffer({\n  buffer,\n  numInstances,\n  attribute,\n  fromLength,\n  fromStartIndices,\n  getData = x => x\n}: {\n  buffer: Buffer;\n  numInstances: number;\n  attribute: Attribute;\n  fromLength: number;\n  fromStartIndices?: NumericArray | null;\n  getData?: (toValue: NumericArray, chunk?: NumericArray) => NumericArray;\n}): void {\n  // TODO: move the precisionMultiplier logic to the attribute when retrieving\n  // its `size` and `elementOffset`?\n  const precisionMultiplier =\n    attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const byteOffset = attribute.byteOffset;\n  const toStartIndices = attribute.startIndices;\n  const hasStartIndices = fromStartIndices && toStartIndices;\n  const toLength = getAttributeBufferLength(attribute, numInstances);\n  const isConstant = attribute.isConstant;\n\n  // check if buffer needs to be padded\n  if (!hasStartIndices && fromLength >= toLength) {\n    return;\n  }\n\n  const toData = isConstant\n    ? attribute.value\n    : (attribute.getBuffer() as Buffer).getData({srcByteOffset: byteOffset});\n  if (attribute.settings.normalized && !isConstant) {\n    const getter = getData;\n    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));\n  }\n\n  const getMissingData = isConstant\n    ? (i, chunk) => getData(toData, chunk)\n    : (i, chunk) => getData(toData.subarray(i, i + size), chunk);\n\n  const source = buffer.getData({length: fromLength});\n  const data = new Float32Array(toLength);\n  padArray({\n    source,\n    target: data,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size,\n    getData: getMissingData\n  });\n\n  // TODO: support offset in buffer.setData?\n  if (buffer.byteLength < data.byteLength + byteOffset) {\n    buffer.reallocate(data.byteLength + byteOffset);\n  }\n  buffer.subData({data, offset: byteOffset});\n}\n"]},"metadata":{},"sourceType":"module"}