{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Texture2D, copyToTexture } from '@luma.gl/core';\nimport { ImageLoader } from '@loaders.gl/images';\nimport { load } from '@loaders.gl/core';\nimport { createIterable } from '@deck.gl/core';\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\n\nconst noop = () => {};\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [10241]: 9987,\n  [10240]: 9729,\n  [10242]: 33071,\n  [10243]: 33071\n};\n\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\nfunction resizeImage(ctx, imageData, width, height) {\n  if (width === imageData.width && height === imageData.height) {\n    return imageData;\n  }\n\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n  return ctx.canvas;\n}\n\nfunction getIconId(icon) {\n  return icon && (icon.id || icon.url);\n}\n\nfunction resizeTexture(texture, width, height, parameters) {\n  const oldWidth = texture.width;\n  const oldHeight = texture.height;\n  const newTexture = new Texture2D(texture.gl, {\n    width,\n    height,\n    parameters\n  });\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight\n  });\n  texture.delete();\n  return newTexture;\n}\n\nfunction buildRowMapping(mapping, columns, yOffset) {\n  for (let i = 0; i < columns.length; i++) {\n    const {\n      icon,\n      xOffset\n    } = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = { ...icon,\n      x: xOffset,\n      y: yOffset\n    };\n  }\n}\n\nexport function buildMapping({\n  icons,\n  buffer,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n  rowHeight = 0,\n  canvasWidth\n}) {\n  let columns = [];\n\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n\n    if (!mapping[id]) {\n      const {\n        height,\n        width\n      } = icon;\n\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon,\n        xOffset\n      });\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\nexport function getDiffIcons(data, getIcon, cachedIcons) {\n  if (!data || !getIcon) {\n    return null;\n  }\n\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {\n    iterable,\n    objectInfo\n  } = createIterable(data);\n\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = { ...icon,\n        source: object,\n        sourceIndex: objectInfo.index\n      };\n    }\n  }\n\n  return icons;\n}\nexport default class IconManager {\n  constructor(gl, {\n    onUpdate = noop,\n    onError = noop\n  }) {\n    _defineProperty(this, \"gl\", void 0);\n\n    _defineProperty(this, \"onUpdate\", void 0);\n\n    _defineProperty(this, \"onError\", void 0);\n\n    _defineProperty(this, \"_loadOptions\", null);\n\n    _defineProperty(this, \"_texture\", null);\n\n    _defineProperty(this, \"_externalTexture\", null);\n\n    _defineProperty(this, \"_mapping\", {});\n\n    _defineProperty(this, \"_textureParameters\", null);\n\n    _defineProperty(this, \"_pendingCount\", 0);\n\n    _defineProperty(this, \"_autoPacking\", false);\n\n    _defineProperty(this, \"_xOffset\", 0);\n\n    _defineProperty(this, \"_yOffset\", 0);\n\n    _defineProperty(this, \"_rowHeight\", 0);\n\n    _defineProperty(this, \"_buffer\", DEFAULT_BUFFER);\n\n    _defineProperty(this, \"_canvasWidth\", DEFAULT_CANVAS_WIDTH);\n\n    _defineProperty(this, \"_canvasHeight\", 0);\n\n    _defineProperty(this, \"_canvas\", null);\n\n    this.gl = gl;\n    this.onUpdate = onUpdate;\n    this.onError = onError;\n  }\n\n  finalize() {\n    var _this$_texture;\n\n    (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.delete();\n  }\n\n  getTexture() {\n    return this._texture || this._externalTexture;\n  }\n\n  getIconMapping(icon) {\n    const id = this._autoPacking ? getIconId(icon) : icon;\n    return this._mapping[id] || {};\n  }\n\n  setProps({\n    loadOptions,\n    autoPacking,\n    iconAtlas,\n    iconMapping,\n    textureParameters\n  }) {\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n\n    if (iconAtlas) {\n      var _this$_texture2;\n\n      (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.delete();\n      this._texture = null;\n      this._externalTexture = iconAtlas;\n    }\n\n    if (textureParameters) {\n      this._textureParameters = textureParameters;\n    }\n  }\n\n  get isLoaded() {\n    return this._pendingCount === 0;\n  }\n\n  packIcons(data, getIcon) {\n    if (!this._autoPacking || typeof document === 'undefined') {\n      return;\n    }\n\n    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});\n\n    if (icons.length > 0) {\n      const {\n        mapping,\n        xOffset,\n        yOffset,\n        rowHeight,\n        canvasHeight\n      } = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n\n      if (!this._texture) {\n        this._texture = new Texture2D(this.gl, {\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          parameters: this._textureParameters || DEFAULT_TEXTURE_PARAMETERS\n        });\n      }\n\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || DEFAULT_TEXTURE_PARAMETERS);\n      }\n\n      this.onUpdate();\n      this._canvas = this._canvas || document.createElement('canvas');\n\n      this._loadIcons(icons);\n    }\n  }\n\n  _loadIcons(icons) {\n    const ctx = this._canvas.getContext('2d');\n\n    for (const icon of icons) {\n      this._pendingCount++;\n      load(icon.url, ImageLoader, this._loadOptions).then(imageData => {\n        const id = getIconId(icon);\n        const {\n          x,\n          y,\n          width,\n          height\n        } = this._mapping[id];\n        const data = resizeImage(ctx, imageData, width, height);\n\n        this._texture.setSubImageData({\n          data,\n          x,\n          y,\n          width,\n          height\n        });\n\n        this._texture.generateMipmap();\n\n        this.onUpdate();\n      }).catch(error => {\n        this.onError({\n          url: icon.url,\n          source: icon.source,\n          sourceIndex: icon.sourceIndex,\n          loadOptions: this._loadOptions,\n          error\n        });\n      }).finally(() => {\n        this._pendingCount--;\n      });\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/icon-layer/icon-manager.ts"],"names":["DEFAULT_CANVAS_WIDTH","DEFAULT_BUFFER","noop","DEFAULT_TEXTURE_PARAMETERS","Math","width","imageData","height","ctx","icon","oldWidth","texture","oldHeight","newTexture","parameters","copyToTexture","targetY","i","columns","xOffset","id","getIconId","mapping","x","y","yOffset","rowHeight","canvasWidth","icons","buildRowMapping","canvasHeight","nextPowOfTwo","cachedIcons","objectInfo","createIterable","getIcon","source","sourceIndex","index","constructor","onUpdate","onError","finalize","getTexture","getIconMapping","setProps","textureParameters","autoPacking","isLoaded","packIcons","Object","getDiffIcons","buildMapping","buffer","_yOffset","resizeTexture","document","_loadIcons","load","data","resizeImage","error","url","loadOptions"],"mappings":"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","sourcesContent":["/* global document */\nimport GL from '@luma.gl/constants';\nimport {Texture2D, copyToTexture} from '@luma.gl/core';\nimport {ImageLoader} from '@loaders.gl/images';\nimport {load} from '@loaders.gl/core';\nimport {createIterable} from '@deck.gl/core';\n\nimport type {AccessorFunction} from '@deck.gl/core';\n\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\n\nconst noop = () => {};\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n  // GL.LINEAR is the default value but explicitly set it here\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  // for texture boundary artifact\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\n\ntype IconDef = {\n  /** Width of the icon */\n  width: number;\n  /** Height of the icon */\n  height: number;\n  /** Horizontal position of icon anchor. Default: half width. */\n  anchorX?: number;\n  /** Vertical position of icon anchor. Default: half height. */\n  anchorY?: number;\n  /**\n   * Whether the icon is treated as a transparency mask.\n   * If `true`, color defined by `getColor` is applied.\n   * If `false`, pixel color from the icon image is applied.\n   * @default false\n   */\n  mask?: boolean;\n};\n\nexport type UnpackedIcon = {\n  /** Url to fetch the icon */\n  url: string;\n  /** Unique identifier of the icon. Icons of the same id are only fetched once. Fallback to `url` if not specified. */\n  id?: string;\n} & IconDef;\n\ntype PrepackedIcon = {\n  /** Left position of the icon on the atlas */\n  x: number;\n  /** Top position of the icon on the atlas */\n  y: number;\n} & IconDef;\n\nexport type IconMapping = Record<string, PrepackedIcon>;\n\nexport type LoadIconErrorContext = {\n  error: Error;\n  /** The URL that was trying to fetch */\n  url: string;\n  /** The original data object that requested this icon */\n  source: any;\n  /** The index of the original data object that requested this icon */\n  sourceIndex: number;\n  /** The load options used for the fetch */\n  loadOptions: any;\n};\n\nfunction nextPowOfTwo(number: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n// update comment to create a new texture and copy original data.\nfunction resizeImage(\n  ctx: CanvasRenderingContext2D,\n  imageData: HTMLImageElement | ImageBitmap,\n  width: number,\n  height: number\n): HTMLImageElement | HTMLCanvasElement | ImageBitmap {\n  if (width === imageData.width && height === imageData.height) {\n    return imageData;\n  }\n\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n\n  return ctx.canvas;\n}\n\nfunction getIconId(icon: UnpackedIcon): string {\n  return icon && (icon.id || icon.url);\n}\n\n// resize texture without losing original data\nfunction resizeTexture(\n  texture: Texture2D,\n  width: number,\n  height: number,\n  parameters: any\n): Texture2D {\n  const oldWidth = texture.width;\n  const oldHeight = texture.height;\n\n  const newTexture = new Texture2D(texture.gl, {width, height, parameters});\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight\n  });\n\n  texture.delete();\n  return newTexture;\n}\n\n// traverse icons in a row of icon atlas\n// extend each icon with left-top coordinates\nfunction buildRowMapping(\n  mapping: IconMapping,\n  columns: {\n    icon: UnpackedIcon;\n    xOffset: number;\n  }[],\n  yOffset: number\n): void {\n  for (let i = 0; i < columns.length; i++) {\n    const {icon, xOffset} = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = {\n      ...icon,\n      x: xOffset,\n      y: yOffset\n    };\n  }\n}\n\n/**\n * Generate coordinate mapping to retrieve icon left-top position from an icon atlas\n */\nexport function buildMapping({\n  icons,\n  buffer,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n  rowHeight = 0,\n  canvasWidth\n}: {\n  /** list of icon definitions */\n  icons: UnpackedIcon[];\n  /** add bleeding buffer to the right and bottom side of the image */\n  buffer: number;\n  /** right position of last icon in old mapping */\n  xOffset: number;\n  /** top position in last icon in old mapping */\n  yOffset: number;\n  /** height of the last icon's row */\n  rowHeight: number;\n  /** max width of canvas */\n  canvasWidth: number;\n  mapping: IconMapping;\n}): {\n  mapping: IconMapping;\n  rowHeight: number;\n  xOffset: number;\n  yOffset: number;\n  canvasWidth: number;\n  canvasHeight: number;\n} {\n  let columns: {\n    icon: UnpackedIcon;\n    xOffset: number;\n  }[] = [];\n  // Strategy to layout all the icons into a texture:\n  // traverse the icons sequentially, layout the icons from left to right, top to bottom\n  // when the sum of the icons width is equal or larger than canvasWidth,\n  // move to next row starting from total height so far plus max height of the icons in previous row\n  // row width is equal to canvasWidth\n  // row height is decided by the max height of the icons in that row\n  // mapping coordinates of each icon is its left-top position in the texture\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n\n    if (!mapping[id]) {\n      const {height, width} = icon;\n\n      // fill one row\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon,\n        xOffset\n      });\n\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\n\n// extract icons from data\n// return icons should be unique, and not cached or cached but url changed\nexport function getDiffIcons(\n  data: any,\n  getIcon: AccessorFunction<any, UnpackedIcon> | null,\n  cachedIcons: Record<string, PrepackedIcon & {url?: string}>\n): Record<\n  string,\n  UnpackedIcon & {\n    source: any;\n    sourceIndex: number;\n  }\n> | null {\n  if (!data || !getIcon) {\n    return null;\n  }\n\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {iterable, objectInfo} = createIterable(data);\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = {...icon, source: object, sourceIndex: objectInfo.index};\n    }\n  }\n  return icons;\n}\n\nexport default class IconManager {\n  gl: WebGLRenderingContext;\n\n  private onUpdate: () => void;\n  private onError: (context: LoadIconErrorContext) => void;\n  private _loadOptions: any = null;\n  private _texture: Texture2D | null = null;\n  private _externalTexture: Texture2D | null = null;\n  private _mapping: IconMapping = {};\n  private _textureParameters: Record<number, number> | null = null;\n\n  /** count of pending requests to fetch icons */\n  private _pendingCount: number = 0;\n\n  private _autoPacking: boolean = false;\n\n  // / internal state used for autoPacking\n\n  private _xOffset: number = 0;\n  private _yOffset: number = 0;\n  private _rowHeight: number = 0;\n  private _buffer: number = DEFAULT_BUFFER;\n  private _canvasWidth: number = DEFAULT_CANVAS_WIDTH;\n  private _canvasHeight: number = 0;\n  private _canvas: HTMLCanvasElement | null = null;\n\n  constructor(\n    gl: WebGLRenderingContext,\n    {\n      onUpdate = noop,\n      onError = noop\n    }: {\n      /** Callback when the texture updates */\n      onUpdate: () => void;\n      /** Callback when an error is encountered */\n      onError: (context: LoadIconErrorContext) => void;\n    }\n  ) {\n    this.gl = gl;\n    this.onUpdate = onUpdate;\n    this.onError = onError;\n  }\n\n  finalize(): void {\n    this._texture?.delete();\n  }\n\n  getTexture(): Texture2D | null {\n    return this._texture || this._externalTexture;\n  }\n\n  getIconMapping(icon: string | UnpackedIcon): PrepackedIcon {\n    const id = this._autoPacking ? getIconId(icon as UnpackedIcon) : (icon as string);\n    return this._mapping[id] || {};\n  }\n\n  setProps({\n    loadOptions,\n    autoPacking,\n    iconAtlas,\n    iconMapping,\n    textureParameters\n  }: {\n    loadOptions?: any;\n    autoPacking?: boolean;\n    iconAtlas?: Texture2D | null;\n    iconMapping?: IconMapping | null;\n    textureParameters?: Record<number, number> | null;\n  }) {\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n\n    if (iconAtlas) {\n      this._texture?.delete();\n      this._texture = null;\n      this._externalTexture = iconAtlas;\n    }\n\n    if (textureParameters) {\n      this._textureParameters = textureParameters;\n    }\n  }\n\n  get isLoaded(): boolean {\n    return this._pendingCount === 0;\n  }\n\n  packIcons(data: any, getIcon: AccessorFunction<any, UnpackedIcon>): void {\n    if (!this._autoPacking || typeof document === 'undefined') {\n      return;\n    }\n\n    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});\n\n    if (icons.length > 0) {\n      // generate icon mapping\n      const {mapping, xOffset, yOffset, rowHeight, canvasHeight} = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n\n      // create new texture\n      if (!this._texture) {\n        this._texture = new Texture2D(this.gl, {\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          parameters: this._textureParameters || DEFAULT_TEXTURE_PARAMETERS\n        });\n      }\n\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(\n          this._texture,\n          this._canvasWidth,\n          this._canvasHeight,\n          this._textureParameters || DEFAULT_TEXTURE_PARAMETERS\n        );\n      }\n\n      this.onUpdate();\n\n      // load images\n      this._canvas = this._canvas || document.createElement('canvas');\n      this._loadIcons(icons);\n    }\n  }\n\n  private _loadIcons(\n    icons: (UnpackedIcon & {\n      source: any;\n      sourceIndex: number;\n    })[]\n  ): void {\n    // This method is only called in the auto packing case, where _canvas is defined\n    const ctx = this._canvas!.getContext('2d') as CanvasRenderingContext2D;\n\n    for (const icon of icons) {\n      this._pendingCount++;\n      load(icon.url, ImageLoader, this._loadOptions)\n        .then(imageData => {\n          const id = getIconId(icon);\n          const {x, y, width, height} = this._mapping[id];\n\n          const data = resizeImage(ctx, imageData, width, height);\n\n          this._texture.setSubImageData({\n            data,\n            x,\n            y,\n            width,\n            height\n          });\n\n          // Call to regenerate mipmaps after modifying texture(s)\n          this._texture.generateMipmap();\n\n          this.onUpdate();\n        })\n        .catch(error => {\n          this.onError({\n            url: icon.url,\n            source: icon.source,\n            sourceIndex: icon.sourceIndex,\n            loadOptions: this._loadOptions,\n            error\n          });\n        })\n        .finally(() => {\n          this._pendingCount--;\n        });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}