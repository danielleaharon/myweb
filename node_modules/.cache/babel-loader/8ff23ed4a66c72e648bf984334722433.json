{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nexport default class LRUCache {\n  constructor(limit = 5) {\n    _defineProperty(this, \"limit\", void 0);\n\n    _defineProperty(this, \"_cache\", {});\n\n    _defineProperty(this, \"_order\", []);\n\n    this.limit = limit;\n  }\n\n  get(key) {\n    const value = this._cache[key];\n\n    if (value) {\n      this._deleteOrder(key);\n\n      this._appendOrder(key);\n    }\n\n    return value;\n  }\n\n  set(key, value) {\n    if (!this._cache[key]) {\n      if (Object.keys(this._cache).length === this.limit) {\n        this.delete(this._order[0]);\n      }\n\n      this._cache[key] = value;\n\n      this._appendOrder(key);\n    } else {\n      this.delete(key);\n      this._cache[key] = value;\n\n      this._appendOrder(key);\n    }\n  }\n\n  delete(key) {\n    const value = this._cache[key];\n\n    if (value) {\n      delete this._cache[key];\n\n      this._deleteOrder(key);\n    }\n  }\n\n  _deleteOrder(key) {\n    const index = this._order.indexOf(key);\n\n    if (index >= 0) {\n      this._order.splice(index, 1);\n    }\n  }\n\n  _appendOrder(key) {\n    this._order.push(key);\n  }\n\n}","map":{"version":3,"sources":["../../../src/text-layer/lru-cache.ts"],"names":["constructor","limit","get","value","set","Object","delete","_deleteOrder","index","_appendOrder"],"mappings":";AAOA,eAAe,MAAA,QAAA,CAAuB;AAMpCA,EAAAA,WAAW,CAACC,KAAa,GAAd,CAAA,EAAoB;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,OAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,QAAA,EAJU,EAIV,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,QAAA,EAFJ,EAEI,CAAA;;AAC7B,SAAA,KAAA,GAAA,KAAA;AACD;;AAEDC,EAAAA,GAAG,CAAA,GAAA,EAAsB;AACvB,UAAMC,KAAK,GAAG,KAAA,MAAA,CAAd,GAAc,CAAd;;AACA,QAAA,KAAA,EAAW;AAET,WAAA,YAAA,CAAA,GAAA;;AACA,WAAA,YAAA,CAAA,GAAA;AACD;;AACD,WAAA,KAAA;AACD;;AAEDC,EAAAA,GAAG,CAAA,GAAA,EAAA,KAAA,EAAmC;AACpC,QAAI,CAAC,KAAA,MAAA,CAAL,GAAK,CAAL,EAAuB;AAErB,UAAIC,MAAM,CAANA,IAAAA,CAAY,KAAZA,MAAAA,EAAAA,MAAAA,KAAoC,KAAxC,KAAA,EAAoD;AAClD,aAAA,MAAA,CAAY,KAAA,MAAA,CAAZ,CAAY,CAAZ;AACD;;AAED,WAAA,MAAA,CAAA,GAAA,IAAA,KAAA;;AACA,WAAA,YAAA,CAAA,GAAA;AAPF,KAAA,MAQO;AAEL,WAAA,MAAA,CAAA,GAAA;AAEA,WAAA,MAAA,CAAA,GAAA,IAAA,KAAA;;AACA,WAAA,YAAA,CAAA,GAAA;AACD;AACF;;AAEDC,EAAAA,MAAM,CAAA,GAAA,EAAoB;AACxB,UAAMH,KAAK,GAAG,KAAA,MAAA,CAAd,GAAc,CAAd;;AACA,QAAA,KAAA,EAAW;AACT,aAAO,KAAA,MAAA,CAAP,GAAO,CAAP;;AACA,WAAA,YAAA,CAAA,GAAA;AACD;AACF;;AAEOI,EAAAA,YAAY,CAAA,GAAA,EAAoB;AACtC,UAAMC,KAAK,GAAG,KAAA,MAAA,CAAA,OAAA,CAAd,GAAc,CAAd;;AACA,QAAIA,KAAK,IAAT,CAAA,EAAgB;AACd,WAAA,MAAA,CAAA,MAAA,CAAA,KAAA,EAAA,CAAA;AACD;AACF;;AAEOC,EAAAA,YAAY,CAAA,GAAA,EAAoB;AACtC,SAAA,MAAA,CAAA,IAAA,CAAA,GAAA;AACD;;AAvDmC","sourcesContent":["/**\n * LRU Cache class with limit\n *\n * Update order for each get/set operation\n * Delete oldest when reach given limit\n */\n\nexport default class LRUCache<ValueT> {\n  private limit: number;\n  private _cache: Record<string, ValueT> = {};\n  /** access/update order, first item is oldest, last item is newest */\n  private _order: string[] = [];\n\n  constructor(limit: number = 5) {\n    this.limit = limit;\n  }\n\n  get(key: string): ValueT {\n    const value = this._cache[key];\n    if (value) {\n      // update order\n      this._deleteOrder(key);\n      this._appendOrder(key);\n    }\n    return value;\n  }\n\n  set(key: string, value: ValueT): void {\n    if (!this._cache[key]) {\n      // if reach limit, delete the oldest\n      if (Object.keys(this._cache).length === this.limit) {\n        this.delete(this._order[0]);\n      }\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    } else {\n      // if found in cache, delete the old one, insert new one to the first of list\n      this.delete(key);\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    }\n  }\n\n  delete(key: string): void {\n    const value = this._cache[key];\n    if (value) {\n      delete this._cache[key];\n      this._deleteOrder(key);\n    }\n  }\n\n  private _deleteOrder(key: string): void {\n    const index = this._order.indexOf(key);\n    if (index >= 0) {\n      this._order.splice(index, 1);\n    }\n  }\n\n  private _appendOrder(key: string): void {\n    this._order.push(key);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}