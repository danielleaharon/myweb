{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { clamp } from '@math.gl/core';\nimport Controller from './controller';\nimport ViewState from './view-state';\nimport { mod } from '../utils/math-utils';\nimport LinearInterpolator from '../transitions/linear-interpolator';\nexport class OrbitState extends ViewState {\n  constructor(options) {\n    const {\n      width,\n      height,\n      rotationX = 0,\n      rotationOrbit = 0,\n      target = [0, 0, 0],\n      zoom = 0,\n      minRotationX = -90,\n      maxRotationX = 90,\n      minZoom = -Infinity,\n      maxZoom = Infinity,\n      startPanPosition,\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      startZoomPosition,\n      startZoom\n    } = options;\n    super({\n      width,\n      height,\n      rotationX,\n      rotationOrbit,\n      target,\n      zoom,\n      minRotationX,\n      maxRotationX,\n      minZoom,\n      maxZoom\n    }, {\n      startPanPosition,\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      startZoomPosition,\n      startZoom\n    });\n\n    _defineProperty(this, \"makeViewport\", void 0);\n\n    this.makeViewport = options.makeViewport;\n  }\n\n  panStart({\n    pos\n  }) {\n    return this._getUpdatedState({\n      startPanPosition: this._unproject(pos)\n    });\n  }\n\n  pan({\n    pos,\n    startPosition\n  }) {\n    const startPanPosition = this.getState().startPanPosition || startPosition;\n\n    if (!startPanPosition) {\n      return this;\n    }\n\n    const viewport = this.makeViewport(this.getViewportProps());\n    const newProps = viewport.panByPosition(startPanPosition, pos);\n    return this._getUpdatedState(newProps);\n  }\n\n  panEnd() {\n    return this._getUpdatedState({\n      startPanPosition: null\n    });\n  }\n\n  rotateStart({\n    pos\n  }) {\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startRotationX: this.getViewportProps().rotationX,\n      startRotationOrbit: this.getViewportProps().rotationOrbit\n    });\n  }\n\n  rotate({\n    pos,\n    deltaAngleX = 0,\n    deltaAngleY = 0\n  }) {\n    const {\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit\n    } = this.getState();\n    const {\n      width,\n      height\n    } = this.getViewportProps();\n\n    if (!startRotatePos || startRotationX === undefined || startRotationOrbit === undefined) {\n      return this;\n    }\n\n    let newRotation;\n\n    if (pos) {\n      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n\n      if (startRotationX < -90 || startRotationX > 90) {\n        deltaScaleX *= -1;\n      }\n\n      newRotation = {\n        rotationX: startRotationX + deltaScaleY * 180,\n        rotationOrbit: startRotationOrbit + deltaScaleX * 180\n      };\n    } else {\n      newRotation = {\n        rotationX: startRotationX + deltaAngleY,\n        rotationOrbit: startRotationOrbit + deltaAngleX\n      };\n    }\n\n    return this._getUpdatedState(newRotation);\n  }\n\n  rotateEnd() {\n    return this._getUpdatedState({\n      startRotationX: null,\n      startRotationOrbit: null\n    });\n  }\n\n  shortestPathFrom(viewState) {\n    const fromProps = viewState.getViewportProps();\n    const props = { ...this.getViewportProps()\n    };\n    const {\n      rotationOrbit\n    } = props;\n\n    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {\n      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;\n    }\n\n    return props;\n  }\n\n  zoomStart({\n    pos\n  }) {\n    return this._getUpdatedState({\n      startZoomPosition: this._unproject(pos),\n      startZoom: this.getViewportProps().zoom\n    });\n  }\n\n  zoom({\n    pos,\n    startPos,\n    scale\n  }) {\n    let {\n      startZoom,\n      startZoomPosition\n    } = this.getState();\n\n    if (!startZoomPosition) {\n      startZoom = this.getViewportProps().zoom;\n      startZoomPosition = this._unproject(startPos) || this._unproject(pos);\n    }\n\n    if (!startZoomPosition) {\n      return this;\n    }\n\n    const newZoom = this._calculateNewZoom({\n      scale,\n      startZoom\n    });\n\n    const zoomedViewport = this.makeViewport({ ...this.getViewportProps(),\n      zoom: newZoom\n    });\n    return this._getUpdatedState({\n      zoom: newZoom,\n      ...zoomedViewport.panByPosition(startZoomPosition, pos)\n    });\n  }\n\n  zoomEnd() {\n    return this._getUpdatedState({\n      startZoomPosition: null,\n      startZoom: null\n    });\n  }\n\n  zoomIn(speed = 2) {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({\n        scale: speed\n      })\n    });\n  }\n\n  zoomOut(speed = 2) {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({\n        scale: 1 / speed\n      })\n    });\n  }\n\n  moveLeft(speed = 50) {\n    return this._panFromCenter([-speed, 0]);\n  }\n\n  moveRight(speed = 50) {\n    return this._panFromCenter([speed, 0]);\n  }\n\n  moveUp(speed = 50) {\n    return this._panFromCenter([0, -speed]);\n  }\n\n  moveDown(speed = 50) {\n    return this._panFromCenter([0, speed]);\n  }\n\n  rotateLeft(speed = 15) {\n    return this._getUpdatedState({\n      rotationOrbit: this.getViewportProps().rotationOrbit - speed\n    });\n  }\n\n  rotateRight(speed = 15) {\n    return this._getUpdatedState({\n      rotationOrbit: this.getViewportProps().rotationOrbit + speed\n    });\n  }\n\n  rotateUp(speed = 10) {\n    return this._getUpdatedState({\n      rotationX: this.getViewportProps().rotationX - speed\n    });\n  }\n\n  rotateDown(speed = 10) {\n    return this._getUpdatedState({\n      rotationX: this.getViewportProps().rotationX + speed\n    });\n  }\n\n  _unproject(pos) {\n    const viewport = this.makeViewport(this.getViewportProps());\n    return pos && viewport.unproject(pos);\n  }\n\n  _calculateNewZoom({\n    scale,\n    startZoom\n  }) {\n    const {\n      maxZoom,\n      minZoom\n    } = this.getViewportProps();\n\n    if (startZoom === undefined) {\n      startZoom = this.getViewportProps().zoom;\n    }\n\n    const zoom = startZoom + Math.log2(scale);\n    return clamp(zoom, minZoom, maxZoom);\n  }\n\n  _panFromCenter(offset) {\n    const {\n      width,\n      height,\n      target\n    } = this.getViewportProps();\n    return this.pan({\n      startPosition: target,\n      pos: [width / 2 + offset[0], height / 2 + offset[1]]\n    });\n  }\n\n  _getUpdatedState(newProps) {\n    return new this.constructor({\n      makeViewport: this.makeViewport,\n      ...this.getViewportProps(),\n      ...this.getState(),\n      ...newProps\n    });\n  }\n\n  applyConstraints(props) {\n    const {\n      maxZoom,\n      minZoom,\n      zoom,\n      maxRotationX,\n      minRotationX,\n      rotationOrbit\n    } = props;\n    props.zoom = Array.isArray(zoom) ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)] : clamp(zoom, minZoom, maxZoom);\n    props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);\n\n    if (rotationOrbit < -180 || rotationOrbit > 180) {\n      props.rotationOrbit = mod(rotationOrbit + 180, 360) - 180;\n    }\n\n    return props;\n  }\n\n}\nexport default class OrbitController extends Controller {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ControllerState\", OrbitState);\n\n    _defineProperty(this, \"transition\", {\n      transitionDuration: 300,\n      transitionInterpolator: new LinearInterpolator({\n        transitionProps: {\n          compare: ['target', 'zoom', 'rotationX', 'rotationOrbit'],\n          required: ['target', 'zoom']\n        }\n      })\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/controllers/orbit-controller.ts"],"names":["constructor","rotationX","rotationOrbit","target","zoom","minRotationX","maxRotationX","minZoom","maxZoom","startZoom","options","panStart","pos","startPanPosition","pan","startPosition","viewport","newProps","panEnd","rotateStart","startRotatePos","startRotationX","startRotationOrbit","rotate","deltaAngleX","deltaAngleY","height","deltaScaleX","deltaScaleY","newRotation","rotateEnd","shortestPathFrom","fromProps","viewState","props","Math","zoomStart","startZoomPosition","scale","newZoom","zoomedViewport","zoomEnd","zoomIn","speed","zoomOut","moveLeft","moveRight","moveUp","moveDown","rotateLeft","rotateRight","rotateUp","rotateDown","_unproject","_calculateNewZoom","clamp","_panFromCenter","width","offset","_getUpdatedState","makeViewport","applyConstraints","Array","mod","transitionDuration","transitionInterpolator","transitionProps","compare","required"],"mappings":"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","sourcesContent":["import {clamp} from '@math.gl/core';\nimport Controller from './controller';\nimport ViewState from './view-state';\nimport {mod} from '../utils/math-utils';\n\nimport type Viewport from '../viewports/viewport';\nimport LinearInterpolator from '../transitions/linear-interpolator';\n\nexport type OrbitStateProps = {\n  width: number;\n  height: number;\n  target?: number[];\n  zoom?: number | number[];\n  rotationX?: number;\n  rotationOrbit?: number;\n\n  /** Viewport constraints */\n  maxZoom?: number;\n  minZoom?: number;\n  minRotationX?: number;\n  maxRotationX?: number;\n};\n\ntype OrbitStateInternal = {\n  startPanPosition?: number[];\n  startRotatePos?: number[];\n  startRotationX?: number;\n  startRotationOrbit?: number;\n  startZoomPosition?: number[];\n  startZoom?: number | number[];\n};\n\nexport class OrbitState extends ViewState<OrbitState, OrbitStateProps, OrbitStateInternal> {\n  makeViewport: (props: Record<string, any>) => Viewport;\n\n  constructor(\n    options: OrbitStateProps &\n      OrbitStateInternal & {\n        makeViewport: (props: Record<string, any>) => Viewport;\n      }\n  ) {\n    const {\n      /* Viewport arguments */\n      width, // Width of viewport\n      height, // Height of viewport\n      rotationX = 0, // Rotation around x axis\n      rotationOrbit = 0, // Rotation around orbit axis\n      target = [0, 0, 0],\n      zoom = 0,\n\n      /* Viewport constraints */\n      minRotationX = -90,\n      maxRotationX = 90,\n      minZoom = -Infinity,\n      maxZoom = Infinity,\n\n      /** Interaction states, required to calculate change during transform */\n      // Model state when the pan operation first started\n      startPanPosition,\n      // Model state when the rotate operation first started\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      // Model state when the zoom operation first started\n      startZoomPosition,\n      startZoom\n    } = options;\n\n    super(\n      {\n        width,\n        height,\n        rotationX,\n        rotationOrbit,\n        target,\n        zoom,\n        minRotationX,\n        maxRotationX,\n        minZoom,\n        maxZoom\n      },\n      {\n        startPanPosition,\n        startRotatePos,\n        startRotationX,\n        startRotationOrbit,\n        startZoomPosition,\n        startZoom\n      }\n    );\n\n    this.makeViewport = options.makeViewport;\n  }\n\n  /**\n   * Start panning\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  panStart({pos}: {pos: [number, number]}): OrbitState {\n    return this._getUpdatedState({\n      startPanPosition: this._unproject(pos)\n    });\n  }\n\n  /**\n   * Pan\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  pan({pos, startPosition}: {pos: [number, number]; startPosition?: number[]}): OrbitState {\n    const startPanPosition = this.getState().startPanPosition || startPosition;\n\n    if (!startPanPosition) {\n      return this;\n    }\n\n    const viewport = this.makeViewport(this.getViewportProps());\n    const newProps = viewport.panByPosition(startPanPosition, pos);\n\n    return this._getUpdatedState(newProps);\n  }\n\n  /**\n   * End panning\n   * Must call if `panStart()` was called\n   */\n  panEnd(): OrbitState {\n    return this._getUpdatedState({\n      startPanPosition: null\n    });\n  }\n\n  /**\n   * Start rotating\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  rotateStart({pos}: {pos: [number, number]}): OrbitState {\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startRotationX: this.getViewportProps().rotationX,\n      startRotationOrbit: this.getViewportProps().rotationOrbit\n    });\n  }\n\n  /**\n   * Rotate\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  rotate({\n    pos,\n    deltaAngleX = 0,\n    deltaAngleY = 0\n  }: {\n    pos?: [number, number];\n    deltaAngleX?: number;\n    deltaAngleY?: number;\n  }): OrbitState {\n    const {startRotatePos, startRotationX, startRotationOrbit} = this.getState();\n    const {width, height} = this.getViewportProps();\n\n    if (!startRotatePos || startRotationX === undefined || startRotationOrbit === undefined) {\n      return this;\n    }\n\n    let newRotation;\n    if (pos) {\n      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n\n      if (startRotationX < -90 || startRotationX > 90) {\n        // When looking at the \"back\" side of the scene, invert horizontal drag\n        // so that the camera movement follows user input\n        deltaScaleX *= -1;\n      }\n      newRotation = {\n        rotationX: startRotationX + deltaScaleY * 180,\n        rotationOrbit: startRotationOrbit + deltaScaleX * 180\n      };\n    } else {\n      newRotation = {\n        rotationX: startRotationX + deltaAngleY,\n        rotationOrbit: startRotationOrbit + deltaAngleX\n      };\n    }\n\n    return this._getUpdatedState(newRotation);\n  }\n\n  /**\n   * End rotating\n   * Must call if `rotateStart()` was called\n   */\n  rotateEnd(): OrbitState {\n    return this._getUpdatedState({\n      startRotationX: null,\n      startRotationOrbit: null\n    });\n  }\n\n  // shortest path between two view states\n  shortestPathFrom(viewState: OrbitState): OrbitStateProps {\n    const fromProps = viewState.getViewportProps();\n    const props = {...this.getViewportProps()};\n    const {rotationOrbit} = props;\n\n    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {\n      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;\n    }\n\n    return props;\n  }\n\n  /**\n   * Start zooming\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  zoomStart({pos}: {pos: [number, number]}): OrbitState {\n    return this._getUpdatedState({\n      startZoomPosition: this._unproject(pos),\n      startZoom: this.getViewportProps().zoom\n    });\n  }\n\n  /**\n   * Zoom\n   * @param {[Number, Number]} pos - position on screen where the current target is\n   * @param {[Number, Number]} startPos - the target position at\n   *   the start of the operation. Must be supplied of `zoomStart()` was not called\n   * @param {Number} scale - a number between [0, 1] specifying the accumulated\n   *   relative scale.\n   */\n  zoom({\n    pos,\n    startPos,\n    scale\n  }: {\n    pos: [number, number];\n    startPos?: [number, number];\n    scale: number;\n  }): OrbitState {\n    let {startZoom, startZoomPosition} = this.getState();\n    if (!startZoomPosition) {\n      // We have two modes of zoom:\n      // scroll zoom that are discrete events (transform from the current zoom level),\n      // and pinch zoom that are continuous events (transform from the zoom level when\n      // pinch started).\n      // If startZoom state is defined, then use the startZoom state;\n      // otherwise assume discrete zooming\n      startZoom = this.getViewportProps().zoom;\n      startZoomPosition = this._unproject(startPos) || this._unproject(pos);\n    }\n    if (!startZoomPosition) {\n      return this;\n    }\n    const newZoom = this._calculateNewZoom({scale, startZoom});\n    const zoomedViewport = this.makeViewport({...this.getViewportProps(), zoom: newZoom});\n\n    return this._getUpdatedState({\n      zoom: newZoom,\n      ...zoomedViewport.panByPosition(startZoomPosition, pos)\n    });\n  }\n\n  /**\n   * End zooming\n   * Must call if `zoomStart()` was called\n   */\n  zoomEnd(): OrbitState {\n    return this._getUpdatedState({\n      startZoomPosition: null,\n      startZoom: null\n    });\n  }\n\n  zoomIn(speed: number = 2): OrbitState {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({scale: speed})\n    });\n  }\n\n  zoomOut(speed: number = 2): OrbitState {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({scale: 1 / speed})\n    });\n  }\n\n  moveLeft(speed: number = 50): OrbitState {\n    return this._panFromCenter([-speed, 0]);\n  }\n\n  moveRight(speed: number = 50): OrbitState {\n    return this._panFromCenter([speed, 0]);\n  }\n\n  moveUp(speed: number = 50): OrbitState {\n    return this._panFromCenter([0, -speed]);\n  }\n\n  moveDown(speed: number = 50): OrbitState {\n    return this._panFromCenter([0, speed]);\n  }\n\n  rotateLeft(speed: number = 15): OrbitState {\n    return this._getUpdatedState({\n      rotationOrbit: this.getViewportProps().rotationOrbit - speed\n    });\n  }\n\n  rotateRight(speed: number = 15): OrbitState {\n    return this._getUpdatedState({\n      rotationOrbit: this.getViewportProps().rotationOrbit + speed\n    });\n  }\n\n  rotateUp(speed: number = 10): OrbitState {\n    return this._getUpdatedState({\n      rotationX: this.getViewportProps().rotationX - speed\n    });\n  }\n\n  rotateDown(speed: number = 10): OrbitState {\n    return this._getUpdatedState({\n      rotationX: this.getViewportProps().rotationX + speed\n    });\n  }\n\n  /* Private methods */\n\n  _unproject(pos?: number[]): number[] | undefined {\n    const viewport = this.makeViewport(this.getViewportProps());\n    // @ts-ignore\n    return pos && viewport.unproject(pos);\n  }\n\n  // Calculates new zoom\n  _calculateNewZoom({\n    scale,\n    startZoom\n  }: {\n    scale: number;\n    startZoom?: number | number[];\n  }): number | number[] {\n    const {maxZoom, minZoom} = this.getViewportProps();\n    if (startZoom === undefined) {\n      startZoom = this.getViewportProps().zoom;\n    }\n    const zoom = (startZoom as number) + Math.log2(scale);\n    return clamp(zoom, minZoom, maxZoom);\n  }\n\n  _panFromCenter(offset) {\n    const {width, height, target} = this.getViewportProps();\n    return this.pan({\n      startPosition: target,\n      pos: [width / 2 + offset[0], height / 2 + offset[1]]\n    });\n  }\n\n  _getUpdatedState(newProps): OrbitState {\n    // @ts-ignore\n    return new this.constructor({\n      makeViewport: this.makeViewport,\n      ...this.getViewportProps(),\n      ...this.getState(),\n      ...newProps\n    });\n  }\n\n  // Apply any constraints (mathematical or defined by _viewportProps) to map state\n  applyConstraints(props: Required<OrbitStateProps>): Required<OrbitStateProps> {\n    // Ensure zoom is within specified range\n    const {maxZoom, minZoom, zoom, maxRotationX, minRotationX, rotationOrbit} = props;\n\n    props.zoom = Array.isArray(zoom)\n      ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)]\n      : clamp(zoom, minZoom, maxZoom);\n\n    props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);\n    if (rotationOrbit < -180 || rotationOrbit > 180) {\n      props.rotationOrbit = mod(rotationOrbit + 180, 360) - 180;\n    }\n\n    return props;\n  }\n}\n\nexport default class OrbitController extends Controller<OrbitState> {\n  ControllerState = OrbitState;\n\n  transition = {\n    transitionDuration: 300,\n    transitionInterpolator: new LinearInterpolator({\n      transitionProps: {\n        compare: ['target', 'zoom', 'rotationX', 'rotationOrbit'],\n        required: ['target', 'zoom']\n      }\n    })\n  };\n}\n"]},"metadata":{},"sourceType":"module"}