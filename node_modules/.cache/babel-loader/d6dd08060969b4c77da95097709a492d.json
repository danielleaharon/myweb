{"ast":null,"code":"import OrthographicView from '../../views/orthographic-view';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\nimport { fitBounds } from '@math.gl/web-mercator';\nexport function getMaskBounds({\n  layers,\n  viewport\n}) {\n  let bounds = null;\n\n  for (const layer of layers) {\n    const subLayerBounds = layer.getBounds();\n\n    if (subLayerBounds) {\n      if (bounds) {\n        bounds[0] = Math.min(bounds[0], subLayerBounds[0][0]);\n        bounds[1] = Math.min(bounds[1], subLayerBounds[0][1]);\n        bounds[2] = Math.max(bounds[2], subLayerBounds[1][0]);\n        bounds[3] = Math.max(bounds[3], subLayerBounds[1][1]);\n      } else {\n        bounds = [subLayerBounds[0][0], subLayerBounds[0][1], subLayerBounds[1][0], subLayerBounds[1][1]];\n      }\n    }\n  }\n\n  const viewportBounds = viewport.getBounds();\n\n  if (!bounds) {\n    return viewportBounds;\n  }\n\n  const paddedBounds = _doubleBounds(viewportBounds);\n\n  if (bounds[2] - bounds[0] < paddedBounds[2] - paddedBounds[0] || bounds[3] - bounds[1] < paddedBounds[3] - paddedBounds[1]) {\n    return bounds;\n  }\n\n  bounds[0] = Math.max(bounds[0], paddedBounds[0]);\n  bounds[1] = Math.max(bounds[1], paddedBounds[1]);\n  bounds[2] = Math.min(bounds[2], paddedBounds[2]);\n  bounds[3] = Math.min(bounds[3], paddedBounds[3]);\n  return bounds;\n}\nexport function getMaskViewport({\n  bounds,\n  viewport,\n  width,\n  height\n}) {\n  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n    return null;\n  }\n\n  const padding = 1;\n  width -= padding * 2;\n  height -= padding * 2;\n\n  if (viewport instanceof WebMercatorViewport) {\n    const {\n      longitude,\n      latitude,\n      zoom\n    } = fitBounds({\n      width,\n      height,\n      bounds: [[bounds[0], bounds[1]], [bounds[2], bounds[3]]],\n      maxZoom: 20\n    });\n    return new WebMercatorViewport({\n      longitude,\n      latitude,\n      zoom,\n      x: padding,\n      y: padding,\n      width,\n      height\n    });\n  }\n\n  const center = [(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0];\n  const scale = Math.min(20, width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));\n  return new OrthographicView({\n    x: padding,\n    y: padding\n  }).makeViewport({\n    width,\n    height,\n    viewState: {\n      target: center,\n      zoom: Math.log2(scale)\n    }\n  });\n}\n\nfunction _doubleBounds(bounds) {\n  const size = {\n    x: bounds[2] - bounds[0],\n    y: bounds[3] - bounds[1]\n  };\n  const center = {\n    x: bounds[0] + 0.5 * size.x,\n    y: bounds[1] + 0.5 * size.y\n  };\n  return [center.x - size.x, center.y - size.y, center.x + size.x, center.y + size.y];\n}","map":{"version":3,"sources":["../../../../src/effects/mask/utils.ts"],"names":["viewport","bounds","subLayerBounds","layer","Math","viewportBounds","paddedBounds","_doubleBounds","height","padding","width","zoom","fitBounds","maxZoom","x","y","center","scale","viewState","target","size"],"mappings":"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","sourcesContent":["import OrthographicView from '../../views/orthographic-view';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\nimport {fitBounds} from '@math.gl/web-mercator';\n\nimport type Layer from '../../lib/layer';\nimport type Viewport from '../../viewports/viewport';\n\nexport type MaskBounds = [number, number, number, number];\n\n/*\n * Compute the bounds of the mask in world space, such that it covers an\n * area currently visible (extended by a buffer) or the area of the masking\n * data, whichever is smaller\n */\nexport function getMaskBounds({\n  layers,\n  viewport\n}: {\n  layers: Layer[];\n  viewport: Viewport;\n}): MaskBounds {\n  // Join the bounds of layer data\n  let bounds: MaskBounds | null = null;\n  for (const layer of layers) {\n    const subLayerBounds = layer.getBounds();\n    if (subLayerBounds) {\n      if (bounds) {\n        bounds[0] = Math.min(bounds[0], subLayerBounds[0][0]);\n        bounds[1] = Math.min(bounds[1], subLayerBounds[0][1]);\n        bounds[2] = Math.max(bounds[2], subLayerBounds[1][0]);\n        bounds[3] = Math.max(bounds[3], subLayerBounds[1][1]);\n      } else {\n        bounds = [\n          subLayerBounds[0][0],\n          subLayerBounds[0][1],\n          subLayerBounds[1][0],\n          subLayerBounds[1][1]\n        ];\n      }\n    }\n  }\n  const viewportBounds = viewport.getBounds();\n  if (!bounds) {\n    return viewportBounds;\n  }\n\n  // Expand viewport bounds by 2X. Heurestically chosen to avoid masking\n  // errors when mask is partially out of view\n  const paddedBounds = _doubleBounds(viewportBounds);\n\n  // When bounds of the mask are smaller than the viewport bounds simply use\n  // mask bounds, so as to maximize resolution & avoid mask rerenders\n  if (\n    bounds[2] - bounds[0] < paddedBounds[2] - paddedBounds[0] ||\n    bounds[3] - bounds[1] < paddedBounds[3] - paddedBounds[1]\n  ) {\n    return bounds;\n  }\n\n  // As viewport shrinks, to avoid pixelation along mask edges\n  // we need to reduce the bounds and only render the visible portion\n  // of the mask.\n  // We pad the viewport bounds to capture the section\n  // of the mask just outside the viewport to correctly maskByInstance.\n  // Intersect mask & padded viewport bounds\n  bounds[0] = Math.max(bounds[0], paddedBounds[0]);\n  bounds[1] = Math.max(bounds[1], paddedBounds[1]);\n  bounds[2] = Math.min(bounds[2], paddedBounds[2]);\n  bounds[3] = Math.min(bounds[3], paddedBounds[3]);\n  return bounds;\n}\n\n/*\n * Compute viewport to render the mask into, covering the given bounds\n */\nexport function getMaskViewport({\n  bounds,\n  viewport,\n  width,\n  height\n}: {\n  bounds: MaskBounds;\n  viewport: Viewport;\n  width: number;\n  height: number;\n}): Viewport | null {\n  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n    return null;\n  }\n\n  // Single pixel border to prevent mask bleeding at edge of texture\n  const padding = 1;\n  width -= padding * 2;\n  height -= padding * 2;\n\n  if (viewport instanceof WebMercatorViewport) {\n    const {longitude, latitude, zoom} = fitBounds({\n      width,\n      height,\n      bounds: [\n        [bounds[0], bounds[1]],\n        [bounds[2], bounds[3]]\n      ],\n      maxZoom: 20\n    });\n    return new WebMercatorViewport({\n      longitude,\n      latitude,\n      zoom,\n      x: padding,\n      y: padding,\n      width,\n      height\n    });\n  }\n\n  const center = [(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0];\n  const scale = Math.min(20, width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));\n\n  return new OrthographicView({\n    x: padding,\n    y: padding\n  }).makeViewport({\n    width,\n    height,\n    viewState: {\n      target: center,\n      zoom: Math.log2(scale)\n    }\n  });\n}\n\nfunction _doubleBounds(bounds: MaskBounds): MaskBounds {\n  const size = {\n    x: bounds[2] - bounds[0],\n    y: bounds[3] - bounds[1]\n  };\n  const center = {\n    x: bounds[0] + 0.5 * size.x,\n    y: bounds[1] + 0.5 * size.y\n  };\n  return [center.x - size.x, center.y - size.y, center.x + size.x, center.y + size.y];\n}\n"]},"metadata":{},"sourceType":"module"}