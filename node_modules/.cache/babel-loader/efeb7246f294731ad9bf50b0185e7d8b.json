{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { isArray } from '@math.gl/core';\nimport { getPolygonSignedArea, forEachSegmentInPolygon, modifyPolygonWindingDirection, getPolygonSignedAreaPoints, forEachSegmentInPolygonPoints, modifyPolygonWindingDirectionPoints } from './polygon-utils';\nexport default class Polygon {\n  constructor(points, options = {}) {\n    _defineProperty(this, \"points\", void 0);\n\n    _defineProperty(this, \"isFlatArray\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n\n    this.points = points;\n    this.isFlatArray = !isArray(points[0]);\n    this.options = {\n      start: options.start || 0,\n      end: options.end || points.length,\n      size: options.size || 2,\n      isClosed: options.isClosed\n    };\n    Object.freeze(this);\n  }\n\n  getSignedArea() {\n    if (this.isFlatArray) return getPolygonSignedArea(this.points, this.options);\n    return getPolygonSignedAreaPoints(this.points, this.options);\n  }\n\n  getArea() {\n    return Math.abs(this.getSignedArea());\n  }\n\n  getWindingDirection() {\n    return Math.sign(this.getSignedArea());\n  }\n\n  forEachSegment(visitor) {\n    if (this.isFlatArray) {\n      forEachSegmentInPolygon(this.points, (x1, y1, x2, y2, i1, i2) => {\n        visitor([x1, y1], [x2, y2], i1, i2);\n      }, this.options);\n    } else {\n      forEachSegmentInPolygonPoints(this.points, visitor, this.options);\n    }\n  }\n\n  modifyWindingDirection(direction) {\n    if (this.isFlatArray) {\n      return modifyPolygonWindingDirection(this.points, direction, this.options);\n    }\n\n    return modifyPolygonWindingDirectionPoints(this.points, direction, this.options);\n  }\n\n}","map":{"version":3,"sources":["../../src/polygon.ts"],"names":["constructor","options","isArray","points","start","end","size","isClosed","Object","getSignedArea","getPolygonSignedArea","getPolygonSignedAreaPoints","getArea","Math","getWindingDirection","forEachSegment","forEachSegmentInPolygon","visitor","forEachSegmentInPolygonPoints","modifyWindingDirection","modifyPolygonWindingDirection","modifyPolygonWindingDirectionPoints"],"mappings":";AACA,SAAA,OAAA,QAAA,eAAA;AAIA,SAAA,oBAAA,EAAA,uBAAA,EAAA,6BAAA,EAAA,0BAAA,EAAA,6BAAA,EAAA,mCAAA,QAAA,iBAAA;AAgBA,eAAe,MAAA,OAAA,CAAc;AAK3BA,EAAAA,WAAW,CAAA,MAAA,EAAoCC,OAAuB,GAA3D,EAAA,EAAkE;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,QAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,aAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,SAAA,EAAA,KAAA,CAAA,CAAA;;AAC3E,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,WAAA,GAAmB,CAACC,OAAO,CAACC,MAAM,CAAlC,CAAkC,CAAP,CAA3B;AAEA,SAAA,OAAA,GAAe;AACbC,MAAAA,KAAK,EAAEH,OAAO,CAAPA,KAAAA,IADM,CAAA;AAEbI,MAAAA,GAAG,EAAEJ,OAAO,CAAPA,GAAAA,IAAeE,MAAM,CAFb,MAAA;AAGbG,MAAAA,IAAI,EAAEL,OAAO,CAAPA,IAAAA,IAHO,CAAA;AAIbM,MAAAA,QAAQ,EAAEN,OAAO,CAACM;AAJL,KAAf;AAOAC,IAAAA,MAAM,CAANA,MAAAA,CAAAA,IAAAA;AACD;;AAMDC,EAAAA,aAAa,GAAW;AACtB,QAAI,KAAJ,WAAA,EAAsB,OAAOC,oBAAoB,CAAC,KAAD,MAAA,EAA8B,KAAzD,OAA2B,CAA3B;AAEtB,WAAOC,0BAA0B,CAAC,KAAD,MAAA,EAA4B,KAA7D,OAAiC,CAAjC;AACD;;AAMDC,EAAAA,OAAO,GAAW;AAChB,WAAOC,IAAI,CAAJA,GAAAA,CAAS,KAAhB,aAAgB,EAATA,CAAP;AACD;;AAMDC,EAAAA,mBAAmB,GAAW;AAC5B,WAAOD,IAAI,CAAJA,IAAAA,CAAU,KAAjB,aAAiB,EAAVA,CAAP;AACD;;AAMDE,EAAAA,cAAc,CAAA,OAAA,EAAsC;AAClD,QAAI,KAAJ,WAAA,EAAsB;AACpBC,MAAAA,uBAAuB,CACrB,KADqB,MAAA,EAGrB,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAA4B;AAE1BC,QAAAA,OAAO,CAAC,CAAA,EAAA,EAAD,EAAC,CAAD,EAAW,CAAA,EAAA,EAAX,EAAW,CAAX,EAAA,EAAA,EAAPA,EAAO,CAAPA;AALmB,OAAA,EAOrB,KAPFD,OAAuB,CAAvBA;AADF,KAAA,MAUO;AACLE,MAAAA,6BAA6B,CAAC,KAAD,MAAA,EAAA,OAAA,EAAqC,KAAlEA,OAA6B,CAA7BA;AACD;AACF;;AAODC,EAAAA,sBAAsB,CAAA,SAAA,EAA6B;AACjD,QAAI,KAAJ,WAAA,EAAsB;AACpB,aAAOC,6BAA6B,CAAC,KAAD,MAAA,EAAA,SAAA,EAAyC,KAA7E,OAAoC,CAApC;AACD;;AACD,WAAOC,mCAAmC,CAAC,KAAD,MAAA,EAAA,SAAA,EAAuC,KAAjF,OAA0C,CAA1C;AACD;;AA3E0B","sourcesContent":["/* eslint-disable no-undef, no-console */\nimport {isArray} from '@math.gl/core';\nimport type {SegmentVisitorPoints} from './polygon-utils';\nimport type {NumericArray} from '@math.gl/core';\n\nimport {\n  getPolygonSignedArea,\n  forEachSegmentInPolygon,\n  modifyPolygonWindingDirection,\n  getPolygonSignedAreaPoints,\n  forEachSegmentInPolygonPoints,\n  modifyPolygonWindingDirectionPoints\n} from './polygon-utils';\n\nexport type PolygonOptions = {\n  start?: number;\n  end?: number;\n  size?: number;\n  isClosed?: boolean;\n};\n\nexport default class Polygon {\n  points: NumericArray | number[][];\n  isFlatArray: boolean;\n  options: PolygonOptions;\n\n  constructor(points: NumericArray | number[][], options: PolygonOptions = {}) {\n    this.points = points;\n    this.isFlatArray = !isArray(points[0]);\n\n    this.options = {\n      start: options.start || 0,\n      end: options.end || points.length,\n      size: options.size || 2,\n      isClosed: options.isClosed\n    };\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Returns signed area of the polygon.\n   * @returns Signed area of the polygon.\n   */\n  getSignedArea(): number {\n    if (this.isFlatArray) return getPolygonSignedArea(this.points as NumericArray, this.options);\n\n    return getPolygonSignedAreaPoints(this.points as number[][], this.options);\n  }\n\n  /**\n   * Returns absolute area of the polygon.\n   * @returns Absolute area of the polygon.\n   */\n  getArea(): number {\n    return Math.abs(this.getSignedArea());\n  }\n\n  /**\n   * Returns winding direction of the polygon.\n   * @returns Winding direction of the polygon. 1 is for clockwise, -1 for counterclockwise winding direction.\n   */\n  getWindingDirection(): number {\n    return Math.sign(this.getSignedArea());\n  }\n\n  /**\n   * Calls the visitor callback for each segment in the polygon.\n   * @param visitor A callback to call for each segment.\n   */\n  forEachSegment(visitor: SegmentVisitorPoints): void {\n    if (this.isFlatArray) {\n      forEachSegmentInPolygon(\n        this.points as NumericArray,\n        // eslint-disable-next-line max-params\n        (x1, y1, x2, y2, i1, i2) => {\n          // TODO @igorDykhta original visitor uses arrays for each point, but with flat arrays performance degrades if we allocate points for each segment\n          visitor([x1, y1], [x2, y2], i1, i2);\n        },\n        this.options\n      );\n    } else {\n      forEachSegmentInPolygonPoints(this.points as number[][], visitor, this.options);\n    }\n  }\n\n  /**\n   * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n   * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n   * @return Returns true if the winding direction was changed.\n   */\n  modifyWindingDirection(direction: number): boolean {\n    if (this.isFlatArray) {\n      return modifyPolygonWindingDirection(this.points as NumericArray, direction, this.options);\n    }\n    return modifyPolygonWindingDirectionPoints(this.points as number[][], direction, this.options);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}