{"ast":null,"code":"import Viewport from '../viewports/viewport';\nimport { Matrix4, clamp } from '@math.gl/core';\nimport { pixelsToWorld } from '@math.gl/web-mercator';\nimport * as vec2 from 'gl-matrix/vec2';\nconst viewMatrix = new Matrix4().lookAt({\n  eye: [0, 0, 1]\n});\n\nfunction getProjectionMatrix({\n  width,\n  height,\n  near,\n  far,\n  padding\n}) {\n  let left = -width / 2;\n  let right = width / 2;\n  let bottom = -height / 2;\n  let top = height / 2;\n\n  if (padding) {\n    const {\n      left: l = 0,\n      right: r = 0,\n      top: t = 0,\n      bottom: b = 0\n    } = padding;\n    const offsetX = clamp((l + width - r) / 2, 0, width) - width / 2;\n    const offsetY = clamp((t + height - b) / 2, 0, height) - height / 2;\n    left -= offsetX;\n    right -= offsetX;\n    bottom += offsetY;\n    top += offsetY;\n  }\n\n  return new Matrix4().ortho({\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    far\n  });\n}\n\nexport default class OrthographicViewport extends Viewport {\n  constructor(props) {\n    const {\n      width,\n      height,\n      near = 0.1,\n      far = 1000,\n      zoom = 0,\n      target = [0, 0, 0],\n      padding = null,\n      flipY = true\n    } = props;\n    const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;\n    const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;\n    const zoom_ = Math.min(zoomX, zoomY);\n    const scale = Math.pow(2, zoom_);\n    let distanceScales;\n\n    if (zoomX !== zoomY) {\n      const scaleX = Math.pow(2, zoomX);\n      const scaleY = Math.pow(2, zoomY);\n      distanceScales = {\n        unitsPerMeter: [scaleX / scale, scaleY / scale, 1],\n        metersPerUnit: [scale / scaleX, scale / scaleY, 1]\n      };\n    }\n\n    super({ ...props,\n      longitude: undefined,\n      position: target,\n      viewMatrix: viewMatrix.clone().scale([scale, scale * (flipY ? -1 : 1), scale]),\n      projectionMatrix: getProjectionMatrix({\n        width: width || 1,\n        height: height || 1,\n        padding,\n        near,\n        far\n      }),\n      zoom: zoom_,\n      distanceScales\n    });\n  }\n\n  projectFlat([X, Y]) {\n    const {\n      unitsPerMeter\n    } = this.distanceScales;\n    return [X * unitsPerMeter[0], Y * unitsPerMeter[1]];\n  }\n\n  unprojectFlat([x, y]) {\n    const {\n      metersPerUnit\n    } = this.distanceScales;\n    return [x * metersPerUnit[0], y * metersPerUnit[1]];\n  }\n\n  panByPosition(coords, pixel) {\n    const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);\n    const toLocation = this.projectFlat(coords);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return {\n      target: this.unprojectFlat(newCenter)\n    };\n  }\n\n}","map":{"version":3,"sources":["../../../src/viewports/orthographic-viewport.ts"],"names":["viewMatrix","eye","padding","left","right","width","bottom","top","height","l","r","t","b","offsetX","clamp","offsetY","far","constructor","near","zoom","target","flipY","zoomX","Array","zoomY","zoom_","Math","scale","scaleX","scaleY","distanceScales","unitsPerMeter","metersPerUnit","longitude","position","projectionMatrix","getProjectionMatrix","projectFlat","X","Y","unprojectFlat","x","y","panByPosition","fromLocation","pixelsToWorld","toLocation","translate","vec2","newCenter"],"mappings":"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","sourcesContent":["import Viewport from '../viewports/viewport';\n\nimport {Matrix4, clamp} from '@math.gl/core';\nimport {pixelsToWorld} from '@math.gl/web-mercator';\nimport * as vec2 from 'gl-matrix/vec2';\n\nimport type {Padding} from './viewport';\n\nconst viewMatrix = new Matrix4().lookAt({eye: [0, 0, 1]});\n\nfunction getProjectionMatrix({\n  width,\n  height,\n  near,\n  far,\n  padding\n}: {\n  width: number;\n  height: number;\n  near: number;\n  far: number;\n  padding: Padding | null;\n}) {\n  let left = -width / 2;\n  let right = width / 2;\n  let bottom = -height / 2;\n  let top = height / 2;\n  if (padding) {\n    const {left: l = 0, right: r = 0, top: t = 0, bottom: b = 0} = padding;\n    const offsetX = clamp((l + width - r) / 2, 0, width) - width / 2;\n    const offsetY = clamp((t + height - b) / 2, 0, height) - height / 2;\n    left -= offsetX;\n    right -= offsetX;\n    bottom += offsetY;\n    top += offsetY;\n  }\n\n  return new Matrix4().ortho({\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    far\n  });\n}\n\nexport type OrthographicViewportOptions = {\n  /** Name of the viewport */\n  id?: string;\n  /** Left offset from the canvas edge, in pixels */\n  x?: number;\n  /** Top offset from the canvas edge, in pixels */\n  y?: number;\n  /** Viewport width in pixels */\n  width?: number;\n  /** Viewport height in pixels */\n  height?: number;\n  /** The world position at the center of the viewport. Default `[0, 0, 0]`. */\n  target?: [number, number, number] | [number, number];\n  /**  The zoom level of the viewport. `zoom: 0` maps one unit distance to one pixel on screen, and increasing `zoom` by `1` scales the same object to twice as large.\n   *   To apply independent zoom levels to the X and Y axes, supply an array `[zoomX, zoomY]`. Default `0`. */\n  zoom?: number | [number, number];\n  /** Padding around the viewport, in pixels. */\n  padding?: Padding | null;\n  /** Distance of near clipping plane. Default `0.1`. */\n  near?: number;\n  /** Distance of far clipping plane. Default `1000`. */\n  far?: number;\n  /** Whether to use top-left coordinates (`true`) or bottom-left coordinates (`false`). Default `true`. */\n  flipY?: boolean;\n};\n\nexport default class OrthographicViewport extends Viewport {\n  constructor(props: OrthographicViewportOptions) {\n    const {\n      width,\n      height,\n      near = 0.1,\n      far = 1000,\n      zoom = 0,\n      target = [0, 0, 0],\n      padding = null,\n      flipY = true\n    } = props;\n    const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;\n    const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;\n    const zoom_ = Math.min(zoomX, zoomY);\n    const scale = Math.pow(2, zoom_);\n\n    let distanceScales;\n    if (zoomX !== zoomY) {\n      const scaleX = Math.pow(2, zoomX);\n      const scaleY = Math.pow(2, zoomY);\n\n      distanceScales = {\n        unitsPerMeter: [scaleX / scale, scaleY / scale, 1],\n        metersPerUnit: [scale / scaleX, scale / scaleY, 1]\n      };\n    }\n\n    super({\n      ...props,\n      // in case viewState contains longitude/latitude values,\n      // make sure that the base Viewport class does not treat this as a geospatial viewport\n      longitude: undefined,\n      position: target,\n      viewMatrix: viewMatrix.clone().scale([scale, scale * (flipY ? -1 : 1), scale]),\n      projectionMatrix: getProjectionMatrix({\n        width: width || 1,\n        height: height || 1,\n        padding,\n        near,\n        far\n      }),\n      zoom: zoom_,\n      distanceScales\n    });\n  }\n\n  projectFlat([X, Y]: number[]): [number, number] {\n    const {unitsPerMeter} = this.distanceScales;\n    return [X * unitsPerMeter[0], Y * unitsPerMeter[1]];\n  }\n\n  unprojectFlat([x, y]: number[]): [number, number] {\n    const {metersPerUnit} = this.distanceScales;\n    return [x * metersPerUnit[0], y * metersPerUnit[1]];\n  }\n\n  /* Needed by LinearInterpolator */\n  panByPosition(coords: number[], pixel: number[]): OrthographicViewportOptions {\n    const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);\n    const toLocation = this.projectFlat(coords);\n\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n\n    return {target: this.unprojectFlat(newCenter)};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}