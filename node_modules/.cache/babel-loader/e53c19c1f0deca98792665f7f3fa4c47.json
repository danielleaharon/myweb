{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Layer, project32, picking, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport { lngLatToWorld } from '@math.gl/web-mercator';\nimport createMesh from './create-mesh';\nimport vs from './bitmap-layer-vertex';\nimport fs from './bitmap-layer-fragment';\nconst defaultProps = {\n  image: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  bounds: {\n    type: 'array',\n    value: [1, 0, 0, 1],\n    compare: true\n  },\n  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n  desaturate: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0\n  },\n  transparentColor: {\n    type: 'color',\n    value: [0, 0, 0, 0]\n  },\n  tintColor: {\n    type: 'color',\n    value: [255, 255, 255]\n  }\n};\nexport default class BitmapLayer extends Layer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking]\n    });\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.remove(['instancePickingColors']);\n    const noAlloc = true;\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: attribute => attribute.value = this.state.mesh.indices,\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        update: attribute => attribute.value = this.state.mesh.positions,\n        noAlloc\n      },\n      texCoords: {\n        size: 2,\n        update: attribute => attribute.value = this.state.mesh.texCoords,\n        noAlloc\n      }\n    });\n  }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }) {\n    const attributeManager = this.getAttributeManager();\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n\n    if (props.bounds !== oldProps.bounds) {\n      const oldMesh = this.state.mesh;\n\n      const mesh = this._createMesh();\n\n      this.state.model.setVertexCount(mesh.vertexCount);\n\n      for (const key in mesh) {\n        if (oldMesh && oldMesh[key] !== mesh[key]) {\n          attributeManager.invalidate(key);\n        }\n      }\n\n      this.setState({\n        mesh,\n        ...this._getCoordinateUniforms()\n      });\n    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {\n      this.setState(this._getCoordinateUniforms());\n    }\n  }\n\n  getPickingInfo(params) {\n    const {\n      image\n    } = this.props;\n    const info = params.info;\n\n    if (!info.color || !image) {\n      info.bitmap = null;\n      return info;\n    }\n\n    const {\n      width,\n      height\n    } = image;\n    info.index = 0;\n    const uv = unpackUVsFromRGB(info.color);\n    const pixel = [Math.floor(uv[0] * width), Math.floor(uv[1] * height)];\n    info.bitmap = {\n      size: {\n        width,\n        height\n      },\n      uv,\n      pixel\n    };\n    return info;\n  }\n\n  disablePickingIndex() {\n    this.setState({\n      disablePicking: true\n    });\n  }\n\n  restorePickingColors() {\n    this.setState({\n      disablePicking: false\n    });\n  }\n\n  _updateAutoHighlight(info) {\n    super._updateAutoHighlight({ ...info,\n      color: this.encodePickingColor(0)\n    });\n  }\n\n  _createMesh() {\n    const {\n      bounds\n    } = this.props;\n    let normalizedBounds = bounds;\n\n    if (isRectangularBounds(bounds)) {\n      normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];\n    }\n\n    return createMesh(normalizedBounds, this.context.viewport.resolution);\n  }\n\n  _getModel(gl) {\n    if (!gl) {\n      return null;\n    }\n\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 4,\n        vertexCount: 6\n      }),\n      isInstanced: false\n    });\n  }\n\n  draw(opts) {\n    const {\n      uniforms,\n      moduleParameters\n    } = opts;\n    const {\n      model,\n      coordinateConversion,\n      bounds,\n      disablePicking\n    } = this.state;\n    const {\n      image,\n      desaturate,\n      transparentColor,\n      tintColor\n    } = this.props;\n\n    if (moduleParameters.pickingActive && disablePicking) {\n      return;\n    }\n\n    if (image && model) {\n      model.setUniforms(uniforms).setUniforms({\n        bitmapTexture: image,\n        desaturate,\n        transparentColor: transparentColor.map(x => x / 255),\n        tintColor: tintColor.slice(0, 3).map(x => x / 255),\n        coordinateConversion,\n        bounds\n      }).draw();\n    }\n  }\n\n  _getCoordinateUniforms() {\n    const {\n      LNGLAT,\n      CARTESIAN,\n      DEFAULT\n    } = COORDINATE_SYSTEM;\n    let {\n      _imageCoordinateSystem: imageCoordinateSystem\n    } = this.props;\n\n    if (imageCoordinateSystem !== DEFAULT) {\n      const {\n        bounds\n      } = this.props;\n\n      if (!isRectangularBounds(bounds)) {\n        throw new Error('_imageCoordinateSystem only supports rectangular bounds');\n      }\n\n      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;\n      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;\n\n      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {\n        return {\n          coordinateConversion: -1,\n          bounds\n        };\n      }\n\n      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {\n        const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);\n        const topRight = lngLatToWorld([bounds[2], bounds[3]]);\n        return {\n          coordinateConversion: 1,\n          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]\n        };\n      }\n    }\n\n    return {\n      coordinateConversion: 0,\n      bounds: [0, 0, 0, 0]\n    };\n  }\n\n}\n\n_defineProperty(BitmapLayer, \"layerName\", 'BitmapLayer');\n\n_defineProperty(BitmapLayer, \"defaultProps\", defaultProps);\n\nfunction unpackUVsFromRGB(color) {\n  const [u, v, fracUV] = color;\n  const vFrac = (fracUV & 0xf0) / 256;\n  const uFrac = (fracUV & 0x0f) / 16;\n  return [(u + uFrac) / 256, (v + vFrac) / 256];\n}\n\nfunction isRectangularBounds(bounds) {\n  return Number.isFinite(bounds[0]);\n}","map":{"version":3,"sources":["../../../src/bitmap-layer/bitmap-layer.ts"],"names":["defaultProps","image","type","value","async","bounds","compare","_imageCoordinateSystem","COORDINATE_SYSTEM","desaturate","min","max","transparentColor","tintColor","BitmapLayer","getShaders","modules","initializeState","attributeManager","noAlloc","indices","size","isIndexed","update","attribute","positions","fp64","texCoords","updateState","changeFlags","gl","props","oldProps","oldMesh","mesh","getPickingInfo","info","params","height","uv","unpackUVsFromRGB","pixel","Math","disablePickingIndex","disablePicking","restorePickingColors","_updateAutoHighlight","color","_createMesh","normalizedBounds","isRectangularBounds","createMesh","_getModel","id","geometry","drawMode","vertexCount","isInstanced","draw","moduleParameters","model","bitmapTexture","x","_getCoordinateUniforms","DEFAULT","imageCoordinateSystem","defaultImageCoordinateSystem","coordinateConversion","bottomLeft","lngLatToWorld","topRight","vFrac","fracUV","uFrac","u","v","Number"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {\n  Layer,\n  project32,\n  picking,\n  CoordinateSystem,\n  COORDINATE_SYSTEM,\n  LayerProps,\n  PickingInfo,\n  GetPickingInfoParams,\n  UpdateParameters,\n  Color,\n  Texture,\n  Position,\n  DefaultProps\n} from '@deck.gl/core';\nimport {Model, Geometry} from '@luma.gl/core';\nimport {lngLatToWorld} from '@math.gl/web-mercator';\n\nimport createMesh from './create-mesh';\n\nimport vs from './bitmap-layer-vertex';\nimport fs from './bitmap-layer-fragment';\n\nconst defaultProps: DefaultProps<BitmapLayerProps> = {\n  image: {type: 'image', value: null, async: true},\n  bounds: {type: 'array', value: [1, 0, 0, 1], compare: true},\n  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n\n  desaturate: {type: 'number', min: 0, max: 1, value: 0},\n  // More context: because of the blending mode we're using for ground imagery,\n  // alpha is not effective when blending the bitmap layers with the base map.\n  // Instead we need to manually dim/blend rgb values with a background color.\n  transparentColor: {type: 'color', value: [0, 0, 0, 0]},\n  tintColor: {type: 'color', value: [255, 255, 255]}\n};\n\n/** All properties supported by BitmapLayer. */\nexport type BitmapLayerProps = _BitmapLayerProps & LayerProps;\nexport type BitmapBoundingBox =\n  | [left: number, bottom: number, right: number, top: number]\n  | [Position, Position, Position, Position];\n\n/** Properties added by BitmapLayer. */\ntype _BitmapLayerProps = {\n  /**\n   * The image to display.\n   *\n   * @default null\n   */\n  image?: string | Texture | null;\n\n  /**\n   * Supported formats:\n   *  - Coordinates of the bounding box of the bitmap `[left, bottom, right, top]`\n   *  - Coordinates of four corners of the bitmap, should follow the sequence of `[[left, bottom], [left, top], [right, top], [right, bottom]]`.\n   *   Each position could optionally contain a third component `z`.\n   * @default [1, 0, 0, 1]\n   */\n  bounds?: BitmapBoundingBox;\n\n  /**\n   * > Note: this prop is experimental.\n   *\n   * Specifies how image coordinates should be geographically interpreted.\n   * @default COORDINATE_SYSTEM.DEFAULT\n   */\n  _imageCoordinateSystem?: CoordinateSystem;\n\n  /**\n   * The desaturation of the bitmap. Between `[0, 1]`.\n   * @default 0\n   */\n  desaturate?: number;\n\n  /**\n   * The color to use for transparent pixels, in `[r, g, b, a]`.\n   * @default [0, 0, 0, 0]\n   */\n  transparentColor?: Color;\n\n  /**\n   * The color to tint the bitmap by, in `[r, g, b]`.\n   * @default [255, 255, 255]\n   */\n  tintColor?: Color;\n\n  /** Customize the [texture parameters](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter). */\n  textureParameters?: Record<number, number> | null;\n};\n\n/** Render a bitmap at specified boundaries. */\nexport default class BitmapLayer<ExtraPropsT = {}> extends Layer<\n  ExtraPropsT & Required<_BitmapLayerProps>\n> {\n  static layerName = 'BitmapLayer';\n  static defaultProps = defaultProps;\n\n  state!: Layer['state'] & {\n    disablePicking?: boolean;\n    model?: Model;\n    mesh?: any;\n    coordinateConversion?: number;\n    bounds?: number[];\n  };\n\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager()!;\n\n    attributeManager.remove(['instancePickingColors']);\n    const noAlloc = true;\n\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: attribute => (attribute.value = this.state.mesh.indices),\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        update: attribute => (attribute.value = this.state.mesh.positions),\n        noAlloc\n      },\n      texCoords: {\n        size: 2,\n        update: attribute => (attribute.value = this.state.mesh.texCoords),\n        noAlloc\n      }\n    });\n  }\n\n  updateState({props, oldProps, changeFlags}: UpdateParameters<this>): void {\n    // setup model first\n    const attributeManager = this.getAttributeManager()!;\n\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      this.state.model?.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n\n    if (props.bounds !== oldProps.bounds) {\n      const oldMesh = this.state.mesh;\n      const mesh = this._createMesh();\n      this.state.model.setVertexCount(mesh.vertexCount);\n      for (const key in mesh) {\n        if (oldMesh && oldMesh[key] !== mesh[key]) {\n          attributeManager.invalidate(key);\n        }\n      }\n      this.setState({mesh, ...this._getCoordinateUniforms()});\n    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {\n      this.setState(this._getCoordinateUniforms());\n    }\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): PickingInfo {\n    const {image} = this.props;\n    const info: PickingInfo & {bitmap?: any} = params.info;\n\n    if (!info.color || !image) {\n      info.bitmap = null;\n      return info;\n    }\n\n    const {width, height} = image as Texture;\n\n    // Picking color doesn't represent object index in this layer\n    info.index = 0;\n\n    // Calculate uv and pixel in bitmap\n    const uv = unpackUVsFromRGB(info.color);\n\n    const pixel = [Math.floor(uv[0] * (width as number)), Math.floor(uv[1] * (height as number))];\n\n    info.bitmap = {\n      size: {width, height}, // Size of bitmap\n      uv, // Floating point precision in 0-1 range\n      pixel // Truncated to integer and scaled to pixel size\n    };\n\n    return info;\n  }\n\n  // Override base Layer multi-depth picking logic\n  disablePickingIndex() {\n    this.setState({disablePicking: true});\n  }\n\n  restorePickingColors() {\n    this.setState({disablePicking: false});\n  }\n\n  protected _updateAutoHighlight(info) {\n    super._updateAutoHighlight({\n      ...info,\n      color: this.encodePickingColor(0)\n    });\n  }\n\n  protected _createMesh() {\n    const {bounds} = this.props;\n\n    let normalizedBounds = bounds;\n    // bounds as [minX, minY, maxX, maxY]\n    if (isRectangularBounds(bounds)) {\n      /*\n        (minX0, maxY3) ---- (maxX2, maxY3)\n               |                  |\n               |                  |\n               |                  |\n        (minX0, minY1) ---- (maxX2, minY1)\n     */\n      normalizedBounds = [\n        [bounds[0], bounds[1]],\n        [bounds[0], bounds[3]],\n        [bounds[2], bounds[3]],\n        [bounds[2], bounds[1]]\n      ];\n    }\n\n    return createMesh(normalizedBounds, this.context.viewport.resolution);\n  }\n\n  protected _getModel(gl: WebGLRenderingContext): Model {\n    if (!gl) {\n      return null;\n    }\n\n    /*\n      0,0 --- 1,0\n       |       |\n      0,1 --- 1,1\n    */\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLES,\n        vertexCount: 6\n      }),\n      isInstanced: false\n    });\n  }\n\n  draw(opts) {\n    const {uniforms, moduleParameters} = opts;\n    const {model, coordinateConversion, bounds, disablePicking} = this.state;\n    const {image, desaturate, transparentColor, tintColor} = this.props;\n\n    if (moduleParameters.pickingActive && disablePicking) {\n      return;\n    }\n\n    // // TODO fix zFighting\n    // Render the image\n    if (image && model) {\n      model\n        .setUniforms(uniforms)\n        .setUniforms({\n          bitmapTexture: image,\n          desaturate,\n          transparentColor: transparentColor.map(x => x / 255),\n          tintColor: tintColor.slice(0, 3).map(x => x / 255),\n          coordinateConversion,\n          bounds\n        })\n        .draw();\n    }\n  }\n\n  _getCoordinateUniforms() {\n    const {LNGLAT, CARTESIAN, DEFAULT} = COORDINATE_SYSTEM;\n    let {_imageCoordinateSystem: imageCoordinateSystem} = this.props;\n    if (imageCoordinateSystem !== DEFAULT) {\n      const {bounds} = this.props;\n      if (!isRectangularBounds(bounds)) {\n        throw new Error('_imageCoordinateSystem only supports rectangular bounds');\n      }\n\n      // The default behavior (linearly interpolated tex coords)\n      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;\n      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;\n\n      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {\n        // LNGLAT in Mercator, e.g. display LNGLAT-encoded image in WebMercator projection\n        return {coordinateConversion: -1, bounds};\n      }\n      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {\n        // Mercator in LNGLAT, e.g. display WebMercator encoded image in Globe projection\n        const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);\n        const topRight = lngLatToWorld([bounds[2], bounds[3]]);\n        return {\n          coordinateConversion: 1,\n          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]\n        };\n      }\n    }\n    return {\n      coordinateConversion: 0,\n      bounds: [0, 0, 0, 0]\n    };\n  }\n}\n\n/**\n * Decode uv floats from rgb bytes where b contains 4-bit fractions of uv\n * @param {number[]} color\n * @returns {number[]} uvs\n * https://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab\n */\nfunction unpackUVsFromRGB(color) {\n  const [u, v, fracUV] = color;\n  const vFrac = (fracUV & 0xf0) / 256;\n  const uFrac = (fracUV & 0x0f) / 16;\n  return [(u + uFrac) / 256, (v + vFrac) / 256];\n}\n\nfunction isRectangularBounds(\n  bounds: [number, number, number, number] | [Position, Position, Position, Position]\n): bounds is [number, number, number, number] {\n  return Number.isFinite(bounds[0]);\n}\n"]},"metadata":{},"sourceType":"module"}