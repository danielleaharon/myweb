{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport log from '../utils/log';\nimport { createMat4, getCameraPosition, getFrustumPlanes } from '../utils/math-utils';\nimport { Matrix4, Vector3, equals, clamp } from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\nimport { getDistanceScales, getMeterZoom, lngLatToWorld, worldToLngLat, worldToPixels, pixelsToWorld } from '@math.gl/web-mercator';\nimport { PROJECTION_MODE } from '../lib/constants';\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst IDENTITY = createMat4();\nconst ZERO_VECTOR = [0, 0, 0];\nconst DEFAULT_DISTANCE_SCALES = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\n\nfunction createProjectionMatrix({\n  width,\n  height,\n  orthographic,\n  fovyRadians,\n  focalDistance,\n  padding,\n  near,\n  far\n}) {\n  const aspect = width / height;\n  const matrix = orthographic ? new Matrix4().orthographic({\n    fovy: fovyRadians,\n    aspect,\n    focalDistance,\n    near,\n    far\n  }) : new Matrix4().perspective({\n    fovy: fovyRadians,\n    aspect,\n    near,\n    far\n  });\n\n  if (padding) {\n    const {\n      left = 0,\n      right = 0,\n      top = 0,\n      bottom = 0\n    } = padding;\n    const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;\n    const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;\n    matrix[8] -= offsetX * 2 / width;\n    matrix[9] += offsetY * 2 / height;\n  }\n\n  return matrix;\n}\n\nexport default class Viewport {\n  constructor(opts = {}) {\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"x\", void 0);\n\n    _defineProperty(this, \"y\", void 0);\n\n    _defineProperty(this, \"width\", void 0);\n\n    _defineProperty(this, \"height\", void 0);\n\n    _defineProperty(this, \"isGeospatial\", void 0);\n\n    _defineProperty(this, \"zoom\", void 0);\n\n    _defineProperty(this, \"focalDistance\", void 0);\n\n    _defineProperty(this, \"position\", void 0);\n\n    _defineProperty(this, \"modelMatrix\", void 0);\n\n    _defineProperty(this, \"distanceScales\", void 0);\n\n    _defineProperty(this, \"scale\", void 0);\n\n    _defineProperty(this, \"center\", void 0);\n\n    _defineProperty(this, \"cameraPosition\", void 0);\n\n    _defineProperty(this, \"projectionMatrix\", void 0);\n\n    _defineProperty(this, \"viewMatrix\", void 0);\n\n    _defineProperty(this, \"viewMatrixUncentered\", void 0);\n\n    _defineProperty(this, \"viewMatrixInverse\", void 0);\n\n    _defineProperty(this, \"viewProjectionMatrix\", void 0);\n\n    _defineProperty(this, \"pixelProjectionMatrix\", void 0);\n\n    _defineProperty(this, \"pixelUnprojectionMatrix\", void 0);\n\n    _defineProperty(this, \"resolution\", void 0);\n\n    _defineProperty(this, \"_frustumPlanes\", {});\n\n    this.id = opts.id || this.constructor.displayName || 'viewport';\n    this.x = opts.x || 0;\n    this.y = opts.y || 0;\n    this.width = opts.width || 1;\n    this.height = opts.height || 1;\n    this.zoom = opts.zoom || 0;\n    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;\n    this.focalDistance = opts.focalDistance || 1;\n    this.position = opts.position || ZERO_VECTOR;\n    this.modelMatrix = opts.modelMatrix || null;\n    const {\n      longitude,\n      latitude\n    } = opts;\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n\n    this._initProps(opts);\n\n    this._initMatrices(opts);\n\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n\n  get metersPerPixel() {\n    return this.distanceScales.metersPerUnit[2] / this.scale;\n  }\n\n  get projectionMode() {\n    if (this.isGeospatial) {\n      return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n    }\n\n    return PROJECTION_MODE.IDENTITY;\n  }\n\n  equals(viewport) {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n\n    if (this === viewport) {\n      return true;\n    }\n\n    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);\n  }\n\n  project(xyz, {\n    topLeft = true\n  } = {}) {\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  unproject(xyz, {\n    topLeft = true,\n    targetZ\n  } = {}) {\n    const [x, y, z] = xyz;\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  projectPosition(xyz) {\n    const [X, Y] = this.projectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz) {\n    const [X, Y] = this.unprojectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n\n  projectFlat(xyz) {\n    if (this.isGeospatial) {\n      const result = lngLatToWorld(xyz);\n      result[1] = clamp(result[1], -318, 830);\n      return result;\n    }\n\n    return xyz;\n  }\n\n  unprojectFlat(xyz) {\n    if (this.isGeospatial) {\n      return worldToLngLat(xyz);\n    }\n\n    return xyz;\n  }\n\n  getBounds(options = {}) {\n    const unprojectOption = {\n      targetZ: options.z || 0\n    };\n    const topLeft = this.unproject([0, 0], unprojectOption);\n    const topRight = this.unproject([this.width, 0], unprojectOption);\n    const bottomLeft = this.unproject([0, this.height], unprojectOption);\n    const bottomRight = this.unproject([this.width, this.height], unprojectOption);\n    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];\n  }\n\n  getDistanceScales(coordinateOrigin) {\n    if (coordinateOrigin) {\n      return getDistanceScales({\n        longitude: coordinateOrigin[0],\n        latitude: coordinateOrigin[1],\n        highPrecision: true\n      });\n    }\n\n    return this.distanceScales;\n  }\n\n  containsPixel({\n    x,\n    y,\n    width = 1,\n    height = 1\n  }) {\n    return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;\n  }\n\n  getFrustumPlanes() {\n    if (this._frustumPlanes.near) {\n      return this._frustumPlanes;\n    }\n\n    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));\n    return this._frustumPlanes;\n  }\n\n  panByPosition(coords, pixel) {\n    return null;\n  }\n\n  _initProps(opts) {\n    const longitude = opts.longitude;\n    const latitude = opts.latitude;\n\n    if (this.isGeospatial) {\n      if (!Number.isFinite(opts.zoom)) {\n        this.zoom = getMeterZoom({\n          latitude\n        }) + Math.log2(this.focalDistance);\n      }\n\n      this.distanceScales = opts.distanceScales || getDistanceScales({\n        latitude,\n        longitude\n      });\n    }\n\n    const scale = Math.pow(2, this.zoom);\n    this.scale = scale;\n    const {\n      position,\n      modelMatrix\n    } = opts;\n    let meterOffset = ZERO_VECTOR;\n\n    if (position) {\n      meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position, []) : position;\n    }\n\n    if (this.isGeospatial) {\n      const center = this.projectPosition([longitude, latitude, 0]);\n      this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);\n    } else {\n      this.center = this.projectPosition(meterOffset);\n    }\n  }\n\n  _initMatrices(opts) {\n    const {\n      viewMatrix = IDENTITY,\n      projectionMatrix = null,\n      orthographic = false,\n      fovyRadians,\n      fovy = 75,\n      near = 0.1,\n      far = 1000,\n      padding = null,\n      focalDistance = 1\n    } = opts;\n    this.viewMatrixUncentered = viewMatrix;\n    this.viewMatrix = new Matrix4().multiplyRight(viewMatrix).translate(new Vector3(this.center).negate());\n    this.projectionMatrix = projectionMatrix || createProjectionMatrix({\n      width: this.width,\n      height: this.height,\n      orthographic,\n      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n      focalDistance,\n      padding,\n      near,\n      far\n    });\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);\n    const viewportMatrix = createMat4();\n    const pixelProjectionMatrix = createMat4();\n    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n    this.pixelProjectionMatrix = pixelProjectionMatrix;\n    this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n\n    if (!this.pixelUnprojectionMatrix) {\n      log.warn('Pixel project matrix not invertible')();\n    }\n  }\n\n}\n\n_defineProperty(Viewport, \"displayName\", 'Viewport');","map":{"version":3,"sources":["../../../src/viewports/viewport.ts"],"names":["DEGREES_TO_RADIANS","Math","IDENTITY","createMat4","ZERO_VECTOR","DEFAULT_DISTANCE_SCALES","unitsPerMeter","metersPerUnit","far","aspect","width","matrix","orthographic","fovy","left","right","top","bottom","offsetX","clamp","offsetY","height","Viewport","constructor","opts","latitude","Number","metersPerPixel","projectionMode","PROJECTION_MODE","equals","viewport","project","topLeft","worldPosition","coord","worldToPixels","y2","xyz","unproject","targetZ","targetZWorld","pixelsToWorld","projectPosition","Z","unprojectPosition","projectFlat","result","lngLatToWorld","unprojectFlat","worldToLngLat","getBounds","options","unprojectOption","topRight","bottomLeft","bottomRight","getDistanceScales","longitude","coordinateOrigin","highPrecision","containsPixel","x","y","getFrustumPlanes","Object","panByPosition","_initProps","scale","modelMatrix","meterOffset","center","_initMatrices","viewMatrix","projectionMatrix","near","padding","focalDistance","createProjectionMatrix","fovyRadians","vpm","mat4","getCameraPosition","viewportMatrix","pixelProjectionMatrix","log"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../utils/log';\nimport {createMat4, getCameraPosition, getFrustumPlanes, FrustumPlane} from '../utils/math-utils';\n\nimport {Matrix4, Vector3, equals, clamp} from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\n\nimport {\n  getDistanceScales,\n  getMeterZoom,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  pixelsToWorld\n} from '@math.gl/web-mercator';\n\nimport {PROJECTION_MODE} from '../lib/constants';\n\nexport type DistanceScales = {\n  unitsPerMeter: number[];\n  metersPerUnit: number[];\n};\n\nexport type Padding = {\n  left?: number;\n  right?: number;\n  top?: number;\n  bottom?: number;\n};\n\nexport type ViewportOptions = {\n  /** Name of the viewport */\n  id?: string;\n  /** Left offset from the canvas edge, in pixels */\n  x?: number;\n  /** Top offset from the canvas edge, in pixels */\n  y?: number;\n  /** Viewport width in pixels */\n  width?: number;\n  /** Viewport height in pixels */\n  height?: number;\n  /** Longitude in degrees (geospatial only) */\n  longitude?: number;\n  /** Latitude in degrees (geospatial only) */\n  latitude?: number;\n  /** Viewport center in world space. If geospatial, refers to meter offsets from lng, lat */\n  position?: number[];\n  /** Zoom level */\n  zoom?: number;\n  /** Padding around the viewport, in pixels. */\n  padding?: Padding | null;\n  distanceScales?: DistanceScales;\n  /** Model matrix of viewport center */\n  modelMatrix?: number[] | null;\n  /** Custom view matrix */\n  viewMatrix?: number[];\n  /** Custom projection matrix */\n  projectionMatrix?: number[];\n  /** Modifier of viewport scale. Corresponds to the number of pixels per common unit at zoom 0. */\n  focalDistance?: number;\n  /** Use orthographic projection */\n  orthographic?: boolean;\n  /** fovy in radians. If supplied, overrides fovy */\n  fovyRadians?: number;\n  /** fovy in degrees. */\n  fovy?: number;\n  /** Near plane of the projection matrix */\n  near?: number;\n  /** Far plane of the projection matrix */\n  far?: number;\n};\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nconst IDENTITY = createMat4();\n\nconst ZERO_VECTOR = [0, 0, 0];\n\nconst DEFAULT_DISTANCE_SCALES: DistanceScales = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\n\n// / Helpers\nfunction createProjectionMatrix({\n  width,\n  height,\n  orthographic,\n  fovyRadians,\n  focalDistance,\n  padding,\n  near,\n  far\n}: {\n  width: number;\n  height: number;\n  orthographic: boolean;\n  fovyRadians: number;\n  focalDistance: number;\n  padding: Padding | null;\n  near: number;\n  far: number;\n}) {\n  const aspect = width / height;\n  const matrix = orthographic\n    ? new Matrix4().orthographic({fovy: fovyRadians, aspect, focalDistance, near, far})\n    : new Matrix4().perspective({fovy: fovyRadians, aspect, near, far});\n  if (padding) {\n    const {left = 0, right = 0, top = 0, bottom = 0} = padding;\n    const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;\n    const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;\n    // pixels to clip space\n    matrix[8] -= (offsetX * 2) / width;\n    matrix[9] += (offsetY * 2) / height;\n  }\n  return matrix;\n}\n\n/**\n * Manages coordinate system transformations.\n *\n * Note: The Viewport is immutable in the sense that it only has accessors.\n * A new viewport instance should be created if any parameters have changed.\n */\nexport default class Viewport {\n  static displayName = 'Viewport';\n\n  /** Init parameters */\n\n  id: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  isGeospatial: boolean;\n  zoom: number;\n  focalDistance: number;\n  position: number[];\n  modelMatrix: number[] | null;\n\n  /** Derived parameters */\n\n  // `!` post-fix expression operator asserts that its operand is non-null and non-undefined in contexts\n  // where the type checker is unable to conclude that fact.\n\n  distanceScales: DistanceScales; /** scale factors between world space and common space */\n  scale!: number; /** scale factor, equals 2^zoom */\n  center!: number[]; /** viewport center in common space */\n  cameraPosition!: number[]; /** Camera position in common space */\n  projectionMatrix!: number[];\n  viewMatrix!: number[];\n  viewMatrixUncentered!: number[];\n  viewMatrixInverse!: number[];\n  viewProjectionMatrix!: number[];\n  pixelProjectionMatrix!: number[];\n  pixelUnprojectionMatrix!: number[];\n  resolution?: number;\n\n  private _frustumPlanes: {[name: string]: FrustumPlane} = {};\n\n  constructor(opts: ViewportOptions = {}) {\n    // @ts-ignore\n    this.id = opts.id || this.constructor.displayName || 'viewport';\n\n    this.x = opts.x || 0;\n    this.y = opts.y || 0;\n    // Silently allow apps to send in w,h = 0,0\n    this.width = opts.width || 1;\n    this.height = opts.height || 1;\n    this.zoom = opts.zoom || 0;\n    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;\n    this.focalDistance = opts.focalDistance || 1;\n    this.position = opts.position || ZERO_VECTOR;\n    this.modelMatrix = opts.modelMatrix || null;\n\n    const {longitude, latitude} = opts;\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n\n    this._initProps(opts);\n    this._initMatrices(opts);\n\n    // Bind methods for easy access\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n\n  get metersPerPixel(): number {\n    return this.distanceScales.metersPerUnit[2] / this.scale;\n  }\n\n  get projectionMode(): number {\n    if (this.isGeospatial) {\n      return this.zoom < 12\n        ? PROJECTION_MODE.WEB_MERCATOR\n        : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n    }\n    return PROJECTION_MODE.IDENTITY;\n  }\n\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n  equals(viewport: Viewport): boolean {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n    if (this === viewport) {\n      return true;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      viewport.scale === this.scale &&\n      equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      equals(viewport.viewMatrix, this.viewMatrix)\n    );\n    // TODO - check distance scales?\n  }\n\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether projected coords are top left\n   * @return {Array} - [x, y] or [x, y, z] in top left coords\n   */\n  project(xyz: number[], {topLeft = true}: {topLeft?: boolean} = {}): number[] {\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates,\n   * (possibly [lon, lat]) on map.\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   * @param {Array} xyz -\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether origin is top left\n   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject(\n    xyz: number[],\n    {topLeft = true, targetZ}: {topLeft?: boolean; targetZ?: number} = {}\n  ): number[] {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ as number] : [X, Y];\n  }\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition(xyz: number[]): [number, number, number] {\n    const [X, Y] = this.projectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz: number[]): [number, number, number] {\n    const [X, Y] = this.unprojectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n  projectFlat(xyz: number[]): [number, number] {\n    if (this.isGeospatial) {\n      // Shader clamps latitude to +-89.9, see /shaderlib/project/project.glsl.js\n      // lngLatToWorld([0, -89.9])[1] = -317.9934163758329\n      // lngLatToWorld([0, 89.9])[1] = 829.9934163758271\n      const result = lngLatToWorld(xyz);\n      result[1] = clamp(result[1], -318, 830);\n      return result;\n    }\n    return xyz as [number, number];\n  }\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   * @param {object|Vector} xy - object with {x,y} members\n   *  representing point on projected map plane\n   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xyz: number[]): [number, number] {\n    if (this.isGeospatial) {\n      return worldToLngLat(xyz);\n    }\n    return xyz as [number, number];\n  }\n\n  /**\n   * Get bounds of the current viewport\n   * @return {Array} - [minX, minY, maxX, maxY]\n   */\n  getBounds(options: {z?: number} = {}): [number, number, number, number] {\n    const unprojectOption = {targetZ: options.z || 0};\n\n    const topLeft = this.unproject([0, 0], unprojectOption);\n    const topRight = this.unproject([this.width, 0], unprojectOption);\n    const bottomLeft = this.unproject([0, this.height], unprojectOption);\n    const bottomRight = this.unproject([this.width, this.height], unprojectOption);\n\n    return [\n      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),\n      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])\n    ];\n  }\n\n  getDistanceScales(coordinateOrigin?: number[]): DistanceScales {\n    if (coordinateOrigin) {\n      return getDistanceScales({\n        longitude: coordinateOrigin[0],\n        latitude: coordinateOrigin[1],\n        highPrecision: true\n      });\n    }\n    return this.distanceScales;\n  }\n\n  containsPixel({\n    x,\n    y,\n    width = 1,\n    height = 1\n  }: {\n    x: number;\n    y: number;\n    width?: number;\n    height?: number;\n  }): boolean {\n    return (\n      x < this.x + this.width &&\n      this.x < x + width &&\n      y < this.y + this.height &&\n      this.y < y + height\n    );\n  }\n\n  // Extract frustum planes in common space\n  getFrustumPlanes(): {\n    left: FrustumPlane;\n    right: FrustumPlane;\n    bottom: FrustumPlane;\n    top: FrustumPlane;\n    near: FrustumPlane;\n    far: FrustumPlane;\n  } {\n    if (this._frustumPlanes.near) {\n      // @ts-ignore\n      return this._frustumPlanes;\n    }\n\n    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));\n\n    // @ts-ignore\n    return this._frustumPlanes;\n  }\n\n  // EXPERIMENTAL METHODS\n\n  /**\n   * Needed by panning and linear transition\n   * Pan the viewport to place a given world coordinate at screen point [x, y]\n   *\n   * @param {Array} coords - world coordinates\n   * @param {Array} pixel - [x,y] coordinates on screen\n   * @return {Object} props of the new viewport\n   */\n  panByPosition(coords: number[], pixel: number[]): any {\n    return null;\n  }\n\n  // INTERNAL METHODS\n\n  /* eslint-disable complexity, max-statements */\n  private _initProps(opts: ViewportOptions) {\n    const longitude = opts.longitude as number;\n    const latitude = opts.latitude as number;\n\n    if (this.isGeospatial) {\n      if (!Number.isFinite(opts.zoom)) {\n        this.zoom = getMeterZoom({latitude}) + Math.log2(this.focalDistance);\n      }\n      this.distanceScales = opts.distanceScales || getDistanceScales({latitude, longitude});\n    }\n    const scale = Math.pow(2, this.zoom);\n    this.scale = scale;\n\n    const {position, modelMatrix} = opts;\n    let meterOffset: number[] = ZERO_VECTOR;\n    if (position) {\n      meterOffset = modelMatrix\n        ? (new Matrix4(modelMatrix).transformAsVector(position, []) as number[])\n        : position;\n    }\n\n    if (this.isGeospatial) {\n      // Determine camera center in common space\n      const center = this.projectPosition([longitude, latitude, 0]);\n\n      this.center = new Vector3(meterOffset)\n        // Convert to pixels in current zoom\n        .scale(this.distanceScales.unitsPerMeter)\n        .add(center);\n    } else {\n      this.center = this.projectPosition(meterOffset);\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n\n  private _initMatrices(opts: ViewportOptions) {\n    const {\n      // View matrix\n      viewMatrix = IDENTITY,\n      // Projection matrix\n      projectionMatrix = null,\n\n      // Projection matrix parameters, used if projectionMatrix not supplied\n      orthographic = false,\n      fovyRadians,\n      fovy = 75,\n      near = 0.1, // Distance of near clipping plane\n      far = 1000, // Distance of far clipping plane\n      padding = null, // Center offset in pixels\n      focalDistance = 1\n    } = opts;\n\n    this.viewMatrixUncentered = viewMatrix;\n    // Make a centered version of the matrix for projection modes without an offset\n    this.viewMatrix = new Matrix4()\n      // Apply the uncentered view matrix\n      .multiplyRight(viewMatrix)\n      // And center it\n      .translate(new Vector3(this.center).negate());\n\n    this.projectionMatrix =\n      projectionMatrix ||\n      createProjectionMatrix({\n        width: this.width,\n        height: this.height,\n        orthographic,\n        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n        focalDistance,\n        padding,\n        near,\n        far\n      });\n\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);\n\n    // Calculate inverse view matrix\n    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n\n    // Decompose camera parameters\n    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);\n\n    /*\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n\n    // matrix for conversion from world location to screen (pixel) coordinates\n    const viewportMatrix = createMat4(); // matrix from NDC to viewport.\n    const pixelProjectionMatrix = createMat4(); // matrix from world space to viewport.\n    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n    this.pixelProjectionMatrix = pixelProjectionMatrix;\n\n    this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n    if (!this.pixelUnprojectionMatrix) {\n      log.warn('Pixel project matrix not invertible')();\n      // throw new Error('Pixel project matrix not invertible');\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}